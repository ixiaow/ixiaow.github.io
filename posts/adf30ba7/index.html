<html>

<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Java高级语言特性 | Xiaowu</title>

<link rel="shortcut icon" href="https://jxiaow.gitee.io/favicon.ico?v=1608000428003">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://jxiaow.gitee.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">


<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>

<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>

<body>
    <div class="main gt-bg-theme-color-first">
        <nav class="navbar navbar-expand-lg">
    <a href="/">
        <div class="navbar-brand">
            <img class="user-avatar" src="/images/avatar.png" alt="头像">
            <div class="site-name gt-c-content-color-first">
                Xiaowu
            </div>
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav " style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://jxiaow.gitee.io/posts/favourite" class="menu gt-a-link">
                            收藏
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1608000428003" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

        <div class="post-container">

            <!-- <div class="post-detail gt-bg-theme-color-second"> -->
            <article style="display:flex;">
                <div class="post-detail gt-bg-theme-color-second gt-post-content">
                    <h2 class="post-title">
                        Java高级语言特性
                    </h2>
                    <div class="post-info">
                        <div>
                            <time class="post-time gt-c-content-color-first">
                                · 2019-10-28 ·
                            </time>
                            
                            <a href="https://jxiaow.gitee.io/tag/hIOPwCYeo/" class="post-tags">
                                # Java高级
                            </a>
                            
                        </div>
                        <div>
                            
                            <span id="/posts/adf30ba7/"
                                class="leancloud_visitors" data-flag-title="Java高级语言特性">
                                <em class="post-meta-item-text">阅读量 </em>
                                <i class="leancloud-visitors-count">0</i>
                            </span>
                            
                        </div>
                    </div>

                    <!-- <div class="post-content-wrapper"> -->
                    <div class="post-content">
                        <p>Java知识是作为Android开发的语言基础，虽然现在我们已经推出了kotlin，但是基于以下原因我们还是需要好好牢牢掌握java：</p>
<p>1）SDK还是改成java，kotlin也需要编译成为java运行；</p>
<p>2）目前大量的第三方库和继承与前任的代码都是java所写的；</p>
<p>3）Java语言应用不仅仅在Android，就是在后台开发中也是一个最流行的语言；</p>
<p>4）大公司面试都要求我们有扎实的Java语言基础。所以，请大家不要轻视提高自己Java基础的机会，请大家认真学习，做好笔记，争取取得更大的进步。</p>
<!-- more -->
<h1 id="java中的泛型">Java中的泛型</h1>
<h2 id="为什么我们需要泛型">为什么我们需要泛型?</h2>
<p>我们有如下两个场景：</p>
<ul>
<li>
<p>场景一：</p>
<p>实际开发中，经常有数值类型求和的需求，例如实现int类型的加法, 有时候还需要实现long类型的求和, 如果还需要double类型的求和，需要重新在重载一个输入是double类型的add方法。</p>
<pre><code class="language-java">public int addInt(int x, int y) {
    return x + y;
}

public float addFloat(float x, float y) {
    return x + y;
}
</code></pre>
</li>
<li>
<p>场景二</p>
<p>定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现错误。因为编译阶段正常，而运行时会出现 <code>ClassCastException</code> 异常。因此，导致此类错误编码过程中不易发现。</p>
<pre><code class="language-java">public class NonGeneric2 {

    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;字符串&quot;);
        list.add(&quot;string&quot;);
        list.add(12);

        for (int i = 0; i &lt; list.size(); i++) {
            String name = (String) list.get(i);
            System.out.println(&quot;name: &quot; + name);
        }
    }
}
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-02-42-generic.png" alt="generic.png" loading="lazy"></figure>
<p>在如上的编码过程中，我们发现主要存在两个问题：</p>
<p>​      1. 当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</p>
<ol start="2">
<li>因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</li>
</ol>
<p>所以泛型的好处就是：</p>
<ol>
<li>
<p>适用于多种数据类型执行相同的代码；</p>
</li>
<li>
<p>泛型中的类型在使用时指定，不需要强制类型转换。</p>
</li>
</ol>
<h2 id="泛型类和泛型接口">泛型类和泛型接口</h2>
<p>泛型，即“<strong>参数化类型</strong>”，就是<em>将类型由原来的具体类型参数化</em>，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<p>引入一个类型变量 <code>T</code>（其他大写字母都可以，不过常用的就是<code>T，E，K，V</code>等），并且用<code>&lt;&gt;</code>括起来，并放在类名的后面。泛型类是允许有多个类型变量的。</p>
<pre><code class="language-java">// 单个泛型类型参数
public class NormalGeneric&lt;T&gt; {
    private T data;

    public NormalGeneric(T t) {
        this.data = t;
    }
}
// 多个泛型类型参数
public class NormalGeneric2&lt;T, K&gt; {
    private T data;
    private K result;

    public NormalGeneric2(T t, K k) {
        this.data = t;
        this.result = k;
    }
}
</code></pre>
<p>泛型接口与泛型类的定义基本相同。</p>
<pre><code class="language-java">public interface Generator&lt;T&gt; {
    public T next();
}
</code></pre>
<p>而实现泛型接口的类，有两种实现方法：</p>
<ol>
<li>未传入泛型实参时:</li>
</ol>
<pre><code class="language-java">public class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt; {
    private T data;

    public GeneratorImpl(T data) {
        this.data = data;
    }
    @Override
    public T next() {
        return data;
    }
}
</code></pre>
<p>在new出类的实例时，需要指定具体类型：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Generator&lt;String&gt; generator = new GeneratorImpl&lt;&gt;(&quot;impl&quot;);
    System.out.println(generator.next());
}
</code></pre>
<ol start="2">
<li>
<p>传入泛型实参</p>
<pre><code class="language-java">public class GeneratorImpl2 implements Generator&lt;String&gt; {

 @Override
 public String next() {
     return &quot;ok&quot;;
 }
}
</code></pre>
<p>在new出类的实例时，和普通的类没区别。</p>
</li>
</ol>
<h2 id="泛型方法">泛型方法</h2>
<pre><code class="language-java">public class GeneratorMethod {
    // 泛型方法
    public &lt;T&gt; T generatorMethod(T... a) {
        return a[a.length / 2];
    }

    public static void main(String[] args) {
        GeneratorMethod generatorMethod = new GeneratorMethod();
        System.out.println(generatorMethod.generatorMethod(1, 2));
        System.out.println(generatorMethod.generatorMethod(&quot;1&quot;, &quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;));
    }
}
</code></pre>
<p>泛型方法，是在调用方法的时候指明泛型的具体类型 ，泛型方法可以在任何地方和任何场景中使用，包括普通类和泛型类。注意泛型类中定义的普通方法和泛型方法的区别。</p>
<p>普通方法：</p>
<pre><code class="language-java">public class Generic&lt;T&gt; {
    private T data;

    public Generic(T t) {
        this.data = t;
    }
    // 此方法是普通方法，不是泛型方法
    public T getData() {
        return data;
    }
}
</code></pre>
<p>泛型方法</p>
<pre><code class="language-java">public &lt;T&gt; T showKeyName(Generic&lt;T&gt; generic) {
    System.out.println(&quot;data: &quot; + generic.getData());
    return generic.getData();
}
</code></pre>
<h2 id="限定类型变量">限定类型变量</h2>
<p>有时候，我们需要对类型变量加以约束，比如计算两个变量的最小，最大值。</p>
<pre><code class="language-java">public static &lt;T&gt; T min(T a, T b) {
    return a.compareTo(b) &gt; 0 ? a : b;
}
</code></pre>
<p>请问，如果确保传入的两个变量一定有compareTo方法？那么解决这个问题的方案就是将T限制为实现了接口Comparable的类</p>
<pre><code class="language-java">public static &lt;T extends Comparable&gt; T min(T a, T b) {
    return a.compareTo(b) &gt; 0 ? a : b;
}
</code></pre>
<p><code>T extends Comparable</code> 中</p>
<p>T 表示应该绑定类型的子类型，Comparable 表示绑定类型，子类型和绑定类型可以是类也可以是接口。</p>
<p>如果这个时候，我们试图传入一个没有实现接口Comparable的类的实例，将会发生编译错误。</p>
<pre><code class="language-java">public static void main(String[] args) {
    System.out.println(min(1, 2));
    System.out.println(min(&quot;aaaa&quot;, &quot;bbbb&quot;));
    // 下面是编译会报错
    System.out.println(min(new GeneratorImpl2(), new GeneratorImpl2()));
}
</code></pre>
<p>同时<code>extends</code>左右都允许有多个，如<code>T,V extends Comparable &amp; Serializable</code></p>
<p><font color='red'>注意限定类型中，只允许有一个类，而且如果有类，这个类必须是限定列表的第一个</font>。</p>
<p>这种类的限定既可以用在泛型方法上也可以用在泛型类上。</p>
<h2 id="泛型中的约束和局限性">泛型中的约束和局限性</h2>
<p>现在我们有泛型类</p>
<pre><code class="language-java">public class Restrict&lt;T&gt; {} 
</code></pre>
<h3 id="不能用基本类型实例化类型参数">不能用基本类型实例化类型参数</h3>
<pre><code class="language-java">// 编译报错
Restrict&lt;int&gt; restrict = new Restrict&lt;&gt;();
</code></pre>
<h3 id="运行时类型检查只适用于原始类型">运行时类型检查只适用于原始类型</h3>
<pre><code class="language-java">Restrict&lt;Boolean&gt; restrict = new Restrict&lt;&gt;();
Restrict&lt;String&gt; stringRestrict = new Restrict&lt;&gt;();

// 这种操作不被允许，编译时报错
//if (restrict instanceof Restrict&lt;Boolean&gt;) {}
// 这种操作不被允许，编译时报错
//if (restrict instanceof Restrict&lt;T&gt;) {}

System.out.println(restrict.getClass() == stringRestrict.getClass());
System.out.println(restrict.getClass().getName());
</code></pre>
<h3 id="泛型类的静态上下文中类型变量失效">泛型类的静态上下文中类型变量失效</h3>
<pre><code class="language-java"> // 静态域或方法里不能引用类型变量
 // protected static T instance;
</code></pre>
<p>不能在<code>静态域或方法</code>中引用<code>类型变量</code>。因为泛型是要在对象创建时才知道具体类型，而对象创建的代码执行先后顺序是static的部分，然后才是构造函数等。所以在对象初始化之前static的部分已经执行了，如果你在静态部分引用的泛型，那么毫无疑问虚拟机根本不知道是什么东西，因为这个时候类还没有初始化。</p>
<h3 id="不能创建参数化类型的数组">不能创建参数化类型的数组</h3>
<pre><code class="language-java">Restrict&lt;Double&gt;[] restricts; // 可以
// Restrict&lt;Double&gt;[] doubleRestricts = new Restrict&lt;Double&gt;[10]; // 不允许
</code></pre>
<h3 id="不能实例化类型变量">不能实例化类型变量</h3>
<pre><code class="language-java">private Restrict() {
    // 不能实例化类型变量
    // this.data = new T();
}
</code></pre>
<h3 id="不能捕获泛型类的实例">不能捕获泛型类的实例</h3>
<pre><code class="language-java">// 泛型类不能继承Exception/Throwable
// public class Problem&lt;T&gt; extends Exception{}

// 不能捕获泛型类对象
// public &lt;T extends Throwable&gt; void doWork(T t) {
    // try {
    // } catch (T e) {
    // }
// }
</code></pre>
<p>但是这样可以：</p>
<pre><code class="language-java">public &lt;T extends Throwable&gt; void doWork(T t) throws T {
    try {
    } catch (Throwable e) {
        throw t;
    }
}
</code></pre>
<h2 id="泛型类型的继承规则">泛型类型的继承规则</h2>
<p>现在我们有一个类、子类和泛型类</p>
<pre><code class="language-java">public class Employee {}

public class Worker extends Employee {}

public class Pair&lt;T&gt; {}
</code></pre>
<p>那么<code>Pair&lt;Employee&gt;</code>和<code>Pair&lt;Worker&gt;</code>是没有任何关系的：</p>
<pre><code class="language-java">Employee employee = new Worker();
// 编译报错
// Pair&lt;Employee&gt; employeePair = new Pair&lt;Worker&gt;();
</code></pre>
<p>但是<code>泛型类</code>可以<code>继承或者扩展其他泛型类</code>，比如List和ArrayList</p>
<pre><code class="language-java">public class ExtendPair&lt;T&gt; extends Pair&lt;T&gt; {}
// 允许
Pair&lt;Employee&gt; employeePair = new ExtendPair&lt;&gt;();
</code></pre>
<h2 id="通配符类型">通配符类型</h2>
<p>正是因为前面所述的，<code>Pair&lt;Employee&gt;</code>和<code>Pair&lt;Worker&gt;</code>没有任何关系，如果我们有一个泛型类和一个方法</p>
<pre><code class="language-java">public static void print(GenericType&lt;Fruit&gt; p) {
    System.out.println(p.getData().getColor());
}

public class GenericType&lt;T&gt; {}
</code></pre>
<p>现在我们有继承关系的类:</p>
<pre><code class="language-java">public class Fruit { }

public class Orange extends Fruit {}

public class Apple extends Fruit {}

public class HongFuShi extends Apple {}
</code></pre>
<p>则会产生这种情况：</p>
<pre><code class="language-java">public static void main(String[] args) {
    GenericType&lt;Fruit&gt; fruitGenericType = new GenericType&lt;&gt;();
    print(fruitGenericType);

    GenericType&lt;Orange&gt; orangeGenericType = new GenericType&lt;&gt;();
    // print(orangeGenericType); // 此处不被允许，编译报错
}
</code></pre>
<p>为解决这个问题，于是提出了一个<code>通配符类型 ?</code></p>
<p>有两种使用方式：</p>
<p><code>？ extends X</code> 表示类型的上界，类型参数是X的子类</p>
<p><code>？ super X</code> 表示类型的下界，类型参数是X的超类</p>
<p>这两种 方式从名字上来看，特别是super，很有迷惑性，下面我们来仔细辨析这两种方法。</p>
<h3 id="extends-x">？ extends X</h3>
<p>表示传递给方法的参数，必须是X的子类（包括X本身）</p>
<pre><code class="language-java">public static void print2(GenericType&lt;? extends Fruit&gt; p) {
    System.out.println(p.getData().getColor());
}

public static void main(String[] args) {
    GenericType&lt;Fruit&gt; fruitGenericType = new GenericType&lt;&gt;();
    print2(fruitGenericType);

    GenericType&lt;Orange&gt; orangeGenericType = new GenericType&lt;&gt;();
    print2(orangeGenericType); 
}
</code></pre>
<p>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法是不允许被调用的，会出现编译错误</p>
<pre><code class="language-java">public class GenericType&lt;T&gt; {
    private T data;
    public T getData() {
        return data;
    }
    public void setData(T data) {
        this.data = data;
    }

    public static void main(String[] args) {
        GenericType&lt;? extends Fruit&gt; fruitGenericType = new GenericType&lt;&gt;();
        Apple apple = new Apple();
        // 这样不被允许
        fruitGenericType.setData(apple);
        // 这样是可以的
        Fruit fruit = fruitGenericType.getData();
    }
}
</code></pre>
<p>get方法则没问题，会返回一个Fruit类型的值。</p>
<p>这是因为<code>？ extends X</code>  表示类型的上界，类型参数是X的子类，那么可以肯定的说，get方法返回的一定是个X（不管是X或者X的子类）编译器是可以确定知道的。但是set方法只知道传入的是个X，至于具体是X的那个子类，不知道。</p>
<p>总结：主要用于安全地访问数据，可以访问X及其子类型，并且不能写入非null的数据。</p>
<h3 id="super-x">？ super X</h3>
<p>表示传递给方法的参数，必须是X的超类（包括X本身）</p>
<pre><code class="language-java">public static void printSuper(GenericType&lt;? super Apple&gt; p) {
    System.out.println(p.getData());
}

public static void main(String[] args) {
    GenericType&lt;Fruit&gt; fruitGenericType = new GenericType&lt;&gt;();
    GenericType&lt;Orange&gt; orangeGenericType = new GenericType&lt;&gt;();
    GenericType&lt;Apple&gt; appleGenericType = new GenericType&lt;&gt;();
    GenericType&lt;HongFuShi&gt; shiGenericType = new GenericType&lt;&gt;();
    printSuper(fruitGenericType);
    printSuper(appleGenericType);
    // 编译出错
    printSuper(orangeGenericType);
    // 编译出错
    printSuper(shiGenericType);
}
</code></pre>
<p>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法可以被调用的，且能传入的参数只能是X或者X的子类</p>
<pre><code class="language-java">public class GenericType&lt;T&gt; {
    private T data;
    public T getData() {
        return data;
    }
    public void setData(T data) {
        this.data = data;
    }
    public static void main(String[] args) {
        GenericType&lt;? super Apple&gt; fruitGenericType = new GenericType&lt;&gt;();
        fruitGenericType.setData(new Apple());
        fruitGenericType.setData(new HongFuShi());
        // 此操作不被允许
        fruitGenericType.setData(new Orange());
        // 此操作不被允许
        fruitGenericType.setData(new Fruit());

        Object object = fruitGenericType.getData();
    }
}
</code></pre>
<p>get方法只会返回一个Object类型的值。</p>
<p>这是因为，<code>？ super X</code>  表示类型的下界，类型参数是X的超类（包括X本身），那么可以肯定的说，get方法返回的一定是个X的超类，那么到底是哪个超类？不知道，但是可以肯定的说，Object一定是它的超类，所以get方法返回Object。编译器是可以确定知道的。对于set方法来说，编译器不知道它需要的确切类型，但是X和X的子类可以安全的转型为X。</p>
<p>总结：主要用于安全地写入数据，可以写入X及其子类型。</p>
<h3 id="无限定的通配符">无限定的通配符 ?</h3>
<p>表示对类型没有什么限制，可以把<code>？</code>看成所有类型的父类，如<code>Pair&lt; ?&gt;</code>；</p>
<p>比如：</p>
<p><code>ArrayList&lt;T&gt; al=new ArrayList&lt;T&gt;();</code> 指定集合元素只能是T类型</p>
<p><code>ArrayList&lt;?&gt; al=new ArrayList&lt;?&gt;();</code>集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法。</p>
<p>在使用上：</p>
<p><code>？ getFirst()</code> ： 返回值只能赋给 Object，；</p>
<p><code>void setFirst(?)</code> ： setFirst 方法不能被调用， 甚至不能用 Object 调用；</p>
<h2 id="虚拟机是如何实现泛型的">虚拟机是如何实现泛型的？</h2>
<p>泛型思想早在<code>C++</code>语言的<code>模板（Template）</code>中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。由于Java语言里面所有的类型都继承于<code>java.lang.Object</code>，所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多<code>ClassCastException</code>的风险就会转嫁到程序运行期之中。</p>
<p>泛型技术在<code>C#</code>和<code>Java</code>之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，<code>List＜int＞</code>与<code>List＜String＞</code>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为<code>真实泛型</code>。</p>
<p>Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，<code>ArrayList＜Integer＞</code>与<code>ArrayList＜String＞</code>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为<code>类型擦除</code>，基于这种方法实现的泛型称为<code>伪泛型</code>。</p>
<h2 id="通过反射获取泛型信息">通过反射获取泛型信息</h2>
<p>由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。因此，JCP组织对虚拟机规范做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[3]，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</p>
<p>另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p>
<h1 id="反射原理及动态代理模式">反射原理及动态代理模式</h1>
<h2 id="反射reflect">反射（Reflect）</h2>
<p>反射之中包含了一个<code>「反」</code>字，所以了解反射我们先从<code>「正」</code>开始。</p>
<p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p>
<p>反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用<code>new</code> 关键字来创建对象了。这时候，我们使用 JDK 提供的反射 API 进行反射调用。<strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p>
<p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。</p>
<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>
<p>在运行时构造任意一个类的对象</p>
</li>
<li>
<p>在运行时获取任意一个类所具有的成员变量和方法</p>
</li>
<li>
<p>在运行时调用任意一个对象的方法（属性）</p>
</li>
</ul>
<p>Java 是一门面向对象的语言。在面向对象的世界里，万事万物皆对象，既然万事万物皆对象，那么我们的类是不是对象呢？我们写的每一个类都可以看成一个对象，是<code>java.lang.Class</code> 类的对象。每一个类对应的Class放在哪里呢？当我们写完一个类的Java文件，编译成class文件的时候，编译器都会将这个类的对应的class对象放在class文件的末尾。里面都保存了些什么？大家可以理解保存了类的元数据信息，一个类的元数据信息包括什么？有哪些属性，方法，构造器，实现了哪些接口等等，那么这些信息在Java里都有对应的类来表示。</p>
<h3 id="class类">Class类</h3>
<p><strong>Class是一个类，封装了当前对象所对应的类的信息</strong></p>
<p>一个类中有属性，方法，构造器等，比如说有一个Person类，一个Order类，一个Book类，这些都是不同的类，现在需要一个类，用来描述类，这就是Class，它应该有类名，属性，方法，构造器等。Class是用来描述类的类。</p>
<p>Class类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等</p>
<p>对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。</p>
<p>对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个Class实例</p>
<p>获取Class对象的三种方式</p>
<p>1.通过类名获取      类名.class</p>
<p>2.通过对象获取      对象名.getClass()</p>
<p>3.通过全类名获取    Class.forName(全类名)</p>
<p>Class类的常用方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static Class&lt;?&gt; forName(String className)</td>
<td style="text-align:center">返回指定类名name的class</td>
</tr>
<tr>
<td style="text-align:center">public T newInstance()</td>
<td style="text-align:center">调用缺省构造函数，返回该class对象的一个实例</td>
</tr>
<tr>
<td style="text-align:center">public T newInstance(Object ... initargs)</td>
<td style="text-align:center">返回当前格式构造函数，返回该Class对象的一个实例</td>
</tr>
<tr>
<td style="text-align:center">getName()</td>
<td style="text-align:center">返回此Class对象所标识的实体（类，接口，数组类，基本类型或void）名称</td>
</tr>
<tr>
<td style="text-align:center">Class getSuperClass()</td>
<td style="text-align:center">返回当前Class对象的父类的Class对象</td>
</tr>
<tr>
<td style="text-align:center">Class[] getInterfaces()</td>
<td style="text-align:center">获取当前Class对象的接口</td>
</tr>
<tr>
<td style="text-align:center">ClassLoader getClassLoader()</td>
<td style="text-align:center">返回该类的类加载器</td>
</tr>
</tbody>
</table>
<h3 id="代理模式和静态代理">代理模式和静态代理</h3>
<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>
<p>目的：（1）通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性； （2）通过代理对象对原有的业务增强；</p>
<p>代理模式一般会有三个角色：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/09-23-57-06-proxy.png" alt="proxy.png" loading="lazy"></figure>
<p><strong>抽象角色</strong>：指代理角色和真实角色对外提供的公共方法，一般为一个接口</p>
<p><strong>真实角色</strong>：需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业务逻辑在此。</p>
<p><strong>代理角色</strong>：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。将统一的流程控制都放到代理角色中处理！</p>
<p>而访问者不再访问真实角色，而是去访问代理角色。</p>
<p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。一般来说，被代理对象和代理对象是一对一的关系，当然一个代理对象对应多个被代理对象也是可以的。</p>
<p>静态代理，一对一则会出现时静态代理对象量多、代码量大，从而导致代码复杂，可维护性差的问题，一对多则代理对象会出现扩展能力差的问题。</p>
<h3 id="动态代理"><strong>动态代理</strong></h3>
<p>是指在使用时再创建代理类和实例</p>
<p><strong>优点</strong></p>
<p>只需要1个动态代理类就可以解决创建多个静态代理的问题，避免重复、多余代码</p>
<p>更强的灵活性</p>
<p><strong>缺点</strong></p>
<p>效率低，相比静态代理中 直接调用目标对象方法，动态代理则需要先通过Java反射机制 从而 间接调用目标对象方法</p>
<p>应用场景局限，因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），即只能针对接口 创建 代理类，不能针对类创建代理类。</p>
<p>在java的动态代理机制中，有两个重要的类或接口，一个是InvocationHandler接口、另一个则是 Proxy类，这个类和接口是实现我们动态代理所必须用到的。</p>
<p><code>InvocationHandler</code>接口是给动态代理类实现的，负责处理被代理对象的操作的，而<code>Proxy</code>是用来创建动态代理类实例对象的，因为只有得到了这个对象我们才能调用那些需要代理的方法。</p>
<p>动态代理用例：</p>
<pre><code class="language-java">public static void main(String[] args) {
   // 真实对象
   HuaWeiFactory huaWeiFactory = new HuaWeiFactory();
    // 根据真实对象动态生成的代理对象
   PhoneFactory instance = (PhoneFactory) Proxy.newProxyInstance(huaWeiFactory.getClass().getClassLoader(),
         huaWeiFactory.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] objects) throws Throwable {
                 if (method.getName().equals(&quot;productPhone&quot;)) {
                     System.out.println(&quot;拦截到方法了.........&quot;);
                     return method.invoke(huaWeiFactory, objects);
                 }
                     return method.invoke(huaWeiFactory, objects);
             }
         });
    instance.productPhone(&quot;哈哈哈&quot;);
  }
</code></pre>
<h4 id="动态代理实现原理">动态代理实现原理</h4>
<p>观察Proxy.<em>newProxyInstance</em>方法，与创建对象有关的代码主要有：</p>
<p>获得代理类的class对象：</p>
<pre><code class="language-java">/*
 * Look up or generate the designated proxy class.
 */
Class&lt;?&gt; cl = getProxyClass0(loader, intfs);
</code></pre>
<p>获得代理类的构造器：</p>
<pre><code class="language-java">  final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
</code></pre>
<p>创建代理类的实例</p>
<pre><code class="language-java">return cons.newInstance(new Object[]{h});
</code></pre>
<p>看来其中的关键点就是如何获得代理类的class对象，我们进入**<code>getProxyClass0</code><strong>方法，进而进入</strong><code>proxyClassCache.get</code>**方法，通过这个方法所在的类名，我们可以推测，JDK内部使用了某种机制缓存了我们的代理类的class对象，同时get方法接受的参数是被代理类的类加载器和类实现的的接口。</p>
<p>然后我们查看<code>proxyClassCache</code>的初始化的方法：</p>
<pre><code class="language-java">private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;
        proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());
</code></pre>
<p>查看<code>ProxyClassFactory</code>类：</p>
<pre><code class="language-java">/**
 * A factory function that generates, defines and returns the proxy class given
 * the ClassLoader and array of interfaces.
 */
private static final class ProxyClassFactory
    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;
    {
       ...
        @Override
        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {
            ...
            /*
             * Choose a name for the proxy class to generate.
             */
            long num = nextUniqueNumber.getAndIncrement();
            // 生成代理类名称
            String proxyName = proxyPkg + proxyClassNamePrefix + num;
            /*
             * Generate the specified proxy class.
             */
             // 生成代理类
            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
            try {
                return defineClass0(loader, proxyName,
                                    proxyClassFile, 0, proxyClassFile.length);
            } catch (ClassFormatError e) {
                throw new IllegalArgumentException(e.toString());
            }
        }
    }
</code></pre>
<p>而最终生成代理类的class对象是<em>defineClass0</em>方法，但是这个方法是个native方法，所以我们不去也无法深究它，但是通过这个方法的参数我们可以明显看到它接收了上面所生成的byte数组。</p>
<p>而我们通过ProxyUtils，这个自己写的工具类，将这个byte数组写入文件，我们并反编译，我们将会看到</p>
<pre><code class="language-java">public static void generateClassFile(Class originClazz, Class clazz, String proxyName) {
    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
        proxyName, clazz.getInterfaces());
    String path = originClazz.getResource(&quot;.&quot;).getPath();
    System.out.println(&quot;resource path: &quot; + path);
    try (FileOutputStream outputStream = new FileOutputStream(path + File.separator + proxyName + &quot;.class&quot;)) {
        outputStream.write(proxyClassFile);
        outputStream.flush();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-06-17-class.jpg" alt="class.jpg" loading="lazy"></figure>
<p>同时我们还会看到其中实现了业务接口的方法</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-08-23-test.jpg" alt="test.jpg" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-09-55-test.jpg" alt="test.jpg" loading="lazy"></figure>
<p>而h则来自派生类Proxy中</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-11-30-InvokeHandler.jpg" alt="InvokeHandler.jpg" loading="lazy"></figure>
<p>这个h的实例来自哪里？不就是我们在创建代理类的实例时传入的吗？</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-13-42-InvokeHandlerImpl.jpg" alt="InvokeHandlerImpl.jpg" loading="lazy"></figure>
<h4 id="使用了动态代理的retrofit">使用了动态代理的<code>Retrofit</code></h4>
<p>Retrofit简单的说就是一个网络请求的适配器，它将一个基本的Java接口通过动态代理的方式翻译成一个HTTP请求，并通过OkHttp去发送请求。此外它还具有强大的可扩展性，支持各种格式转换以及RxJava。我们基于Retrofit2解析。</p>
<p>先定义一个名为X的java接口，当然里面有各种注解。</p>
<p>@FormUrlEncoded注解表示from表单，另外还有@Multipart等注解。@POST表示post请求，此外还可以使用@GET请求</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-14-52-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86Retrofit%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.jpg" alt="动态代理Retrofit接口定义.jpg" loading="lazy"></figure>
<p>然后如何使用的呢？</p>
<p>首先将域名传入构造一个Retrofit，然后通过retrofit中的create方法传入一个Java接口并得到一个x(当然x这个对象是经过处理了的)调用getPersonalListInfo(12)然后返回一个Call，最后这个Call调用了enqueue方法去异步请求http，这就是一个基本的Retrofit的网络请求。Retrofit2中Call接口的默认实现是OkHttpCall，它默认使用OkHttp3作为底层http请求client。</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-17-41-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86Retrofit%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.jpg" alt="动态代理Retrofit使用示例.jpg" loading="lazy"></figure>
<p>我们只定义了一个接口X，并没有实现这个接口，那么它是如何工作的呢？我们看看create方法的实现。</p>
<p>create()方法是个泛型方法，调用它时会返回一个范型T的对象，我们这里类型是X接口，在内部实现上，很明显了使用了动态代理返回了一个X的代理类。当调用X内部方法的时候，会调用invoke方法。invoke方法内则通过内部一系列的封装最后返回一个Call对象。</p>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-18-49-Retrofit%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.jpg" alt="Retrofit动态代理.jpg" loading="lazy"></figure>
<h1 id="多线程与android线程性能优化">多线程与Android线程性能优化</h1>
<h2 id="基础概念">基础概念</h2>
<h3 id="cpu核心数和线程数的关系">CPU核心数和线程数的关系</h3>
<p>多核心: 也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理</p>
<p>多线程: Simultaneous Multithreading.简称SMT.SMT可通过复制处理器上的结构状态,让同一个处理器上的多个线程同步执行并共享处理器的执行资源可最大限度地实现宽发射、乱序的超标量处理,提高处理器运算部件的利用率,缓和由于数据相关或 Cache未命中带来的访问内存延时。</p>
<p>核心数、线程数:目前主流CPU有双核、三核和四核,六核也在2010年发布。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系</p>
<h3 id="cpu时间片轮转机制">CPU时间片轮转机制</h3>
<p>我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。</p>
<p>时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称<code>RR</code>调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。</p>
<p>百度百科对CPU时间片轮转机制原理解释如下:</p>
<blockquote>
<p>如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾。</p>
</blockquote>
<p>时间片轮转调度中唯一有趣的一点是时间片的长度。<strong>从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等</strong>。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。</p>
<p>为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发</p>
<p>结论可以归结如下: <strong>时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷</strong>。</p>
<p>在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KⅢ掉的,我想也正是因为这种机制的缘故。</p>
<h3 id="什么是进程和线程">什么是进程和线程</h3>
<p><strong>进程是程序运行资源分配的最小单位</strong></p>
<p><strong>进程是操作系统进行资源分配的最小单位</strong>, 其中资源包括:CPU、内存空间、磁盘10等, 同一进程中的多条线程共享该进程中的全部系统资源,而<strong>进程和进程之间是相互独立的</strong>。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</p>
<p>进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。</p>
<p><strong>线程是CPU调度的最小单位,必须依赖于进程而存在</strong></p>
<p>线程是进程的一个实体,是<strong>CPU调度和分派的基本单位</strong>,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>线程无处不在</strong></p>
<p>任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。</p>
<h3 id="澄清并行和并发">澄清并行和并发</h3>
<p>我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的<strong>并行</strong>车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。</p>
<p>当谈论<strong>并发</strong>的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。</p>
<p>俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。</p>
<p>综合来说：</p>
<p><strong>并发</strong>: 指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到&quot;同时执行效果&quot;,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.</p>
<p><strong>并行</strong>:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行</p>
<p>两者区别:一个是交替执行,一个是同时执行.</p>
<h3 id="高并发编程的意义-好处和注意事项">高并发编程的意义、好处和注意事项</h3>
<p>由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。</p>
<p>(1) 充分利用CPU的资源</p>
<p>从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。</p>
<p>(2) 加快响应用户的时间</p>
<p>我们在做程序开发的时候, 特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。</p>
<p>(3) 可以使你的代码模块化,异步化,简单化</p>
<p>例如我们在做 Android程序开发的时候,主线程的UI展示部分是一块主代码程序部分,但是UI上的按钮用相应事件的处理程序就可以做个单独的模块程序拿出来。这样既增加了异步的操,又使程序模块化,清晰化和简单化。</p>
<p>时下最流行的异步程序处理机制,正是多线程、并发程序最好的应用例子。</p>
<p>多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。</p>
<p><em><strong>多线程程序需要注意事项</strong></em></p>
<p>(1) 线程之间的安全性</p>
<p>从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。</p>
<p>(2) 线程之间的死循环过程</p>
<p>为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。</p>
<p>假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生</p>
<p>(3)  线程太多了会将服务器资源耗尽形成死机当机</p>
<p>线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢?</p>
<p>某些系统资源是有限的, 如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。</p>
<h2 id="认识java里的线程">认识Java里的线程</h2>
<h3 id="java里的程序天生就是多线程的"><strong>Java里的程序天生就是多线程的</strong></h3>
<p>一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。</p>
<p>通过以下代码可以查看当前存在的线程：</p>
<pre><code class="language-java">ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
for (ThreadInfo threadInfo : threadInfos) {
    System.out.println(threadInfo.getThreadName());
}
</code></pre>
<p>[6] Monitor Ctrl-Break //监控Ctrl-Break中断信号的</p>
<p>[5] Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等</p>
<p>[4] Signal Dispatcher  // 分发处理发送给JVM信号的线程</p>
<p>[3] Finalizer  // 调用对象finalize方法的线程</p>
<p>[2] Reference Handler//清除Reference的线程</p>
<p>[1] main //main线程，用户程序入口</p>
<h3 id="线程的启动与中止">线程的启动与中止</h3>
<h4 id="线程的启动">线程的启动</h4>
<p>启动线程的方式有：</p>
<p>1、<code>X extends Thread</code>，然后 <code>X.run</code></p>
<p>2、<code>X implements Runnable</code>， 然后交给 Thread运行</p>
<p>3、<code>X implements Callable</code>，然后交给Thread运行</p>
<p>第1、2方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。从Java 1.5开始，就提供了<code>Callable</code>和<code>Future</code>，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<h5 id="callable-future和futuretask">Callable、Future和FutureTask</h5>
<p>Runnable是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p>Callable 位于<code>java.util.concurrent</code>包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做<code>call()</code>，这是一个泛型接口，call() 函数返回的类型就是传递进来的 V 类型。</p>
<p>Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-26-29-2e5706540612f67ff96a0bb894f7c37f978b5769.png" alt="Future-class.png" loading="lazy"></figure>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p>
<pre><code class="language-java">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {}

public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {}
</code></pre>
<p><code>FutureTask</code> 类实现了<code>RunnableFuture</code>接口，RunnableFuture继承了<code>Runnable</code>接口和<code>Future</code>接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<p>事实上，<strong>FutureTask是Future接口的一个唯一实现类</strong>。</p>
<p>要new一个FutureTask的实例，有两种方法</p>
<pre><code class="language-java">public FutureTask(Callable&lt;V&gt; callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}

public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
</code></pre>
<h4 id="中止"><strong>中止</strong></h4>
<p><strong>线程自然终止</strong>：要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。</p>
<p><strong>手动中止</strong></p>
<p>暂停、恢复和停止操作对应在线程Thread的API就是<code>suspend()</code>、<code>resume()</code>和<code>stop()</code>。<em><strong>但是这些API是过期的</strong></em>，也就是不建议使用的。不建议使用的原因主要有：以suspend()方法为例，<strong>在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题</strong>。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。</p>
<p>安全的中止则是其他线程通过调用某个线程A的**interrupt()<strong>方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。<strong>因为java里的线程是协作式的，不是抢占式的</strong>。线程通过检查自身的中断标志位是否被置为true来进行响应，线程通过方法</strong>isInterrupted()<strong>来进行判断是否被中断，也可以调用静态方法</strong>Thread.interrupted()**来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。</p>
<p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。</p>
<p><strong>不建议自定义一个取消标志位来中止线程的运行</strong>。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，一、一般的阻塞方法，如sleep等本身就支持中断的检查，二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。</p>
<p><strong>注意：处于死锁状态的线程无法被中断</strong></p>
<h2 id="对java里的线程再多一点点认识">对Java里的线程再多一点点认识</h2>
<h3 id="深入理解run和start">深入理解run()和start()</h3>
<p>Thread 类是Java里对线程概念的抽象，可以这样理解：我们通过<code>new Thread()</code>其实只是new出一个<code>Thread的实例</code>，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。</p>
<p><code>start()</code>方法让一个线程进入<strong>就绪队列等待分配cpu</strong>，分到cpu后才调用实现的run()方法，start()方法不能重复调用。</p>
<p>而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，可以被单独调用。</p>
<h3 id="其他的线程方法">其他的线程方法</h3>
<p><code>yield()</code>方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>
<p><code>join</code>方法：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
<p><code>wait()/notify()/notifyAll()</code>：后面会单独讲述</p>
<h2 id="线程间的共享和协作">线程间的共享和协作</h2>
<h3 id="线程间的共享">线程间的共享</h3>
<p>线程开始运行，拥有自己的<code>栈空间</code>，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。</p>
<p>Java支持多个线程同时访问一个对象或者对象的成员变量，关键字<code>synchronized</code>可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p>
<p><strong>对象锁和类锁：</strong></p>
<p>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。</p>
<p>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。</p>
<h3 id="线程间的协作"><strong>线程间的协作</strong></h3>
<p>线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。却存在如下问题：</p>
<p>1）难以确保及时性。</p>
<p>2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</p>
<h4 id="等待通知机制">等待/通知机制</h4>
<p>是指一个线程A调用了对象O的<code>wait()</code>方法进入等待状态，而另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p>
<p><code>notify()</code>：</p>
<p>通知一个在对象上等待的线程,使其从<code>wait</code>方法返回,而返回的前提是该线程获取到了<code>对象的锁</code>，没有获得锁的线程重新进入<code>WAITING</code>状态。</p>
<p><code>notifyAll()</code>：</p>
<p>通知所有等待在该对象上的线程</p>
<p><code>wait()</code>:</p>
<p>调用该方法的线程进入<code>WAITING</code>状态,只有等待另外线程的<code>通知</code>或<code>被中断</code>才会返回.需要注意,调用wait()方法后,<strong>会释放对象的锁</strong></p>
<p><code>wait(long)</code>:</p>
<p>超时等待一段时间, 这里的参数时间是毫秒, 也就是等待长达n毫秒, 如果没有通知就超时返回</p>
<p><code>wait (long,int)</code>:</p>
<p>对于超时时间更细粒度的控制,可以达到纳秒</p>
<h5 id="等待和通知的标准范式">等待和通知的标准范式</h5>
<p><strong>等待方</strong>遵循如下原则。</p>
<p>1）获取对象的锁。</p>
<p>2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p>
<p>3）条件满足则执行对应的逻辑。</p>
<pre><code class="language-java">syncronized(对象){// 不能是Class对象
    while(条件不满足){
        对象.wait()
    }
    对应的逻辑处理
}
</code></pre>
<p><strong>通知方</strong>遵循如下原则。</p>
<p>1）获得对象的锁。</p>
<p>2）改变条件。</p>
<p>3）通知所有等待在对象上的线程。</p>
<pre><code class="language-java">syncronized(对象) { // 不能是Class对象
    改变条件
    对象.notifyAll()
}
</code></pre>
<p>在调用<code>wait()</code> 之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法，进入wait（）方法后，当前线程释放锁，在从wait（）返回前，线程与其他线程竞争重新获得锁，notifyAll方法一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p>
<h5 id="notify和notifyall应该用谁">notify和notifyAll应该用谁</h5>
<p>尽可能用notifyall()，谨慎使用notify()。</p>
<pre><code class="language-java">public class Express {
    private int km;/*快递运输里程数*/

    public Express(int km) {
        this.km = km;
    }

    /* 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理*/
    public synchronized void changeKm(){
        this.km = 101;
        notify();
    }

    public synchronized void waitKm(){
        while(this.km&lt;100){
            try {
                wait();
                System.out.println(&quot;check km thread[&quot;
                        +Thread.currentThread().getName()+&quot;] is be notifyed&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;the km is&quot;+this.km+&quot;,I will change db.&quot;);

    }
}
</code></pre>
<pre><code class="language-java">public class TestCond {
    private static ExpressCond express = new ExpressCond(0);

    /*检查里程数变化的线程,不满足条件，线程一直等待*/
    private static class CheckKm extends Thread{
        @Override
        public void run() {
            express.waitKm();
        }
    }
    public static void main(String[] args) throws InterruptedException {

        for(int i=0;i&lt;3;i++){
            new CheckKm().start();
        }
        Thread.sleep(1000);
        express.changeKm();//快递里程变化
    }
}
</code></pre>
<h3 id="threadlocal">ThreadLocal</h3>
<p>ThreadLocal，即<code>线程变量</code>，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值, ThreadLocal往往用来实现变量在线程之间的隔离。</p>
<p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p>
<p>•  void set(Object value)</p>
<p>设置当前线程的线程局部变量的值。</p>
<p>•  public Object get()</p>
<p>该方法返回当前线程所对应的线程局部变量。</p>
<p>•  public void remove()</p>
<p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p>
<p>•  protected Object initialValue()</p>
<p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p>
<p>public final static ThreadLocal<String> RESOURCE = new ThreadLocal<String>();RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。</p>
<h2 id="显式锁">显式锁</h2>
<h3 id="lock接口和synchronized的比较">Lock接口和synchronized的比较</h3>
<p>我们一般的Java程序是靠<code>synchronized</code>关键字实现锁功能的，使用synchronized关键字将会<code>隐式</code>地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。synchronized属于Java语言层面的锁，也被称之为<code>内置锁</code>。</p>
<p>synchronized这种机制，一旦开始获取锁，是不能中断的，也不提供尝试获取锁的机制。</p>
<p>而<code>Lock</code>是由Java在语法层面提供的，<strong>锁的获取和释放需要我们明显的去获取</strong>，因此被称为<code>显式锁</code>。并且提供了synchronized不提供的机制。</p>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-30-30-46926593f9edb0bd57a4f0b275bf52bdbf9afcf4.png" alt="loading-ag-13483" loading="lazy"></figure>
<h3 id="lock接口和核心方法">Lock接口和核心方法</h3>
<p>在<code>finally</code>块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</p>
<pre><code class="language-java">lock.lock();
try {
    // TODO doSomething
} finally {
    lock.unlock();
}
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-31-13-f92be04249ce849ccdbc7cbc32168bb9e1a4bd03.png" alt="lock.png" loading="lazy"></figure>
<h3 id="可重入锁reentrantlock-所谓锁的公平和非公平">可重入锁ReentrantLock、所谓锁的公平和非公平</h3>
<p><code>synchronized</code>关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。<code>ReentrantLock</code>在调用<code>lock()</code>方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<p>**公平和非公平锁 **</p>
<p>如果在时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。</p>
<p>ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，<strong>公平的锁机制往往没有非公平的效率高</strong>。原因是，<strong>在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟</strong>。假设线程A持有一个锁, 并且线程B请求这个锁。由于这个锁已被线程A持有,因此B将被挂起。当A释放锁时,B将被唤醒,因此会再次尝试获取锁。与此同时,如果C也请求这个锁,那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面:B获得锁的时刻并没有推迟,C更早地获得了锁,并且吞吐量也获得了提高。</p>
<h3 id="读写锁reentrantreadwritelock">读写锁ReentrantReadWriteLock</h3>
<p>之前提到锁（synchronized和ReentrantLock）基本都是<code>排他锁</code>，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p>
<p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量</p>
<h3 id="condition接口">Condition接口</h3>
<p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。</p>
<p>用Lock和Condition实现等待通知</p>
<pre><code class="language-java">private Lock lock = new ReentrantLock();
private Condition condition = lock.newCondition();

public void conditionWait() {
    lock.lock();
    try {
        condition.await();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

public void conditionSingle() {
    lock.lock();
    try {
        condition.signal();
    } finally {
        lock.unlock();
    }
} 
</code></pre>
<h1 id="线程池原理与asynctask">线程池原理与AsyncTask</h1>
<h2 id="什么是线程池为什么要用线程池">什么是线程池？为什么要用线程池?</h2>
<p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。线程池就是将线程进行池化，需要运行任务时从池中拿一个线程来执行，执行完毕，线程放回池中。</p>
<p>在开发过程中，合理地使用线程池能够带来3个好处。</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。   如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</p>
<p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h2 id="jdk中的线程池和工作机制"><strong>JDK中的线程池和工作机制</strong></h2>
<h3 id="线程池的创建各个参数含义">线程池的创建各个参数含义</h3>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)
</code></pre>
<h4 id="corepoolsize">corePoolSize</h4>
<p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；</p>
<p>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；</p>
<p>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<h4 id="maximumpoolsize">maximumPoolSize</h4>
<p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</p>
<h4 id="keepalivetime">keepAliveTime</h4>
<p>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</p>
<h4 id="timeunit">TimeUnit</h4>
<p>keepAliveTime的时间单位</p>
<h4 id="workqueue">workQueue</h4>
<p>workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能</p>
<h5 id="什么是阻塞队列">什么是阻塞队列</h5>
<p><strong>队列：</strong></p>
<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p>
<p>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p>
<p><strong>阻塞队列：</strong></p>
<p>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p>
<figure data-type="image" tabindex="14"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-33-38-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="阻塞队列.png" loading="lazy"></figure>
<ul>
<li>
<p>抛出异常：当队列满时，如果再往队列里插入元素，会抛出<code>IllegalStateException（&quot;Queuefull&quot;）</code>异常。当队列为空时，从队列里获取元素会抛出<code>NoSuchElementException</code>异常。</p>
</li>
<li>
<p>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</p>
</li>
<li>
<p>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</p>
</li>
<li>
<p>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p>
</li>
</ul>
<h5 id="常用阻塞队列">常用阻塞队列</h5>
<ul>
<li>
<p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</p>
</li>
<li>
<p>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</p>
</li>
<li>
<p>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</p>
</li>
<li>
<p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>
</li>
<li>
<p>SynchronousQueue：一个不存储元素的阻塞队列。</p>
</li>
<li>
<p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>
</li>
<li>
<p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
</li>
</ul>
<h4 id="threadfactory">threadFactory</h4>
<p>创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名Executors静态工厂里默认的threadFactory，线程的命名规则是“<strong>pool-数字-thread-数字</strong>”</p>
<h4 id="rejectedexecutionhandler饱和策略">RejectedExecutionHandler（饱和策略）</h4>
<p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<p>（1）AbortPolicy：直接抛出异常，默认策略；</p>
<p>（2）CallerRunsPolicy：用调用者所在的线程来执行任务；</p>
<p>（3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p>
<p>（4）DiscardPolicy：直接丢弃任务；</p>
<p>当然也可以根据应用场景实现<code>RejectedExecutionHandler</code>接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h3 id="线程池的工作机制">线程池的工作机制</h3>
<p>1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p>
<p>2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p>
<p>3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</p>
<p>4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<h2 id="合理配置线程池">合理配置线程池</h2>
<p>要想合理地配置线程池，就必须首先分析任务特性</p>
<p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>
<ul>
<li>
<p>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</p>
</li>
<li>
<p>任务的优先级：高、中和低。</p>
</li>
<li>
<p>任务的执行时间：长、中和短。</p>
</li>
<li>
<p>任务的依赖性：是否依赖其他系统资源，如数据库连接。</p>
</li>
</ul>
<p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的CPU个数。</p>
<h2 id="asynctask"><strong>AsyncTask</strong></h2>
<h3 id="为什么需要asynctask">为什么需要AsyncTask？</h3>
<p>在Android当中，当一个应用程序的组件启动的时候，并且没有其他的应用程序组件在运行时，Android系统就会为该应用程序组件开辟一个新的线程来执行。默认的情况下，在一个相同Android应用程序当中，其里面的组件都是运行在同一个线程里面的，这个线程我们称之为Main线程。当我们通过某个组件来启动另一个组件的时候，这个时候默认都是在同一个线程当中完成的。</p>
<p>在Android当中，通常将线程分为两种，一种叫做<code>Main Thread</code>，除了Main Thread之外的线程都可称为<code>Worker Thread</code>。</p>
<p>当一个应用程序运行的时候，Android操作系统就会给该应用程序启动一个线程，这个线程就是我们的Main Thread，这个线程非常的重要，它主要用来加载我们的UI界面，完成系统和我们用户之间的交互，并将交互后的结果又展示给我们用户，所以Main Thread又被称为<code>UI Thread</code>。</p>
<p>Android系统默认不会给我们的应用程序组件创建一个额外的线程，所有的这些组件默认都是在同一个线程中运行。然而，某些时候当我们的应用程序需要完成一个耗时的操作的时候，例如访问网络或者是对数据库进行查询时，此时我们的UI Thread就会被阻塞。例如，当我们点击一个Button，然后希望其从网络中获取一些数据，如果此操作在UI Thread当中完成的话，当我们点击Button的时候，UI线程就会处于阻塞的状态，此时，我们的系统不会调度任何其它的事件，更糟糕的是，当我们的整个现场如果阻塞时间超过5秒钟(官方是这样说的)，这个时候就会出现 ANR (Application Not Responding)的现象，此时，应用程序会弹出一个框，让用户选择是否退出该程序。对于Android开发来说，出现ANR的现象是绝对不能被允许的。</p>
<p>另外，由于我们的Android UI控件是线程不安全的，所以我们不能在UI Thread之外的线程当中对我们的UI控件进行操作。因此在Android的多线程编程当中，我们有两条非常重要的原则必须要遵守：</p>
<ol>
<li>
<p>绝对不能在UI Thread当中进行耗时的操作，不能阻塞我们的UI Thread</p>
</li>
<li>
<p>不能在UI Thread之外的线程当中操纵我们的UI元素</p>
<p>既然在Android当中有两条重要的原则要遵守，那么我们可能就有疑问了？我们既不能在主线程当中处理耗时的操作，又不能在工作线程中来访问我们的UI控件，那么我们比如从网络中要下载一张图片，又怎么能将其更新到UI控件上呢？这就关系到了我们的主线程和工作线程之间的通信问题了。在Android当中，提供了两种方式来解决线程直接的通信问题，一种是通过Handler的机制，这个时候就很可能自己会去封装一下thread+handler了，正是因为这类需求很多，google就帮我们封装了一下。其实我们也可以自己封装，但是我相信99%程序员自己封装的东西比不上google的。所以另外一种就是今天要详细讲解的 AsyncTask 机制。</p>
</li>
</ol>
<h3 id="原理分析"><strong>原理分析</strong></h3>
<p>AsyncTask是个abstract类，所以在使用时需要实现一个AsyncTask的具体实现类，一般来说会覆盖4个方法，我们以前面所说的从网络中下载一张图片，然后更新到UI控件来说明：</p>
<p>（1）onPreExecute()：在执行后台下载操作之前调用，将下载等待动画显示出来，运行在主线程中；</p>
<p>（2）doInBackground()：核心方法，执行后台下载操作的方法，必须实现的一个方法，运行在子线程中；这个方法是执行在子线程中的。在onPreExecute()执行完后，会立即开启这个方法。</p>
<p>（3）onProgressUpdate()：在下载操作doInBackground()中调用publishProgress()时的回调方法，用于更新下载进度，运行在主线程中；</p>
<p>（4）onPostExecute()：后台下载操作完成后调用，将下载等待动画进行隐藏，并更新UI，运行在主线程中；</p>
<p>通过上面的分析，我们可以知道，AsyncTask的构造方法和execute方法是我们分析AsyncTask的重点。</p>
<h4 id="1构造方法"><strong>1）构造方法</strong></h4>
<p>AsyncTask的构造方法中</p>
<pre><code class="language-java">public AsyncTask(@Nullable Looper callbackLooper) {
    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()
        ? getMainHandler()
        : new Handler(callbackLooper);

    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
        public Result call() throws Exception {
            mTaskInvoked.set(true);
            Result result = null;
            try {
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                //noinspection unchecked
                result = doInBackground(mParams);
                Binder.flushPendingCommands();
            } catch (Throwable tr) {
                mCancelled.set(true);
                throw tr;
            } finally {
                postResult(result);
            }
            return result;
        }
    };

    mFuture = new FutureTask&lt;Result&gt;(mWorker) {
        @Override
        protected void done() {
            try {
                postResultIfNotInvoked(get());
            } catch (InterruptedException e) {
                android.util.Log.w(LOG_TAG, e);
            } catch (ExecutionException e) {
                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,
                                           e.getCause());
            } catch (CancellationException e) {
                postResultIfNotInvoked(null);
            }
        }
    };
}
</code></pre>
<p>mWorker代表了AsyncTask要执行的任务，是对Callable接口的封装，意味着这个任务是有返回值的;</p>
<p>mFuture代表了AsyncTask要执行的任务的返回结果，其实就是个FutureTask，按照FutureTask标准用法，mWorker作为Callable被传给了mFuture，那么mFuture的结果就从mWorker执行的任务中取得。仔细看mWorker，return语句返回的结果就是我们前面所说的doInBackground()的执行结果。</p>
<h4 id="2再看执行流程"><strong>2）再看执行流程</strong></h4>
<p>查看源码 execute() -&gt; executeOnExecutor(sDefaultExecutor, params) -&gt; exec.execute(mFuture)</p>
<p>到了这一步，将mFuture传递给了AsyncTask的执行器进行执行。AsyncTask的执行器缺省是sDefaultExecutor。</p>
<p>找到成员变量sDefaultExecutor，最终定位到</p>
<figure data-type="image" tabindex="15"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-32-48-asyncTask.png" alt="asyncTask.png" loading="lazy"></figure>
<p>SerialExecutor是对JDK里Executor的一个实现，被声明为一个静态变量，我们仔细看SerialExecutor的实现，</p>
<pre><code class="language-java">private static class SerialExecutor implements Executor {
    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
</code></pre>
<p>内部声明了一个双端队列ArrayDeque类型的mTasks（双端队列中offer方法表示从队列尾插入，poll()表示从队列头获取元素）。</p>
<p>每次调用execute，就创建一个Runnable匿名内部类对象，这个对象存入mTasks，在匿名内部类的run函数里面调用传入参数r.run()。然后通过一个scheduleNext函数把mTasks里面的所有对象通过THREAD_POOL_EXECUTOR.execute(mActive)执行一遍。说穿了，也就是说SerialExecutor类会把所有的任务丢入一个容器，之后把容器里面的所有对象**一个一个的排队（串行化）**执行THREAD_POOL_EXECUTOR.execute(mActive);</p>
<p>至于这个THREAD_POOL_EXECUTOR，是这样定义的：</p>
<pre><code class="language-java">public static final Executor THREAD_POOL_EXECUTOR;

static {
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
        sPoolWorkQueue, sThreadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    THREAD_POOL_EXECUTOR = threadPoolExecutor;
}
</code></pre>
<p>我们可以看到这个线程池，被声明为一个静态变量，同时初始化的参数是：</p>
<pre><code class="language-java"> private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    // We want at least 2 threads and at most 4 threads in the core pool,
    // preferring to have 1 less than the CPU count to avoid saturating
    // the CPU with background work
    private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
    private static final int KEEP_ALIVE_SECONDS = 30;

 private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =
            new LinkedBlockingQueue&lt;Runnable&gt;(128);
</code></pre>
<h4 id="3结果和进度的通知">3)结果和进度的通知</h4>
<p>AsyncTask的执行结果和进度是怎么通知给UI线程的呢？检视mFuture</p>
<pre><code class="language-java">mFuture = new FutureTask&lt;Result&gt;(mWorker) {
    @Override
    protected void done() {
        try {
            postResultIfNotInvoked(get());
        } catch (InterruptedException e) {
            android.util.Log.w(LOG_TAG, e);
        } catch (ExecutionException e) {
            throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,
                                       e.getCause());
        } catch (CancellationException e) {
            postResultIfNotInvoked(null);
        }
    }
};
</code></pre>
<pre><code class="language-java">private void postResultIfNotInvoked(Result result) {
    final boolean wasTaskInvoked = mTaskInvoked.get();
    if (!wasTaskInvoked) {
        postResult(result);
    }
}
</code></pre>
<pre><code class="language-java">private Result postResult(Result result) {
    @SuppressWarnings(&quot;unchecked&quot;)
    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
                                                 new AsyncTaskResult&lt;Result&gt;(this, result));
    message.sendToTarget();
    return result;
}
</code></pre>
<p>和更新进度时我们会调用的publishProgress方法</p>
<pre><code class="language-java">@WorkerThread
protected final void publishProgress(Progress... values) {
    if (!isCancelled()) {
        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
                                   new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();
    }
}
</code></pre>
<p>我们可以看到都调用了sHandler</p>
<pre><code class="language-java">protected final void publishProgress(Progress... values) {
    if (!isCancelled()) {
        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
                                   new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();
    }
}
</code></pre>
<p>说明当子线程需要和UI线程进行通信时，其实就是通过这个handler，往UI线程发送消息。</p>
<h4 id="总结"><strong>总结：</strong></h4>
<p>1）线程池的创建：</p>
<p>在创建了AsyncTask的时候，会默认创建两个线程池SerialExecutor和ThreadPoolExecutor，SerialExecutor负责将任务串行化，ThreadPoolExecutor是真正执行任务的地方，且无论有多少个AsyncTask实例，两个线程池都会只有一份。</p>
<p>2）任务的执行：</p>
<p>在execute中，会执行run方法，当执行完run方法后，会调用scheduleNext()不断的从双端队列中轮询，获取下一个任务并继续放到一个子线程中执行，直到异步任务执行完毕。</p>
<p>3）消息的处理：</p>
<p>在执行完onPreExecute()方法之后，执行了doInBackground()方法，然后就不断的发送请求获取数据；在这个AsyncTask中维护了一个InternalHandler的类，这个类是继承Handler的，获取的数据是通过handler进行处理和发送的。在其handleMessage方法中，将消息传递给onProgressUpdate()进行进度的更新，也就可以将结果发送到主线程中，进行界面的更新了。</p>
<p>4）使用AsyncTask的注意点</p>
<p>通过观察代码我们可以发现，每一个new出的AsyncTask只能执行一次execute()方法，多次运行将会报错，如需多次，需要新new一个AsyncTask。</p>
<pre><code class="language-java">@MainThread
public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
                                                                   Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                                                + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                                                + &quot; the task has already been executed &quot;
                                                + &quot;(a task can be executed only once)&quot;);
        }
    }

    ...
}
</code></pre>
<h3 id="asynctask优缺点"><strong>AsyncTask优缺点</strong></h3>
<p><strong>AsyncTask：</strong></p>
<p>优点：AsyncTask是一个轻量级的异步任务处理类，轻量级体现在，使用方便、代码简洁上，而且整个异步任务的过程可以通过cancel()进行控制；</p>
<p>缺点：不适用于处理长时间的异步任务，一般这个异步任务的过程最好控制在几秒以内，如果是长时间的异步任务就需要考虑多线程的控制问题；当处理多个异步任务时，UI更新变得困难。</p>
<p><strong>Handler:</strong></p>
<p>优点：代码结构清晰，容易处理多个异步任务；</p>
<p>缺点：当有多个异步任务时，由于要配合Thread或Runnable，代码可能会稍显冗余。</p>
<p>**总之，**AsyncTask不失为一个非常好用的异步任务处理类，只要不是频繁对大量UI进行更新，可以考虑使用；而Handler在处理大量UI更新时可以考虑使用。</p>
<h1 id="补充知识cas">补充知识：CAS</h1>
<h2 id="什么是原子操作如何实现原子操作">什么是原子操作？如何实现原子操作？</h2>
<p>假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p>
<p>实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争（事实上CPU的主要工作并非这些），同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p>
<p>实现原子操作还可以使用当前的处理器基本都支持<code>CAS()</code>的指令，只不过每个厂家所实现的算法并不一样罢了，**每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。**CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。<strong>循环CAS就是在一个循环里不断的做CAS</strong>操作，直到成功为止。怎么实现线程安全呢？语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上<code>volatile</code>变量的特性即可实现基于原子操作的线程安全。</p>
<h2 id="cas实现原子操作的三大问题">CAS实现原子操作的三大问题</h2>
<ol>
<li>ABA问题。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</li>
</ol>
<p>举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，这就是ABA问题。如果你是一个讲卫生讲文明的小伙子，不但关心水在不在，还要在你离开的时候水被人动过没有，因为你是程序员，所以就想起了放了张纸在旁边，写上初始值0，别人喝水前麻烦先做个累加才能喝水。</p>
<ol start="2">
<li>
<p>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
</li>
<li>
<p>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p>
</li>
</ol>

                    </div>
                    <div class="essaySuffix-box">
                        <div class="essaySuffix-box-left"><img
                                src="/images/avatar.png" alt="">
                        </div>
                        <div class="essaySuffix-box-right"><span
                                class="essaySuffix-right-title">本文作者</span>：<strong><span style="font-size: 12px;"><a
                                        href="/about"
                                        target="_blank">Xiaowu</a></span></strong> <br><span
                                style="font-weight: bold; white-space:nowrap;">本文链接</span>：<a
                                href="https://jxiaow.gitee.io/posts/adf30ba7/"
                                target="_blank">https://jxiaow.gitee.io/posts/adf30ba7/</a><br><span
                                class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a
                                href="https://creativecommons.org/licenses/by-nc-nd/4.0/" alt="BY-NC-SA"
                                title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</div>
                        <div style="clear: both;"></div>
                    </div>

                </div>
                <!-- </div> -->
                <div class="toc-container">
                    <ul class="markdownIt-TOC">
<li><a href="#java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B">Java中的泛型</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B">为什么我们需要泛型?</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">泛型类和泛型接口</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">泛型方法</a></li>
<li><a href="#%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F">限定类型变量</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7">泛型中的约束和局限性</a>
<ul>
<li><a href="#%E4%B8%8D%E8%83%BD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">不能用基本类型实例化类型参数</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B">运行时类型检查只适用于原始类型</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%A4%B1%E6%95%88">泛型类的静态上下文中类型变量失效</a></li>
<li><a href="#%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84">不能创建参数化类型的数组</a></li>
<li><a href="#%E4%B8%8D%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F">不能实例化类型变量</a></li>
<li><a href="#%E4%B8%8D%E8%83%BD%E6%8D%95%E8%8E%B7%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">不能捕获泛型类的实例</a></li>
</ul>
</li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99">泛型类型的继承规则</a></li>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B">通配符类型</a>
<ul>
<li><a href="#extends-x">？ extends X</a></li>
<li><a href="#super-x">？ super X</a></li>
<li><a href="#%E6%97%A0%E9%99%90%E5%AE%9A%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6">无限定的通配符 ?</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B3%9B%E5%9E%8B%E7%9A%84">虚拟机是如何实现泛型的？</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E4%BF%A1%E6%81%AF">通过反射获取泛型信息</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">反射原理及动态代理模式</a>
<ul>
<li><a href="#%E5%8F%8D%E5%B0%84reflect">反射（Reflect）</a>
<ul>
<li><a href="#class%E7%B1%BB">Class类</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">代理模式和静态代理</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><strong>动态代理</strong></a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">动态代理实现原理</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%BA%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84retrofit">使用了动态代理的<code>Retrofit</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Eandroid%E7%BA%BF%E7%A8%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">多线程与Android线程性能优化</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">基础概念</a>
<ul>
<li><a href="#cpu%E6%A0%B8%E5%BF%83%E6%95%B0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB">CPU核心数和线程数的关系</a></li>
<li><a href="#cpu%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E6%9C%BA%E5%88%B6">CPU时间片轮转机制</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">什么是进程和线程</a></li>
<li><a href="#%E6%BE%84%E6%B8%85%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91">澄清并行和并发</a></li>
<li><a href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89-%E5%A5%BD%E5%A4%84%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">高并发编程的意义、好处和注意事项</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A4%E8%AF%86java%E9%87%8C%E7%9A%84%E7%BA%BF%E7%A8%8B">认识Java里的线程</a>
<ul>
<li><a href="#java%E9%87%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%A4%A9%E7%94%9F%E5%B0%B1%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84"><strong>Java里的程序天生就是多线程的</strong></a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E4%B8%AD%E6%AD%A2">线程的启动与中止</a>
<ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8">线程的启动</a>
<ul>
<li><a href="#callable-future%E5%92%8Cfuturetask">Callable、Future和FutureTask</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E6%AD%A2"><strong>中止</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AF%B9java%E9%87%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%86%8D%E5%A4%9A%E4%B8%80%E7%82%B9%E7%82%B9%E8%AE%A4%E8%AF%86">对Java里的线程再多一点点认识</a>
<ul>
<li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3run%E5%92%8Cstart">深入理解run()和start()</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95">其他的线程方法</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E5%8D%8F%E4%BD%9C">线程间的共享和协作</a>
<ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB">线程间的共享</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><strong>线程间的协作</strong></a>
<ul>
<li><a href="#%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6">等待/通知机制</a>
<ul>
<li><a href="#%E7%AD%89%E5%BE%85%E5%92%8C%E9%80%9A%E7%9F%A5%E7%9A%84%E6%A0%87%E5%87%86%E8%8C%83%E5%BC%8F">等待和通知的标准范式</a></li>
<li><a href="#notify%E5%92%8Cnotifyall%E5%BA%94%E8%AF%A5%E7%94%A8%E8%B0%81">notify和notifyAll应该用谁</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#threadlocal">ThreadLocal</a></li>
</ul>
</li>
<li><a href="#%E6%98%BE%E5%BC%8F%E9%94%81">显式锁</a>
<ul>
<li><a href="#lock%E6%8E%A5%E5%8F%A3%E5%92%8Csynchronized%E7%9A%84%E6%AF%94%E8%BE%83">Lock接口和synchronized的比较</a></li>
<li><a href="#lock%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95">Lock接口和核心方法</a></li>
<li><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrantlock-%E6%89%80%E8%B0%93%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3">可重入锁ReentrantLock、所谓锁的公平和非公平</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E9%94%81reentrantreadwritelock">读写锁ReentrantReadWriteLock</a></li>
<li><a href="#condition%E6%8E%A5%E5%8F%A3">Condition接口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8Easynctask">线程池原理与AsyncTask</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">什么是线程池？为什么要用线程池?</a></li>
<li><a href="#jdk%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><strong>JDK中的线程池和工作机制</strong></a>
<ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89">线程池的创建各个参数含义</a>
<ul>
<li><a href="#corepoolsize">corePoolSize</a></li>
<li><a href="#maximumpoolsize">maximumPoolSize</a></li>
<li><a href="#keepalivetime">keepAliveTime</a></li>
<li><a href="#timeunit">TimeUnit</a></li>
<li><a href="#workqueue">workQueue</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">什么是阻塞队列</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">常用阻塞队列</a></li>
</ul>
</li>
<li><a href="#threadfactory">threadFactory</a></li>
<li><a href="#rejectedexecutionhandler%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5">RejectedExecutionHandler（饱和策略）</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6">线程池的工作机制</a></li>
</ul>
</li>
<li><a href="#%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0">合理配置线程池</a></li>
<li><a href="#asynctask"><strong>AsyncTask</strong></a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81asynctask">为什么需要AsyncTask？</a></li>
<li><a href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><strong>原理分析</strong></a>
<ul>
<li><a href="#1%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><strong>1）构造方法</strong></a></li>
<li><a href="#2%E5%86%8D%E7%9C%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><strong>2）再看执行流程</strong></a></li>
<li><a href="#3%E7%BB%93%E6%9E%9C%E5%92%8C%E8%BF%9B%E5%BA%A6%E7%9A%84%E9%80%9A%E7%9F%A5">3)结果和进度的通知</a></li>
<li><a href="#%E6%80%BB%E7%BB%93"><strong>总结：</strong></a></li>
</ul>
</li>
<li><a href="#asynctask%E4%BC%98%E7%BC%BA%E7%82%B9"><strong>AsyncTask优缺点</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86cas">补充知识：CAS</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">什么是原子操作？如何实现原子操作？</a></li>
<li><a href="#cas%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98">CAS实现原子操作的三大问题</a></li>
</ul>
</li>
</ul>

                </div>
            </article>

            <!-- </div> -->
            
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://jxiaow.gitee.io/posts/6241fe4b/" class="post-title gt-a-link">
                    App启动优化
                </a>
            </div>
            

            

            
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'CAmH4sFTLPMg3inDkFSqWsuL-gzGzoHsz',
		appKey: '3Mh9SPxWQ7QbJjxmX7EU26z4',
		avatar: 'monsterid',
		pageSize: 5,
		recordIp: true,
		placeholder: '快来吐槽吧~',
		visitor: true,
	});
</script>

            

            <div class="site-footer gt-c-content-color-first">

  <div class="social-container">

    <a href="https://github.com/jxiaow" target="_blank" title="https://github.com/jxiaow">
      <i class="fab fa-github gt-c-content-color-first"></i>
    </a>

    <a href="https://www.cnblogs.com/xiaowj" target="_blank" title="https://www.cnblogs.com/xiaowj">
      <i class="fas fa-blog gt-c-content-color-first"></i>
    </a>

    <a href="https://blog.csdn.net/xiaowu_zhu" target="_blank" title="https://blog.csdn.net/xiaowu_zhu">
      <i class="fab fa-cuttlefish gt-c-content-color-first"></i>
    </a>

    <a href="mailto:jxiaow@126.com" title="jxiaow@126.com">
      <i class="fas fa-envelope gt-c-content-color-first"></i>
    </a>

  </div>
  <div class="slogan gt-c-content-color-first">心若没有栖息的地方，到哪里都是在流浪</div>
  
	<div>
    <div>
      Theme by <a href="https://github.com/jxiaow/gridea-theme-pure-fashion" target="_blank">jxiaow</a>, Powered by <a
              href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://jxiaow.gitee.io/atom.xml" target="_blank">RSS</a></a>
  </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

            <script>
  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");
  
  if (mainNavLinks == null || mainNavLinks.length == 0) {
    let tocContainer = document.querySelector(".toc-container");
    tocContainer.classList.remove("toc-container")
    tocContainer.parentElement.firstElementChild.style.width = "100%"
    console.log("隐藏大纲")
  } else {

    // This should probably be throttled.
    // Especially because it triggers during smooth scrolling.
    // https://lodash.com/docs/4.17.10#throttle
    // You could do like...
    // window.addEventListener("scroll", () => {
    //    _.throttle(doThatStuff, 100);
    // });
    // Only not doing it here to keep this Pen dependency-free.


    window.addEventListener("scroll", event => {
      let fromTop = window.scrollY;

      mainNavLinks.forEach((link, index) => {
        let section = document.getElementById(decodeURI(link.hash).substring(1));
        let nextSection = null
        if (mainNavLinks[index + 1]) {
          nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
        }
        if (section.offsetTop <= fromTop) {
          if (nextSection) {
            if (nextSection.offsetTop > fromTop) {
              link.classList.add("current");
            } else {
              link.classList.remove("current");
            }
          } else {
            link.classList.add("current");
          }
        } else {
          link.classList.remove("current");
        }
      });
    });
  }



</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll("figure > img");
  //   debugger
  //   console.log("dddd: "+ images);
  images.forEach(image => {
    var parent = image.parentElement;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'gallery';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.appendChild(aelem);
  })

//   <a data-fancybox="gallery" href="big_1.jpg"><img src="small_1.jpg"></a>
// <a data-fancybox="gallery" href="big_2.jpg"><img src="small_2.jpg"></a>
</script>
        </div>
    </div>

</body>

</html>