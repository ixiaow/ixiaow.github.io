<html>

<head>
    <meta charset="utf-8"/>
<meta name="description" content="心若没有栖息的地方，到哪里都是在流浪"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Dart 语言简述 | Xiaowu</title>

<link rel="shortcut icon" href="https://jxiaow.gitee.io/favicon.ico?v=1611741908220">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://jxiaow.gitee.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">


<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>

<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.0/mermaid.min.js"></script>
<script>
    var config = {
        startOnLoad:true,
        flowchart:{
            useMaxWidth:false,
            htmlLabels:true
        }
    };
    mermaid.initialize(config);
    $(function(){
        var elements = document.getElementsByClassName("language-mermaid");
        for (var i = elements.length; i--;) {
            element = elements[i];
            var graphDefinition = element.innerText;
            if (graphDefinition) {
                var svg = mermaid.render('ha_mermaid_' + i, graphDefinition, function(svg){});
                if (svg) {
                    var svgElement = document.createElement('div');
                    preNode = element.parentNode;
                    svgElement.innerHTML = svg;
                    svgElement.setAttribute('class', 'mermaid');
                    svgElement.setAttribute('data-processed', 'true');
                    preNode.parentNode.replaceChild(svgElement, preNode);
                }
            }
        }
    });
</script>
</head>

<body>
    <div class="main gt-bg-theme-color-first">
        <nav class="navbar navbar-expand-lg">
    <a href="/">
        <div class="navbar-brand">
            <img class="user-avatar" src="/images/avatar.png" alt="头像">
            <div class="site-name gt-c-content-color-first">
                Xiaowu
            </div>
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav " style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://jxiaow.gitee.io/posts/favourite" class="menu gt-a-link">
                            收藏
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1611741908220" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

        <div class="post-container">

            <!-- <div class="post-detail gt-bg-theme-color-second"> -->
            <article style="display:flex;">
                <div class="post-detail gt-bg-theme-color-second gt-post-content">
                    <h2 class="post-title">
                        Dart 语言简述
                    </h2>
                    <div class="post-info">
                        <div>
                            <time class="post-time gt-c-content-color-first">
                                · 2019-12-05 ·
                            </time>
                            
                            <a href="https://jxiaow.gitee.io/tag/yIARIF1ON/" class="post-tags">
                                # flutter
                            </a>
                            
                            <a href="https://jxiaow.gitee.io/tag/S3EyU9FVQe/" class="post-tags">
                                # dart
                            </a>
                            
                        </div>
                        <div>
                            
                            <span id="/posts/b8c700d2/"
                                class="leancloud_visitors" data-flag-title="Dart 语言简述">
                                <em class="post-meta-item-text">阅读量 </em>
                                <i class="leancloud-visitors-count">0</i>
                            </span>
                            
                        </div>
                    </div>

                    <!-- <div class="post-content-wrapper"> -->
                    <div class="post-content">
                        <p>最近开始接触Flutter相关的项目，通过源码、例子和一些资料的阅读，发现如果掌握了Dart的一些语法和一些基础对于Flutter的学习有着事半功倍的效果。下面是我在查阅一些资料和实际的开发中的一些总结。希望对今后的学习有所帮助。</p>
<!--more-->
<blockquote>
<p>Dart 诞生于 2011.10.10 日， 谷歌 Dart 语言项目的领导人 Lars Bak 在丹麦举行的Goto 会议上 布， Dart 种“结构化的 Web 程”语言， Dart 编程语言在所有现代浏览器和环境中提供高性能。</p>
</blockquote>
<p>Dart语言的特性：</p>
<ul>
<li>Dart 是AOT（Ahead Of Time）编译的，编译成快速、可预测本地的代码。</li>
<li>Dart也可以JIT（Just In Time）编译，开发周期异常快，包括Flutter流行的亚秒级有状态热重载。</li>
<li>Dart可以更轻松地创建以60fps运行的流畅动画和状态，Dart可以在没有锁的情况下进行对象分配和垃圾回收。</li>
<li>Dart使Flutter不需要单独的声明式布局语言，或单独的可视化界面构建器，因为Dart的声明式编程布局易于阅读和可视化。</li>
</ul>
<p>Dart重要概念：</p>
<ul>
<li>
<p>一切皆对象，无论是变量、数字、函数等都是对象，所有的对像都继自Object， 这点类似于 Java 语言。</p>
</li>
<li>
<p>程序中指定数据类型使得程序合理地分配内存空间，并帮助编绎器进行语法检查，由于Dart 言是弱数据类型， 所以类型不是必须的 。</p>
</li>
<li>
<p>Dart 代码在运行前解析 指定数据类型和编译时的常量， 可以提高运行速度。</p>
</li>
<li>
<p>Dart 程序有统 的程序人口： main （） 这一点与 Java C 和 C＋＋ 语言很像。</p>
</li>
<li>
<p>Dart 没有 <code>public</code> <code>protected</code> <code>private</code> 这些修饰符的概念，私有特性通过变量或函数加上下划线来表示。</p>
</li>
<li>
<p>Dart 工具可以检查出警告信息(<code>warning</code>) 和 错误信息(<code>errors</code>)， 警告信息只是表明代码可能不工作，但是不会妨碍程序运行，错误信息可以是编译时的错误，也可能是运行时的错误， 编译时的错误将阻止程序运行，运行时的错误将会以异常（exception ）的方式呈现。</p>
</li>
<li>
<p>Dart 支持 anync/await 异步处理。</p>
</li>
<li>
<p>关键字（ 56 个）如下：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-43-54-dart%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="dart关键字.png" loading="lazy"></figure>
<ul>
<li>带有上标 <strong>1</strong> 的关键字是 <em><strong>内置关键字</strong></em>。避免把内置关键字当做标识符使用。 也不要把内置关键字 用作类名字和类型名字。</li>
<li>带有上标 <strong>2</strong> 的关键字，是在 Dart 1.0 发布以后又新加的，用于支持异步相关的特性。</li>
</ul>
</li>
</ul>
<h2 id="变量与基本类型">变量与基本类型</h2>
<h3 id="变量的声明">变量的声明</h3>
<p>在Dart里，变量的声明有三种方式：</p>
<ol>
<li>
<p>用<code>var</code>关键字</p>
<p>用var声明变量时，如果未指定初始值，可以变成任意类型。如果指定了类型，则类型会被锁定。如：</p>
<pre><code class="language-dart">void main() {
  var v; // 初始值未指定类型
  v = '2'; // 可以变为任意类型
  v = 3;
  print('v: $v');

  var v1 = '111'; // 初始化时已经指定类型
  var v1 = 222; // 此时无法赋值成功，编译时报错
}
</code></pre>
</li>
<li>
<p>用<code>dynamic</code>关键字</p>
<p>dynamic声明的变量，表示动态任意类型，编译时不检查类型。如：</p>
<pre><code class="language-dart">void main() {
  dynamic d1 = '111';
  d1 = 222;
  d1 = 333.0;
  print(&quot;d1: $d1&quot;);
  // dynamic修饰的变量，在编译时不做检查
  d1.test(); // 这行还代码，在编译时是不会检查错误信息的，运行时会报错
}
</code></pre>
</li>
<li>
<p>用<code>Object</code></p>
<p>Object声明的变量，表示任意动态类型，编译时检查类型。如：</p>
<pre><code class="language-dart">void main() {
  Object o1 = &quot;sss&quot;;
  o1 = 222;
  o1.test(); // 编译时会做检查，报错
}
</code></pre>
</li>
</ol>
<h3 id="变量的默认值">变量的默认值</h3>
<ul>
<li>没有初始化的变量会自动获取一个默认值null</li>
<li>一切皆为对象，对象的默认值为null</li>
</ul>
<h3 id="final-和-const">final 和 const</h3>
<p>​    final 或 const 修饰的变量为常量或固定值。</p>
<ul>
<li>共同点：
<ol>
<li>声明的类型可以省略</li>
<li>初始化后不能再赋值</li>
<li>不能和<code>var</code>同时使用</li>
</ol>
</li>
<li>不同点：
<ol>
<li>类级别常量，使用 <code>static const</code></li>
<li>const 可以使用其它const常量的值来初始化其值</li>
<li>使用const赋值声明，const可省略</li>
<li>可以更改非final、非const变量的值，即使曾经具有const值</li>
<li>const 导致的不可变性是可传递的</li>
<li>相同的const常量不会在内存中重复创建</li>
<li>const需要编译时常量</li>
</ol>
</li>
</ul>
<h3 id="基本类型">基本类型</h3>
<p>Dart语言常用的基本数据类型包括： <code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>List和Map</code></p>
<ul>
<li>
<p>Number类型</p>
<p>Number 类型包括 int 整形，double浮点类型，他们都是<code>num</code>类型的子类</p>
</li>
<li>
<p>String类型</p>
<ul>
<li>Dart 字符串是 utf-16 编码的字符序列，可以使用单引号或者双引号来创建字符</li>
<li>可以使用三个单引号或者双引号创建多行字符串对象</li>
<li>可以使用r前缀创建原始字符串，即输出原始字符，字符串里的转义等符号不会生效</li>
<li>可以在字符串中使用表达式：<code>&quot;${expression}&quot;</code>，如果表达式是一个标识符，可以省略<code>{}</code>，如果表达式的结果为一个对象，则 Dart会调用对象的<code>toString</code>方法</li>
</ul>
</li>
<li>
<p>Boolean类型</p>
<p>Dart是强bool类型检查，只有bool类型的值是true才被认为是true， 如果未赋初值，则为null</p>
</li>
<li>
<p>List类型</p>
<p>在Dart语言中，具有一系列相同类型的数据称为List对象。Dart中List可以直接打印出出各个元素，而java中则是地址。</p>
</li>
<li>
<p>Map类型</p>
<p>与java类似。</p>
</li>
<li>
<p>Set</p>
<ul>
<li>set1.difference(set2): 返回 set1 集合里有但 set2 里没有的元素集合</li>
<li>set1.intersection(set2)：返回set1和set2的交集</li>
<li>set1.union(set2)：返回set1和set2的并集</li>
<li>set1.retainAll()：set1只保留某些元素(要保留的元素要在原set中存在）</li>
</ul>
</li>
<li>
<p>Runs</p>
<ul>
<li>用在符串中表示Unicode字符</li>
<li>使用String.fromCharCodes显示字符图形</li>
<li>如果非4个数值，需要把编码值放到大括号中</li>
</ul>
</li>
</ul>
<h2 id="函数">函数</h2>
<p>Dart是一个面向对象的语言,所以函数也是对象，函数属于Function对象。函数可以像参数一样传递给其他函数。</p>
<h3 id="函数定义">函数定义</h3>
<ol>
<li>
<p>定义函数时可以省略类型(不建议)</p>
<pre><code class="language-dart">void func(a, b){} // 参数a,b都省略了类型
</code></pre>
</li>
<li>
<p>支持缩写语法<code>=&gt;</code></p>
<pre><code class="language-dart">void main() =&gt; runApp(MyApp()); // 当函数体只有一条语句时可以使用此种写法
</code></pre>
</li>
<li>
<p>可在函数内定义函数</p>
<p>可以在函数里定义函数，如：</p>
<pre><code class="language-dart">int func(int a, int b) {
  int sum(int a, int b, int c) {
    return a + b + c;
  }
  return sum(a, b, 1);
}
</code></pre>
<p>dart 函数支持闭包</p>
<pre><code class="language-dart">Function addFunction(int a) {
  return (y) =&gt; a + y;
}

void main() {
  var addFunc = addFunction(12);
  print(addFunc(22));
}
</code></pre>
</li>
</ol>
<h3 id="函数返回值">函数返回值</h3>
<ul>
<li>所有的函数都有返回值</li>
<li>如果没有指定函数返回值，则默认的返回值是null</li>
<li>没有返回值的函数,系统会在最后添加隐式的return语句</li>
</ul>
<h3 id="可选参数">可选参数</h3>
<ul>
<li>
<p>可选命名参数</p>
<p>使用<code>{param1, param2,...}</code>的形式来指定命名参数。</p>
<pre><code class="language-dart">main() {
  func(a:1);
  func(b:1);
  func(a:1, b:1);
}

int func({int a, int b}) {
  return a + b;
}
</code></pre>
</li>
<li>
<p>可选位置参数</p>
<p>将参数使用中括号[]括起来,用来表明是可选位置参数，必填参数要放在可选参数前面。</p>
<pre><code class="language-dart">String getUserInfo(String name, String sex, [String from]) {}
</code></pre>
<p>其中name和sex是必须传入的参数,from参数可以不传</p>
</li>
<li>
<p>参数默认值</p>
<ul>
<li>如果参数指定了默认值,当不传入值时，函数就会使用这个默认值。通常默认值参数为null。</li>
</ul>
<pre><code class="language-dart">String getUserInfo(String name, String sex, [String from = '中国']) {}
</code></pre>
<ul>
<li>可选命名参数默认值(默认值必须是编译时常量)，可以使用等号<code>=</code> 或冒号<code>:</code>，Dart SDK 1.21 之前只能用冒号，冒号的支持以后会移除，所以建议使用<em>等号</em>。</li>
<li>可选位置参数默认值(默认值必须是编译时常量)，只能使用等号<code>=</code>。</li>
<li>可使用list或map作为默认值，但必须是const。</li>
</ul>
<pre><code class="language-dart">int fun([List list = const [1, 2, 3]]) {}
</code></pre>
</li>
</ul>
<h3 id="匿名函数">匿名函数</h3>
<ul>
<li>
<p>可赋值给变量，通过变量调用</p>
<pre><code class="language-dart">main() {
  var func = (int a, int b) =&gt; a + b;
  func(1, 2);
}
</code></pre>
</li>
<li>
<p>可在其他函数中直接调用或传递给其他函数</p>
</li>
</ul>
<h3 id="函数别名">函数别名</h3>
<p>函数别名使用<code>typedef</code>表示，如：</p>
<pre><code class="language-dart">typedef Fun1(int a, int b);
typedef Fun2&lt;T, K&gt;(T a, K b);
</code></pre>
<ul>
<li>typedef给函数起一个别名，使用比较方便。例如定义一个方法的回调，直接使用别名定义。</li>
<li>没返回值，则只要参数匹配就行了，如果定义了返回值，则返回值不一样会报错。</li>
</ul>
<h3 id="main函数">main函数</h3>
<p>Flutter应用程序必须要有一个main函数作为程序的入口函数。</p>
<h2 id="运算符">运算符</h2>
<p>Dart所有的运算符如下表所示， 与java不同的有8个，如下：</p>
<p><code>?.</code>，条件成员访问 和 . 类似，但是左边的操作对象不能为 null，例如 foo?.bar 如果 foo 为 null 则返回 null，否则返回 bar 成员。<br>
<code>~/</code>，除后取整。<br>
<code>as</code>，类型转换。<br>
<code>is</code>，如果对象是指定类型返回true。<br>
<code>is!</code>，如果对象是指定类型返回false。<br>
<code>??</code>，双问号左边为true返回左边结果，否则返回右边结果。<br>
<code>..</code>，级联语法。严格来说， 两个点的级联语法不是一个操作符。 只是一个 Dart 特殊语法。<br>
<code>??:</code>，如果左边是 null，则右边赋值给左边；如果不是 null，则左边的值保持不变。</p>
<table>
<thead>
<tr>
<th><strong>描述</strong></th>
<th style="text-align:center"><strong>操作符</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>后缀操作</td>
<td style="text-align:center">expr++ expr-- () [] . <code>?.</code></td>
</tr>
<tr>
<td>前缀操作</td>
<td style="text-align:center">-expr !expr ~expr ++expr --expr</td>
</tr>
<tr>
<td>乘除</td>
<td style="text-align:center">* /  % <code>~/</code></td>
</tr>
<tr>
<td>加减</td>
<td style="text-align:center">+ -</td>
</tr>
<tr>
<td>位移</td>
<td style="text-align:center">&lt;&lt; &gt;&gt;</td>
</tr>
<tr>
<td>按位与</td>
<td style="text-align:center">&amp;</td>
</tr>
<tr>
<td>按位异或</td>
<td style="text-align:center">^</td>
</tr>
<tr>
<td>按位或</td>
<td style="text-align:center">|</td>
</tr>
<tr>
<td>类型操作</td>
<td style="text-align:center">&gt;= &gt; &lt;= &lt; <code>as</code> <code>is</code> <code>is!</code></td>
</tr>
<tr>
<td>相等</td>
<td style="text-align:center">== !=</td>
</tr>
<tr>
<td>逻辑与</td>
<td style="text-align:center">&amp;&amp;</td>
</tr>
<tr>
<td>逻辑或</td>
<td style="text-align:center">||</td>
</tr>
<tr>
<td>是否为空</td>
<td style="text-align:center"><code>??</code></td>
</tr>
<tr>
<td>三目运算</td>
<td style="text-align:center">expr1 ? expr2 : expr3</td>
</tr>
<tr>
<td>级联</td>
<td style="text-align:center"><code>..</code></td>
</tr>
<tr>
<td>赋值</td>
<td style="text-align:center">= *= /= ~/= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=  <code>??=</code></td>
</tr>
</tbody>
</table>
<h2 id="流程控制语句">流程控制语句</h2>
<p>Dart中控制流程语句和Java类似。List和Set等实现了Iterable接口的类支持for-in遍历元素。</p>
<ul>
<li>if  else</li>
<li>for forEach <code>for-in</code></li>
<li>while  do-while</li>
<li>break continue</li>
<li>switch case</li>
<li>assert</li>
<li>try-catch throw</li>
</ul>
<h2 id="异常处理">异常处理</h2>
<p>异常是表示发生意外错误，如果没有捕获异常，引发异常的隔离程序将被挂起，并且程序终止。</p>
<p>Dart代码可抛出并捕获异常，但Dart的所有异常都是<strong>未检查异常</strong>，方法不声明他们可能抛出的异常,也不需要捕获任何异常。<br>
Dart 代码可以抛出任何非 null 对象为异常，不仅仅是实现了 Exception 或者 Error 的对象。<br>
可以使用on 或者 catch 来声明捕获语句，也可以 同时使用。使用 on 来指定异常类型，使用 catch 来 捕获异常对象。</p>
<ol>
<li>
<p>抛出异常</p>
<pre><code class="language-dart">// 抛出Exception对象
throw FormatException('抛出一个ｆormatException')   
// 抛出Error对象
throw OutMemoryError();    
//或自定义异常
throw '数据非法'
</code></pre>
</li>
<li>
<p>捕获异常</p>
<p><code>catch()</code> 可以指定一个或两个参数来捕获异常，第一个是抛出的异常，第二个是堆栈跟踪，如：</p>
<pre><code class="language-dart">try {
    ...
} on Error catch (e) { // 捕获异常详细信息

} catch　(e, s) { // 堆栈跟踪信息

}
</code></pre>
<p><code>rethrow</code> 把捕获的异常重新抛出</p>
</li>
<li>
<p>Finally</p>
</li>
</ol>
<h2 id="面向对象">面向对象</h2>
<p>Dart作为高级语言支持面向对象的很多特性并且支持基于<code>mixin</code>的继承方式。基于mixin的继承方式是值：一个类可以继承多个父类，相当于其他语言里的多继承，所有的类都有同一个基类<code>Object</code>。</p>
<h3 id="实例化成员变量">实例化成员变量</h3>
<p>类定义中所有的变量都会隐式的定义Setter方法，针对非空的变量会额外增加getter方法</p>
<h3 id="构造函数">构造函数</h3>
<p>dart的构造函数有多种形式，如下：</p>
<ul>
<li>
<p>常规构造函数</p>
<pre><code class="language-dart">class User {
  String name;
  int age;

  User(String name, int age) {
    this.name = name;
    this.age = age;
  }
  // 或
  User(this.name, this.age);  
}
</code></pre>
</li>
<li>
<p>命名的构造函数</p>
<pre><code class="language-dart">class User {
  String name;
  int age;

  User.fromJson(Map json) {
      name = json['name'];
      age = json['age'];
  }
}
</code></pre>
<p>使用命名构造函数可以为一个类实现多个构造函数， 或者使用命名构造函数来更清晰的表明你的意图。</p>
</li>
<li>
<p>重定向构造函数</p>
<pre><code class="language-dart">class User {
  String name;
  int age;

  User(this.name, this.age);

  User.create(String name): this(name,12); 
}
</code></pre>
<p>一个重定向构造函数是没有代码的，在构造函数声明后，使用 冒号调用其他构造函数。</p>
</li>
<li>
<p>构造函数初始化列表</p>
<pre><code class="language-dart">class User {
  // final 修饰的成员变量，只能通过构造方法进行赋值
  final String name;
  final int age;

  // 初始化列表
  User(name, age)
      : name = name,
        age = age;
}
</code></pre>
<p>在构造函数体执行之前可以初始化实例参数。 使用逗号分隔初始化表达式。初始化列表非常适合用来设置 final 变量的值。</p>
</li>
<li>
<p>调用超类构造函数</p>
<p>在构造方法处使用<code>super</code>关键字，如：</p>
<pre><code class="language-dart">class User extends Person {
  // final 修饰的成员变量，只能通过构造方法进行赋值
  final String name;
  final int age;

  // 初始化列表
  User(this.name, this.age):super(name,age);
}
</code></pre>
</li>
<li>
<p>常量构造函数</p>
<pre><code class="language-dart">class User {
  // 定义const构造函数要确保所有的成员变量都是final修饰
  final String name;
  final int age;

  static final User user = const User('111', 12);

  // const 关键字放在构造函数名前，且不能有函数体
  const User(this.name, this.age);
}
</code></pre>
</li>
<li>
<p>工厂构造函数(单例)</p>
<pre><code class="language-dart">class User {
  String name;
//工厂构造函数无法访问this，所以这里要用static
  static User _user;
//工厂方法构造函数，关键字factory
  factory User([String name]) {
    return User._user ??= User._(name);
  }
//定义一个命名构造函数用来生产实例
  User._(this.name);
}
</code></pre>
</li>
</ul>
<h3 id="读取和写入对象getter-setter">读取和写入对象（Getter、Setter）</h3>
<ul>
<li>get()和set()方法是专门用于读取和写入对象的属性的方法。</li>
<li>每一个类的实例，系统都隐式地包含有get()和set()方法。</li>
<li>final 修饰的变量没有setter方法。</li>
<li>可以使用get 和 set 关键字定义getter和setter。</li>
</ul>
<pre><code class="language-dart">class User {
  String name;

  User(this.name);

  String get username =&gt; 'getter ${this.name}';
  set username(String name) =&gt; this.name = name;
}
</code></pre>
<h3 id="重载操作">重载操作</h3>
<p>采用operator修饰，如：</p>
<pre><code class="language-dart">class Vector {
  final int x;
  final int y;

  const Vector(this.x, this.y);

  Vector operator +(Vector v) {
    return Vector(x + v.x, y + v.y);
  }
}
</code></pre>
<h3 id="抽象类">抽象类</h3>
<ul>
<li>抽象类采用<code>abstract</code>关键字修饰<code>class</code>。f</li>
<li>不能被实例化，除非定义一个工厂构造函数。</li>
<li>抽象类通常用来定义接口， 以及部分实现。</li>
<li>抽象类通常具有抽象方法，抽象方法不需要关键字，以分号结束即可。</li>
<li>接口方式使用时，需要重写抽象类的成员变量和方法，包括私有的。</li>
<li>一个类可以implement一个普通类。Dart任何一个类都是接口。</li>
<li>一个类可以implement多个接口。</li>
</ul>
<h3 id="可调用类">可调用类</h3>
<p>类实现 <code>call()</code> 方法可以让类像函数一样能够被调用。</p>
<pre><code class="language-dart">class ClassFunction {
  call(String a, String b, String c) =&gt; '$a, $b, $c';
}

main() {
  var cf = ClassFunction();
  var out = cf('a1', 'b1', 'c1');
  print('out: $out');
  print(cf.runtimeType);
  print(out.runtimeType);
  print(cf is Function);
}
</code></pre>
<h3 id="枚举类">枚举类</h3>
<p>与java一致，采用<code>enum</code>修饰。</p>
<pre><code class="language-dart">enum Type {
  A, B, C
}
</code></pre>
<h3 id="mixins">Mixins</h3>
<p>Mixins(混入功能)相当于多继承，使用with关键字来实现Mixins的功能</p>
<pre><code class="language-dart">class S {
  a() =&gt; print('S.a');
}

class A {
  a() =&gt; print('A.a');
  b() =&gt; print('A.b');
}

class T = A with S;
</code></pre>
<ol>
<li>子类没有重写超类A方法的前提下，如果2个或多个超类拥有相同签名的A方法，那么子类会以继承的最后一个超类中的A方法为准。</li>
<li>如果子类自己重写了A方法则以本身的A方法为准。</li>
</ol>
<h2 id="泛型">泛型</h2>
<p>Dart1.21开始可以使用泛型函数。泛型函数可以在以下几个地方使用类型参数：</p>
<ul>
<li>函数的返回值类型。</li>
<li>参数的类型。</li>
<li>局部变量的类型。</li>
</ul>
<pre><code class="language-dart">main() {
  K addCache&lt;K, V&gt;(K key, V value) {
    K temp = key;
    print('${key}: ${value}');
    return temp;
  }
  var key = addCache('key', 'value');
  print(key);
}
</code></pre>
<p>要在使用构造函数时指定一个或多个类型，可将类型放在类名称后面的尖括号&lt;...&gt;中:</p>
<pre><code class="language-dart">main() {
  var p = Phone&lt;String&gt;('123456');
  print(p.mobileNumber);
}

class Phone&lt;T&gt; {
  final T mobileNumber;
  Phone(this.mobileNumber);
}
</code></pre>
<p>实现泛型类型时，您可能希望限制其参数的类型，可以在<code>&lt;&gt;</code>里面使用<code>extends</code>。</p>
<pre><code class="language-dart">main() {
  var man = Man();
  var m = User&lt;Man&gt;(man);
  m.man.doMassage();
}

class User&lt;T extends Man&gt; {
  final T man;
  User(this.man);
}

class Man {
  void doMassage() {}
}
</code></pre>
<p>与java一致， 唯一区别：Java泛型是编译时的，在运行时泛型信息会被擦除，Dart的泛型类型是固化的，在运行时也可以判断具体类型。</p>
<pre><code class="language-dart">var names = List&lt;String&gt;();
print(names is List&lt;String&gt;);//true
print(names.runtimeType); // List&lt;String&gt; 
</code></pre>
<h2 id="库的使用">库的使用</h2>
<h3 id="引用库">引用库</h3>
<p>通过import语句在一个库中引入另一个库文件：</p>
<ol>
<li>在import语句后面需要接上库文件的路径</li>
<li>对dart语言提供的库文件使用dart:xx格式</li>
<li>第三方的库文件使用package:xx格式</li>
</ol>
<pre><code class="language-dart">import 'dart:io'; 
import 'package:mylib/mylib.dart'; 
import 'package :utils/utils.dart' ; 
</code></pre>
<h3 id="指定一个库的前缀">指定一个库的前缀</h3>
<p>当引用的库拥有相互冲突的名字，可以为其中一个或几个指定不一样的前缀。</p>
<pre><code class="language-dart">import 'package:libl/ libl.dart '; 
import 'package:lib2 / lib2.dart ' as lib2 ;
</code></pre>
<h3 id="引用库的一部分">引用库的一部分</h3>
<p>如果只需要使用库的一部分内容，可以有选择性地引用，有如下关键字：</p>
<ul>
<li>show 关键字：　只引用一点</li>
<li>hide 关键字：　除此之外都引用</li>
</ul>
<pre><code class="language-dart">／／ 导入 foo
import 'package:libl/libl.dart' show foo; 
／／ 除了 foo 导入其他所有内容
import 'package:lib2 / lib2.dart' hide foo; 
</code></pre>
<h3 id="库的延迟载入">库的延迟载入</h3>
<ul>
<li>使用<code>deferred as</code>导入</li>
<li>使用标识符调用<code>loadLibrary()</code> 加载库</li>
</ul>
<pre><code class="language-dart">import 'dart:io' deferred as io;

lazyLoad() async {
  //使用 await 关键字暂停代码执行一直到库加载完成。
  await io.loadLibrary();
}

main() {
  lazyLoad();
}
</code></pre>
<ul>
<li>优点：
<ul>
<li>可提高程序启动速度。</li>
<li>用在不常使用的功能。</li>
<li>用在载入时间过长的包。</li>
<li>执行 A/B 测试，例如 尝试各种算法的 不同实现。</li>
</ul>
</li>
</ul>
<h2 id="异步使用">异步使用</h2>
<p>Dart支持异步操作，一般使用<code>async</code>函数和<code>await</code>表达式实现异步操作，Dart库提供<code>asynchronous</code>功能,该功能提供接口来消耗时间的操作，比如文件读写,网络请求。该功能返回<code>Future</code>或<code>Stream</code>对象。</p>
<p>可以通过如下的方式来获取asynchronous功能返回的Future对象值:</p>
<ul>
<li>使用async函数和await表达式</li>
<li>使用Future功能提供的API</li>
</ul>
<p>可以通过如下方式来获取asynchronous功能返回的Stream对象的值:</p>
<ul>
<li>使用async和一个异步的循环(await for)</li>
<li>使用Stream的相关API</li>
</ul>
<h3 id="async-await">async / await</h3>
<p>await关键字必须在async函数内部使用，await表达式可以使用多次</p>
<pre><code class="language-dart">void main(){
  getName1();
  getName2();
  getName3();
}

Future getName1() async {
  await getStr1();
  await getStr2();
  print('getName1’);
}
getStr1() {
  print('getStr1’);
}
getStr2() {
  print('getStr2’);
}
getName2() {
  print('getName2’);
}
getName3() {
  print('getName3’);
}

/// 输出结果： getStr1 getName2  getName3  getStr2  getName1
</code></pre>
<h3 id="thencatcherrorwhencomplete">then,catchError,whenComplete</h3>
<p>如果需要监听“完毕”这个状态，那么用<code>whenComplete</code>，需要监听“成功”这个状态，用<code>then</code>，需要监听“失败”这个状态，用<code>catchError</code>。<br>
如果重写了test方法，test返回true就可以在catchError的onError方法里捕获到异常，如果test返回false，就把该异常继续抛出而不会在catchError方法里被捕获，如果不写test默认实现一个返回true的test方法</p>
<pre><code class="language-dart">void main() {
  Future(() =&gt; futureTask()) //异步任务的函数
      .then((m) =&gt; &quot;result:$m&quot;) //任务执行完后的子任务
      .then((m) =&gt; m.length) //其中m为上个任务执行完后的返回的结果
      .then((m) =&gt; printLength(m))
      .catchError(print) // 拦截错误，如果实现了test方法，只有return true时才会拦截，否则不会
      .whenComplete(() =&gt; whenTaskCompelete()); //所有任务完成后的回调函数
}

whenTaskCompelete() {
  print('task complete');
}

futureTask() async {
  return 'future';
}

printLength(dynamic name) {
  if (name is! String || name.length &lt; 3 || name.length &gt; 15) {
    throw '长度错误';
  }
}
</code></pre>
<h3 id="event-looper">Event-Looper</h3>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-45-02-event-loop.png" alt="event-loop.png" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-45-33-event-loop-process.png" alt="event-loop-process.png" loading="lazy"></figure>
<ol>
<li>一个消息循环的职责就是不断从消息队列中取出消息并处理他们直到消息队列为空。</li>
<li>消息队列中的消息可能来自用户输入，文件I/O消息，定时器等。例如上图的消息队列就包含了定时器消息和用户输入消息。</li>
<li>Dart中的<code>Main Isolate</code>只有一个<code>Event Looper</code>，但是存在两个Event Queue: <code>Event Queue</code>以及<code>Microtask Queue</code>。</li>
</ol>
<h3 id="event-queue和microtask-queue">Event Queue和Microtask Queue</h3>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-46-08-event-microtask.png" alt="event-microtask.png" loading="lazy"></figure>
<ul>
<li>优先全部执行完Microtask Queue中的Event。</li>
<li>直到Microtask Queue为空时，才会执行Event Queue中的Event。</li>
<li>当Event Looper正在处理Microtask Queue中的Event时候，Event Queue中的Event就停止了处理了，此时App不能绘制任何图形，不能处理任何鼠标点击，不能处理文件IO等等。</li>
<li>绘制图形，处理鼠标点击，处理文件IO等都是在Event Queue里完成的。</li>
</ul>
<h3 id="任务调度">任务调度</h3>
<ul>
<li>使用Future类，可以将任务加入到Event Queue的队尾</li>
<li>使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾</li>
<li>优先全部执行完Microtask Queue中的Event，直到Microtask Queue为空时，才会执行Event Queue中的Event。</li>
</ul>
<h3 id="future">Future</h3>
<ul>
<li>使用 Future（）将任务加入event队列。</li>
<li>Future中的<code>then</code>并没有创建新的Event丢到<code>Event Queue</code>中，而只是一个普通的<code>Function Call</code>，在FutureTask执行完后，立即开始执行。</li>
<li>如果在then()调用之前Future就已经执行完毕了，那么任务会被加入到<code>microtask</code>队列中，并且该任务会执行then()中注册的回调函数。</li>
<li>使用Future.value构造函数的时候，就会上一条一样，创建Task丢到microtask Queue中执行then传入的函数。</li>
<li>Future.sync构造函数执行了它传入的函数之后，也会立即创建Task丢到microtask Queue中执行。</li>
<li>当任务需要延迟执行时，可以使用new Future.delay()来将任务延迟执行。</li>
</ul>
<pre><code class="language-dart">void main(){
  testFuture();
}
void testFuture() {
  Future f = new Future(() =&gt; print('f1'));
  Future f1 = new Future(() =&gt; null);
  //Future f1 = new Future.delayed(Duration(seconds: 1) ,() =&gt; null);
  Future f2 = new Future(() =&gt; null);
  Future f3 = new Future(() =&gt; null);
  f3.then((_) =&gt; print('f2'));
  f2.then((_) {
    print('f3');
    new Future(() =&gt; print('f4'));
    f1.then((_) {
      print('f5');
    });
  });
  f1.then((m) {
    print('f6');
  });
  print('f7');
}
</code></pre>
<h3 id="schedulemicrotask">scheduleMicrotask()</h3>
<ul>
<li>如果可以，尽量将任务放入event队列中。</li>
<li>使用Future的then方法或whenComplete方法来指定任务顺序。</li>
<li>为了保持你app的可响应性，尽量不要将大计算量的任务放入这两个队列。</li>
<li>大计算量的任务放入额外的isolate中。</li>
</ul>
<pre><code class="language-dart">import 'dart:async';
void main(){
  testScheduleMicrotask();
}
void testScheduleMicrotask(){
  scheduleMicrotask(() =&gt; print('s1'));

  new Future.delayed(new Duration(seconds: 1), () =&gt; print('s2'));

  new Future(() =&gt; print('s3')).then((_) {
    print('s4');
    scheduleMicrotask(() =&gt; print('s5'));
  }).then((_) =&gt; print('s6'));

  new Future(() =&gt; print('s7'));

  scheduleMicrotask(() =&gt; print('s8'));

  print('s9');
}
</code></pre>
<h2 id="隔离isolate">隔离（isolate）</h2>
<p>所有Dart代码都在隔离区内运行，而不是线程。每个隔离区都有自己的内存堆，确保不会从任何其他隔离区访问隔离区的状态。</p>
<p>Dart没有共享内存的并发，没有竞争的可能性所以不需要锁，也就不用担心死锁的问题。</p>
<p>isolate之间没有共享内存，所以他们之间的通信唯一方式只能是通过Port进行，而且Dart中的消息传递总是异步的。</p>
<p>isolate神似Thread，但实际上两者有本质的区别。操作系统内的线程之间是可以有共享内存的而isolate没有，这是最为关键的区别。</p>
<h2 id="元数据">元数据</h2>
<p>使用元数据给代码添加更多的信息。元数据是以＠开始的修饰符，在＠后面接着编译时的常量或者一个常量构造函数。</p>
<ul>
<li>@deprecated 被弃用</li>
<li>@override　重写</li>
<li>@proxy 代理</li>
</ul>
<p>元数据可以修饰 library、class、typedef、type parameter、constructor、factory、function、field、parameter、variable declaration。</p>
<h3 id="注释">注释</h3>
<ul>
<li>
<p>单行注释以//开头。Dart编译器会忽略//和行尾之间的所有内容。</p>
<pre><code class="language-dart">// 这是单行注释
</code></pre>
</li>
<li>
<p>多行注释以/<em>开头，以</em>/结尾。介于/*和 */两者之间的内容会被编译器忽略（除非该注释是一个文档注释)。</p>
<pre><code class="language-dart">/*
 * 这是多行注释
 * 这是多行注释 
 */
</code></pre>
<p>多行注释可以嵌套</p>
</li>
<li>
<p>文档注释以///或者/**开头。可以通过dartdoc命令导出文档。</p>
<pre><code class="language-dart">/// 这是文档注释

/**
  * 这是文档注释
  */
</code></pre>
</li>
</ul>

                    </div>
                    <div class="essaySuffix-box">
                        <div class="essaySuffix-box-left"><img
                                src="/images/avatar.png" alt="">
                        </div>
                        <div class="essaySuffix-box-right"><span
                                class="essaySuffix-right-title">本文作者</span>：<strong><span style="font-size: 12px;"><a
                                        href="/about"
                                        target="_blank">Xiaowu</a></span></strong> <br><span
                                style="font-weight: bold; white-space:nowrap;">本文链接</span>：<a
                                href="https://jxiaow.gitee.io/posts/b8c700d2/"
                                target="_blank">https://jxiaow.gitee.io/posts/b8c700d2/</a><br><span
                                class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a
                                href="https://creativecommons.org/licenses/by-nc-nd/4.0/" alt="BY-NC-SA"
                                title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</div>
                        <div style="clear: both;"></div>
                    </div>
                </div>
                <!-- </div> -->
                <div class="toc-container">
                    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">变量与基本类型</a>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E">变量的声明</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">变量的默认值</a></li>
<li><a href="#final-%E5%92%8C-const">final 和 const</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">函数定义</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">函数返回值</a></li>
<li><a href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0">可选参数</a></li>
<li><a href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%AB%E5%90%8D">函数别名</a></li>
<li><a href="#main%E5%87%BD%E6%95%B0">main函数</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li>
<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">流程控制语句</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">实例化成员变量</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E5%AF%B9%E8%B1%A1getter-setter">读取和写入对象（Getter、Setter）</a></li>
<li><a href="#%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C">重载操作</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E7%B1%BB">可调用类</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB">枚举类</a></li>
<li><a href="#mixins">Mixins</a></li>
</ul>
</li>
<li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></li>
<li><a href="#%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8">库的使用</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E5%BA%93">引用库</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%BA%93%E7%9A%84%E5%89%8D%E7%BC%80">指定一个库的前缀</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E5%BA%93%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">引用库的一部分</a></li>
<li><a href="#%E5%BA%93%E7%9A%84%E5%BB%B6%E8%BF%9F%E8%BD%BD%E5%85%A5">库的延迟载入</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5%E4%BD%BF%E7%94%A8">异步使用</a>
<ul>
<li><a href="#async-await">async / await</a></li>
<li><a href="#thencatcherrorwhencomplete">then,catchError,whenComplete</a></li>
<li><a href="#event-looper">Event-Looper</a></li>
<li><a href="#event-queue%E5%92%8Cmicrotask-queue">Event Queue和Microtask Queue</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6">任务调度</a></li>
<li><a href="#future">Future</a></li>
<li><a href="#schedulemicrotask">scheduleMicrotask()</a></li>
</ul>
</li>
<li><a href="#%E9%9A%94%E7%A6%BBisolate">隔离（isolate）</a></li>
<li><a href="#%E5%85%83%E6%95%B0%E6%8D%AE">元数据</a>
<ul>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
</ul>
</li>
</ul>
</li>
</ul>

                </div>
            </article>
            <!-- </div> -->

          

            
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://jxiaow.gitee.io/posts/b74c4b6c/" class="post-title gt-a-link">
                    Dagger 2 进阶使用
                </a>
            </div>
            

            

            
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'CAmH4sFTLPMg3inDkFSqWsuL-gzGzoHsz',
		appKey: '3Mh9SPxWQ7QbJjxmX7EU26z4',
		avatar: 'mp',
		pageSize: 5,
		recordIp: true,
		placeholder: '快来吐槽吧~',
		visitor: true,
	});
</script>

            

            <div class="site-footer gt-c-content-color-first">

  <div class="social-container">

    <a href="https://github.com/jxiaow" target="_blank" title="https://github.com/jxiaow">
      <i class="fab fa-github gt-c-content-color-first"></i>
    </a>

    <a href="https://www.cnblogs.com/xiaowj" target="_blank" title="https://www.cnblogs.com/xiaowj">
      <i class="fas fa-blog gt-c-content-color-first"></i>
    </a>

    <a href="https://blog.csdn.net/xiaowu_zhu" target="_blank" title="https://blog.csdn.net/xiaowu_zhu">
      <i class="fab fa-cuttlefish gt-c-content-color-first"></i>
    </a>

    <a href="mailto:jxiaow@126.com" title="jxiaow@126.com">
      <i class="fas fa-envelope gt-c-content-color-first"></i>
    </a>

  </div>
  <div class="slogan gt-c-content-color-first">心若没有栖息的地方，到哪里都是在流浪</div>
  
  <div>
    <div>
      Theme by <a href="https://github.com/jxiaow/gridea-theme-pure-fashion" target="_blank">jxiaow</a>, Powered by <a
              href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://jxiaow.gitee.io/atom.xml" target="_blank">RSS</a></a>
  </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

            <script>
  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");
  
  if (mainNavLinks == null || mainNavLinks.length == 0) {
    let tocContainer = document.querySelector(".toc-container");
    tocContainer.classList.remove("toc-container")
    // tocContainer.parentElement.firstElementChild.style.width = "100%"
    console.log("隐藏大纲")
  } else {

    // This should probably be throttled.
    // Especially because it triggers during smooth scrolling.
    // https://lodash.com/docs/4.17.10#throttle
    // You could do like...
    // window.addEventListener("scroll", () => {
    //    _.throttle(doThatStuff, 100);
    // });
    // Only not doing it here to keep this Pen dependency-free.


    window.addEventListener("scroll", event => {
      let fromTop = window.scrollY;

      mainNavLinks.forEach((link, index) => {
        let section = document.getElementById(decodeURI(link.hash).substring(1));
        let nextSection = null
        if (mainNavLinks[index + 1]) {
          nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
        }
        if (section.offsetTop <= fromTop) {
          if (nextSection) {
            if (nextSection.offsetTop > fromTop) {
              link.classList.add("current");
            } else {
              link.classList.remove("current");
            }
          } else {
            link.classList.add("current");
          }
        } else {
          link.classList.remove("current");
        }
      });
    });
  }



</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll("figure > img");
  //   debugger
  //   console.log("dddd: "+ images);
  images.forEach(image => {
    var parent = image.parentElement;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'gallery';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.appendChild(aelem);
  })

//   <a data-fancybox="gallery" href="big_1.jpg"><img src="small_1.jpg"></a>
// <a data-fancybox="gallery" href="big_2.jpg"><img src="small_2.jpg"></a>
</script>
        </div>
    </div>

</body>

</html>