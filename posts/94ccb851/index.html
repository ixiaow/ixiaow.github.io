<html>

<head>
    <meta charset="utf-8"/>
<meta name="description" content="心若没有栖息的地方，到哪里都是在流浪"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>UI绘制流程 | Xiaowu</title>

<link rel="shortcut icon" href="https://jxiaow.gitee.io/favicon.ico?v=1608688629201">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://jxiaow.gitee.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">


<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>

<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.0/mermaid.min.js"></script>
<script>
    var config = {
        startOnLoad:true,
        flowchart:{
            useMaxWidth:false,
            htmlLabels:true
        }
    };
    mermaid.initialize(config);
    $(function(){
        var elements = document.getElementsByClassName("language-mermaid");
        for (var i = elements.length; i--;) {
            element = elements[i];
            var graphDefinition = element.innerText;
            if (graphDefinition) {
                var svg = mermaid.render('ha_mermaid_' + i, graphDefinition, function(svg){});
                if (svg) {
                    var svgElement = document.createElement('div');
                    preNode = element.parentNode;
                    svgElement.innerHTML = svg;
                    svgElement.setAttribute('class', 'mermaid');
                    svgElement.setAttribute('data-processed', 'true');
                    preNode.parentNode.replaceChild(svgElement, preNode);
                }
            }
        }
    });
</script>
</head>

<body>
    <div class="main gt-bg-theme-color-first">
        <nav class="navbar navbar-expand-lg">
    <a href="/">
        <div class="navbar-brand">
            <img class="user-avatar" src="/images/avatar.png" alt="头像">
            <div class="site-name gt-c-content-color-first">
                Xiaowu
            </div>
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav " style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://jxiaow.gitee.io/posts/favourite" class="menu gt-a-link">
                            收藏
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1608688629201" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

        <div class="post-container">

            <!-- <div class="post-detail gt-bg-theme-color-second"> -->
            <article style="display:flex;">
                <div class="post-detail gt-bg-theme-color-second gt-post-content">
                    <h2 class="post-title">
                        UI绘制流程
                    </h2>
                    <div class="post-info">
                        <div>
                            <time class="post-time gt-c-content-color-first">
                                · 2020-12-17 ·
                            </time>
                            
                            <a href="https://jxiaow.gitee.io/tag/QAu6AEWYg/" class="post-tags">
                                # Draw
                            </a>
                            
                            <a href="https://jxiaow.gitee.io/tag/GJLfjss5g/" class="post-tags">
                                # UI
                            </a>
                            
                            <a href="https://jxiaow.gitee.io/tag/f3tbfHeq9/" class="post-tags">
                                # Android
                            </a>
                            
                        </div>
                        <div>
                            
                            <span id="/posts/94ccb851/"
                                class="leancloud_visitors" data-flag-title="UI绘制流程">
                                <em class="post-meta-item-text">阅读量 </em>
                                <i class="leancloud-visitors-count">0</i>
                            </span>
                            
                        </div>
                    </div>

                    <!-- <div class="post-content-wrapper"> -->
                    <div class="post-content">
                        <blockquote>
<p>自定义<code>View</code>最重要的部分是外观。绘制自定义视图可能很简单，也可能很复杂，具体取决于应用的需求。</p>
</blockquote>
<p>在自定义view中，<code>onDraw()</code>扮演着非常重要的角色。通过对它的仔细探究就可以知道view是怎么画出来的。</p>
<h2 id="绘制流程">绘制流程</h2>
<p>在之前了解绘制流程中可以知道<code>ViewRootImpl#performTraversals()</code>方法中调用了<code>performMeasure()</code>、<code>performLayout()</code>和<code>performDraw()</code>。</p>
<h3 id="viewrootimplperformtraversals">ViewRootImpl#performTraversals()</h3>
<pre><code class="language-java">private void performTraversals() {
    // ...
    if (!cancelDraw) {
        // ...
        performDraw();
    } else {
        if (isViewVisible) {
            // Try again
            scheduleTraversals();
        } else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) {
            for (int i = 0; i &lt; mPendingTransitions.size(); ++i) {
                mPendingTransitions.get(i).endChangingAnimations();
            }
            mPendingTransitions.clear();
        }
    }
    // ...
}
</code></pre>
<h3 id="performdraw">performDraw()</h3>
<pre><code class="language-java">private void performDraw() {
    // ...
    final boolean fullRedrawNeeded = mFullRedrawNeeded || mReportNextDraw;
    // ...
    try {
        // ...
        boolean canUseAsync = draw(fullRedrawNeeded);
       // ...
    } finally {
        mIsDrawing = false;
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
</code></pre>
<p>在<code>performDraw()</code>中调用了<code>draw()</code>，参数<code>fullRedrawNeeded</code>的作用是判断是否需要重新绘制全部视图，如果是第一次绘制视图，需要全部绘制，如果由于某些原因，导致视图重绘则不需要绘制所有视图。</p>
<h3 id="draw">draw()</h3>
<pre><code class="language-java">private boolean draw(boolean fullRedrawNeeded) {
    // ...
    // mDirty 表示需要绘制视图的区域
    final Rect dirty = mDirty;
    if (mSurfaceHolder != null) {
        // The app owns the surface, we won't draw.
        dirty.setEmpty();
        if (animating &amp;&amp; mScroller != null) {
            mScroller.abortAnimation();
        }
        return false;
    }
    // 如果需要全部重新绘制，则绘制区域为整个屏幕
    // 第一次绘制流程需要绘制整个屏幕
    if (fullRedrawNeeded) {
        dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));
    }
 
    // ...
    boolean useAsyncReport = false;
    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {
        if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) {
            // If accessibility focus moved, always invalidate the root.
            boolean invalidateRoot = accessibilityFocusDirty || mInvalidateRootRequested;
            mInvalidateRootRequested = false;
 
            // Draw with hardware renderer.
            mIsAnimating = false;
 
            if (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) {
                mHardwareYOffset = yOffset;
                mHardwareXOffset = xOffset;
                invalidateRoot = true;
            }
 
            if (invalidateRoot) {
                mAttachInfo.mThreadedRenderer.invalidateRoot();
            }
 
            dirty.setEmpty();
 
            // Stage the content drawn size now. It will be transferred to the renderer
            // shortly before the draw commands get send to the renderer.
            final boolean updated = updateContentDrawBounds();
 
            if (mReportNextDraw) {
                // report next draw overrides setStopped()
                // This value is re-sync'd to the value of mStopped
                // in the handling of mReportNextDraw post-draw.
                mAttachInfo.mThreadedRenderer.setStopped(false);
            }
 
            if (updated) {
                requestDrawWindow();
            }
 
            useAsyncReport = true;
 
            mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this);
        } else {
            // ...
            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,
                              scalingRequired, dirty, surfaceInsets)) {
                return false;
            }
        }
    }
 
    if (animating) {
        mFullRedrawNeeded = true;
        scheduleTraversals();
    }
    return useAsyncReport;
}
</code></pre>
<p>在<code>draw()</code>中首先获取了<code>mDirty</code>值，接着根据<code>fullRedrawNeeded</code>的值判断是否需要重置绘制区域，最后调用了<code>drawSoftware()</code>。</p>
<h3 id="drawsoftware">drawSoftware()</h3>
<pre><code class="language-java">private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
                             boolean scalingRequired, Rect dirty, Rect surfaceInsets) {
 
    // Draw with software renderer.
    final  Canvas canvas;
    // ...
    try {
        // ...
        // 锁定canvas区域，区域范围由dirty决定
        canvas = mSurface.lockCanvas(dirty);
        // TODO: Do this in native
        // canvas设置像素密度
        canvas.setDensity(mDensity);
    }
    // ...
    try {
        //...
        // 清除位图格式的alpha通道，以便子控件重新组合其图纸上的透明背景
        // 避免在未出现偏移的情况下空白区域出现垃圾
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }
        // ...
        // view调用draw方法
        mView.draw(canvas);
        drawAccessibilityFocusedDrawableIfNeeded(canvas);
    } finally {
        // ...
    }
    return true;
}
</code></pre>
<p>上述关键代码可以看出，首先获取<code>Canvas</code>对象，然后锁定该canvas的区域，该区域由dirty决定，接着对canvas进行赋值，最后调用了<code>mView.draw(canvas)</code>方法。</p>
<h3 id="viewdraw">View#draw()</h3>
<pre><code class="language-java">@CallSuper
public void draw(Canvas canvas) {
    final int privateFlags = mPrivateFlags;
    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
 
    /*
     * Draw traversal performs several drawing steps which must be executed
     * (绘制遍历执行必须执行的几个绘图步骤)
     * in the appropriate order:
     *
     *   1. Draw the background (绘制背景)
     *   2. If necessary, save the canvas' layers to prepare for fading (如有必要，保存画布已准备渐变)
     *   3. Draw view's content (画视图内容)
     *   4. Draw children （画子控件）
     *   5. If necessary, draw the fading edges and restore layers （如有必要，绘制渐变边缘并恢复图层）
     *   6. Draw decorations (scrollbars for instance) （绘制装饰（例如滚动条））
     *   7. If necessary, draw the default focus highlight （如有必要，绘制焦点）
     */
    // Step 1, draw the background, if needed
    int saveCount;
 
    drawBackground(canvas);
 
    // skip step 2 &amp; 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges &amp;&amp; !horizontalEdges) {
        // Step 3, draw the content
        onDraw(canvas);
 
        // Step 4, draw the children
        dispatchDraw(canvas);
 
        drawAutofilledHighlight(canvas);
 
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
 
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
 
        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);
 
        if (isShowingLayoutBounds()) {
            debugDrawFocus(canvas);
        }
 
        // we're done...
        return;
    }
 
    /*
     * Here we do the full fledged routine...
     * (this is an uncommon case where speed matters less,
     * this is why we repeat some of the tests that have been
     * done above)
     */   
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
 
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
 
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
 
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
 
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
 
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
 
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
 
    // clip the fade length if top and bottom fades overlap
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) {
        length = (bottom - top) / 2;
    }
 
    // also clip horizontal fades if necessary
    if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) {
        length = (right - left) / 2;
    }
 
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight &gt; 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f;
    }
 
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight &gt; 1.0f;
    }
 
    saveCount = canvas.getSaveCount();
    int topSaveCount = -1;
    int bottomSaveCount = -1;
    int leftSaveCount = -1;
    int rightSaveCount = -1;
 
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        if (drawTop) {
            topSaveCount = canvas.saveUnclippedLayer(left, top, right, top + length);
        }
 
        if (drawBottom) {
            bottomSaveCount = canvas.saveUnclippedLayer(left, bottom - length, right, bottom);
        }
 
        if (drawLeft) {
            leftSaveCount = canvas.saveUnclippedLayer(left, top, left + length, bottom);
        }
 
        if (drawRight) {
            rightSaveCount = canvas.saveUnclippedLayer(right - length, top, right, bottom);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
 
    // Step 3, draw the content
    onDraw(canvas);
 
    // Step 4, draw the children
    dispatchDraw(canvas);
 
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
 
    // must be restored in the reverse order that they were saved
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(rightSaveCount, p);
        } else {
            canvas.drawRect(right - length, top, right, bottom, p);
        }
    }
 
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(leftSaveCount, p);
        } else {
            canvas.drawRect(left, top, left + length, bottom, p);
        }
    }
 
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(bottomSaveCount, p);
        } else {
            canvas.drawRect(left, bottom - length, right, bottom, p);
        }
    }
 
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(topSaveCount, p);
        } else {
            canvas.drawRect(left, top, right, top + length, p);
        }
    }
 
    canvas.restoreToCount(saveCount);
 
    drawAutofilledHighlight(canvas);
 
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
 
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
 
    // Step 7, draw the default focus highlight
    drawDefaultFocusHighlight(canvas);
 
    if (isShowingLayoutBounds()) {
        debugDrawFocus(canvas);
    }
}
</code></pre>
<p>可以看到，draw过程比较复杂，但是逻辑十分清晰，而官方注释也清楚地说明了每一步的做法。</p>
<p>绘制流程的七个步骤：</p>
<ol>
<li>对View的背景进行绘制；</li>
<li>保存当前的图层信息；( <code>skip step 2 &amp; 5 if possible (common case)</code>)</li>
<li>绘制View的内容；</li>
<li>对View的子View进行绘制(如果有子View)；</li>
<li>绘制View的褪色的边缘，类似于阴影效果并恢复图层信息；( <code>skip step 2 &amp; 5 if possible (common case)</code>)</li>
<li>绘制View的装饰；</li>
<li>绘制焦点部分。</li>
</ol>
<h3 id="drawbackground">drawBackground()</h3>
<p>画背景</p>
<pre><code class="language-java">private void drawBackground(Canvas canvas) {
    // 如果视图没有背景色，则不用绘制
    final Drawable background = mBackground;
    if (background == null) {
        return;
    }
    // 根据布局的四个参数来确定背景的边界
    setBackgroundBounds();
    // ...
    // 获取当前view的scroll值
    final int scrollX = mScrollX;
    final int scrollY = mScrollY;
    if ((scrollX | scrollY) == 0) {
        background.draw(canvas);
    } else {
        // 如果有值则偏移后 绘制
        canvas.translate(scrollX, scrollY);
        background.draw(canvas);
        canvas.translate(-scrollX, -scrollY);
    }
}
</code></pre>
<pre><code class="language-java">void setBackgroundBounds() {
    if (mBackgroundSizeChanged &amp;&amp; mBackground != null) {
        // 设置背景四个参数
        mBackground.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
        mBackgroundSizeChanged = false;
        rebuildOutline();
    }
}
</code></pre>
<p>保存图层和恢复图层暂不考虑。</p>
<pre><code class="language-java">//skip step 2 &amp; 5 if possible (common case)
</code></pre>
<h3 id="ondraw">onDraw()</h3>
<pre><code class="language-java">protected void onDraw(Canvas canvas) {
}
</code></pre>
<p>View中该方法是一个空实现，这里同理于之前的<code>onMeasure</code>和<code>onLayout</code>因为不同的View有着不同的内容，这需要我们自己去实现，即在自定义View中重写该方法来实现。</p>
<h3 id="dispatchdraw">dispatchDraw()</h3>
<p><code>dispatchDraw()</code>在view中是空实现，我们可以看看<code>ViewGroup</code>中的。</p>
<pre><code class="language-java">@Override
protected void dispatchDraw(Canvas canvas) {
    boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
    final int childrenCount = mChildrenCount;
    final View[] children = mChildren;
    int flags = mGroupFlags;
 
    if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) {
        final boolean buildCache = !isHardwareAccelerated();
        for (int i = 0; i &lt; childrenCount; i++) {
            final View child = children[i];
            if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) {
                final LayoutParams params = child.getLayoutParams();
                attachLayoutAnimationParameters(child, params, i, childrenCount);
                bindLayoutAnimation(child);
            }
        }
 
        final LayoutAnimationController controller = mLayoutAnimationController;
        if (controller.willOverlap()) {
            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;
        }
 
        controller.start();
 
        mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;
        mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;
 
        if (mAnimationListener != null) {
            mAnimationListener.onAnimationStart(controller.getAnimation());
        }
    }
 
    int clipSaveCount = 0;
    final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);
        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,
                        mScrollX + mRight - mLeft - mPaddingRight,
                        mScrollY + mBottom - mTop - mPaddingBottom);
    }
 
    // We will draw our child's animation, let's reset the flag
    mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;
    mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;
 
    boolean more = false;
    final long drawingTime = getDrawingTime();
 
    if (usingRenderNodeProperties) canvas.insertReorderBarrier();
    final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();
    int transientIndex = transientCount != 0 ? 0 : -1;
    // Only use the preordered list if not HW accelerated, since the HW pipeline will do the
    // draw reordering internally
    final ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties
        ? null : buildOrderedChildList();
    final boolean customOrder = preorderedList == null
        &amp;&amp; isChildrenDrawingOrderEnabled();
    for (int i = 0; i &lt; childrenCount; i++) {
        while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) {
            final View transientChild = mTransientViews.get(transientIndex);
            if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                transientChild.getAnimation() != null) {
                more |= drawChild(canvas, transientChild, drawingTime);
            }
            transientIndex++;
            if (transientIndex &gt;= transientCount) {
                transientIndex = -1;
            }
        }
 
        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
        if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    while (transientIndex &gt;= 0) {
        // there may be additional transient views after the normal views
        final View transientChild = mTransientViews.get(transientIndex);
        if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
            transientChild.getAnimation() != null) {
            more |= drawChild(canvas, transientChild, drawingTime);
        }
        transientIndex++;
        if (transientIndex &gt;= transientCount) {
            break;
        }
    }
    if (preorderedList != null) preorderedList.clear();
 
    // Draw any disappearing views that have animations
    if (mDisappearingChildren != null) {
        final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size() - 1;
        // Go backwards -- we may delete as animations finish
        for (int i = disappearingCount; i &gt;= 0; i--) {
            final View child = disappearingChildren.get(i);
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (usingRenderNodeProperties) canvas.insertInorderBarrier();
 
    if (isShowingLayoutBounds()) {
        onDebugDraw(canvas);
    }
 
    if (clipToPadding) {
        canvas.restoreToCount(clipSaveCount);
    }
 
    // mGroupFlags might have been updated by drawChild()
    flags = mGroupFlags;
 
    if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
        invalidate(true);
    }
 
    if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp;
        mLayoutAnimationController.isDone() &amp;&amp; !more) {
        // We want to erase the drawing cache and notify the listener after the
        // next frame is drawn because one extra invalidate() is caused by
        // drawChild() after the animation is over
        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
        final Runnable end = new Runnable() {
            @Override
            public void run() {
                notifyAnimationListener();
            }
        };
        post(end);
    }
}
</code></pre>
<p><code>dispatchDraw()</code>里面主要遍历了所以子View，每个子View都调用了<code>drawChild()</code>。</p>
<h3 id="drawchild">drawChild()</h3>
<pre><code class="language-java">protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
    return child.draw(canvas, this, drawingTime);
}
</code></pre>
<p><code>drawChild</code>中，子view各自调用了<code>draw</code>方法。</p>
<p>其实<code>dispatchDraw</code>同理于我门之前的测量和布局，父亲取得所有子控件开始遍历，调用子控件让子控件自己调用自己的draw开始绘制自己。</p>

                    </div>
                    <div class="essaySuffix-box">
                        <div class="essaySuffix-box-left"><img
                                src="/images/avatar.png" alt="">
                        </div>
                        <div class="essaySuffix-box-right"><span
                                class="essaySuffix-right-title">本文作者</span>：<strong><span style="font-size: 12px;"><a
                                        href="/about"
                                        target="_blank">Xiaowu</a></span></strong> <br><span
                                style="font-weight: bold; white-space:nowrap;">本文链接</span>：<a
                                href="https://jxiaow.gitee.io/posts/94ccb851/"
                                target="_blank">https://jxiaow.gitee.io/posts/94ccb851/</a><br><span
                                class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a
                                href="https://creativecommons.org/licenses/by-nc-nd/4.0/" alt="BY-NC-SA"
                                title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</div>
                        <div style="clear: both;"></div>
                    </div>
                </div>
                <!-- </div> -->
                <div class="toc-container">
                    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B">绘制流程</a>
<ul>
<li><a href="#viewrootimplperformtraversals">ViewRootImpl#performTraversals()</a></li>
<li><a href="#performdraw">performDraw()</a></li>
<li><a href="#draw">draw()</a></li>
<li><a href="#drawsoftware">drawSoftware()</a></li>
<li><a href="#viewdraw">View#draw()</a></li>
<li><a href="#drawbackground">drawBackground()</a></li>
<li><a href="#ondraw">onDraw()</a></li>
<li><a href="#dispatchdraw">dispatchDraw()</a></li>
<li><a href="#drawchild">drawChild()</a></li>
</ul>
</li>
</ul>
</li>
</ul>

                </div>
            </article>
            <!-- </div> -->

          

            

            

            
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'CAmH4sFTLPMg3inDkFSqWsuL-gzGzoHsz',
		appKey: '3Mh9SPxWQ7QbJjxmX7EU26z4',
		avatar: 'mp',
		pageSize: 5,
		recordIp: true,
		placeholder: '快来吐槽吧~',
		visitor: true,
	});
</script>

            

            <div class="site-footer gt-c-content-color-first">

  <div class="social-container">

    <a href="https://github.com/jxiaow" target="_blank" title="https://github.com/jxiaow">
      <i class="fab fa-github gt-c-content-color-first"></i>
    </a>

    <a href="https://www.cnblogs.com/xiaowj" target="_blank" title="https://www.cnblogs.com/xiaowj">
      <i class="fas fa-blog gt-c-content-color-first"></i>
    </a>

    <a href="https://blog.csdn.net/xiaowu_zhu" target="_blank" title="https://blog.csdn.net/xiaowu_zhu">
      <i class="fab fa-cuttlefish gt-c-content-color-first"></i>
    </a>

    <a href="mailto:jxiaow@126.com" title="jxiaow@126.com">
      <i class="fas fa-envelope gt-c-content-color-first"></i>
    </a>

  </div>
  <div class="slogan gt-c-content-color-first">心若没有栖息的地方，到哪里都是在流浪</div>
  
  <div>
    <div>
      Theme by <a href="https://github.com/jxiaow/gridea-theme-pure-fashion" target="_blank">jxiaow</a>, Powered by <a
              href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://jxiaow.gitee.io/atom.xml" target="_blank">RSS</a></a>
  </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

            <script>
  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");
  
  if (mainNavLinks == null || mainNavLinks.length == 0) {
    let tocContainer = document.querySelector(".toc-container");
    tocContainer.classList.remove("toc-container")
    // tocContainer.parentElement.firstElementChild.style.width = "100%"
    console.log("隐藏大纲")
  } else {

    // This should probably be throttled.
    // Especially because it triggers during smooth scrolling.
    // https://lodash.com/docs/4.17.10#throttle
    // You could do like...
    // window.addEventListener("scroll", () => {
    //    _.throttle(doThatStuff, 100);
    // });
    // Only not doing it here to keep this Pen dependency-free.


    window.addEventListener("scroll", event => {
      let fromTop = window.scrollY;

      mainNavLinks.forEach((link, index) => {
        let section = document.getElementById(decodeURI(link.hash).substring(1));
        let nextSection = null
        if (mainNavLinks[index + 1]) {
          nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
        }
        if (section.offsetTop <= fromTop) {
          if (nextSection) {
            if (nextSection.offsetTop > fromTop) {
              link.classList.add("current");
            } else {
              link.classList.remove("current");
            }
          } else {
            link.classList.add("current");
          }
        } else {
          link.classList.remove("current");
        }
      });
    });
  }



</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll("figure > img");
  //   debugger
  //   console.log("dddd: "+ images);
  images.forEach(image => {
    var parent = image.parentElement;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'gallery';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.appendChild(aelem);
  })

//   <a data-fancybox="gallery" href="big_1.jpg"><img src="small_1.jpg"></a>
// <a data-fancybox="gallery" href="big_2.jpg"><img src="small_2.jpg"></a>
</script>
        </div>
    </div>

</body>

</html>