{"posts":[{"title":"Dagger2在Android中的使用","content":"Dagger 2 完全解析（一）,基本使用与原理 Dagger 2 完全解析（二）, 进阶使用 Dagger 2 完全解析（三）, Component 与 SubComponent Dagger 2 完全解析（四）,在Android中的使用 本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本 在Android项目中使用Dagger2时，像 Activity和Fragment这种类型的初始化操作都是有Android系统提供的，如果要往其注入对象，不免会有这样的写法： class MainActivity : AppCompatActivity() { @Inject lateinit var activity: MainActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) DaggerMainActivityComponent.builder() .mainActivityModule(MainActivityModule(this)) .appComponent( (application as MyApplication) .daggerAppComponent ).build() .inject(this) } } 上述写法，会有以下几个我们几乎无法避免的问题： 上述Dagger部分的代码存在模板代码，在每个Activity中都会这么写到，即便抽取到BaseActivity中，也有一些特殊部分需要在每个Activity中单独处理，随着业务的增加后期维护不易； 从上面的代码可以看出，MainActivityModule中持有了MainActivity实例，并且需要在MainActivity传入参数，它打破了依赖注入的核心原则：类不应该知道它是如何注入的。 因此为了解决上面的问题，谷歌官方推出了dagger.android。 下面是基本的使用方式，包括如何注入Activity和Fragment,本篇只讲如何使用，后续再分析其原理。 引入Dagger.android依赖 在build.gradle中添加： implementation 'com.google.dagger:dagger-android:2.23.2' implementation 'com.google.dagger:dagger-android-support:2.23.2' kapt 'com.google.dagger:dagger-android-processor:2.23.2' 注入Activity 以MainActivity为例 Dagger2中的写法 class MainActivity : AppCompatActivity() { // 这里只是做了一个例子 @Inject lateinit var activity: MainActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) DaggerMainActivityComponent.builder() .mainActivityModule(MainActivityModule(this)) .appComponent( (application as MyApplication) .daggerAppComponent ).build() .inject(this) } } @ActivityScope @Component(modules = [MainActivityModule::class], dependencies = [AppComponent::class]) interface MainActivityComponent { fun inject(activity: MainActivity) } @Module class MainActivityModule(private val activity: MainActivity) { @Provides fun provideMainActivity(): MainActivity = activity } @Scope annotation class ActivityScope Dagger2-Android中的写法 修改MainActivityComponent @ActivityScope @Subcomponent interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt; { // 声明MainActivity创建的工厂接口 @dagger.Subcomponent.Factory interface Factory : AndroidInjector.Factory&lt;MainActivity&gt; } 修改MainActivityModule @Module(subcomponents = [MainActivityComponent::class]) abstract class MainActivityModule { // module中提供绑定工厂方法 @Binds @IntoMap @ClassKey(MainActivity::class) abstract fun bind( factory: MainActivityComponent.Factory ): AndroidInjector.Factory&lt;*&gt; } 修改onCreate()中的Dagger注入 override fun onCreate(savedInstanceState: Bundle?) { // 在super.onCreate前添加 AndroidInjection.inject(this) super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } 修改MyApplication 通过dagger.android注入时，Application中也发生了相应的变化 class MyApplication : Application(), HasAndroidInjector { @Inject lateinit var dispatchingAndroidInjector: DqispatchingAndroidInjector&lt;Any&gt; override fun onCreate() { super.onCreate() DaggerAppComponent.factory().create(this).inject(this) } override fun androidInjector(): AndroidInjector&lt;Any&gt; { return dispatchingAndroidInjector } } @dagger.Component( modules = [AndroidInjectionModule::class,// 引入框架提供的InjectionModule AndroidSupportInjectionModule::class,// 如果使用了support相关的类，也需要引入 MainActivityModule::class // 这是我们自定义的Module ] ) interface AppComponent : AndroidInjector&lt;MyApplication&gt; { @dagger.Component.Factory interface Factory : AndroidInjector.Factory&lt;MyApplication&gt; } 我们需要将我们在MainActivity中的MainActivityModule加入到Application中的AppComponent的module,然后Make Project或Make App或build project，如果未报错即成功。 简洁写法 如果相应的ActivityComponent中只有以下操作时： @ActivityScope @Subcomponent interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt; { // 声明MainActivity创建的工厂接口 @dagger.Subcomponent.Factory interface Factory : AndroidInjector.Factory&lt;MainActivity&gt; } 我们可以新建一个module类， 将满足以上条件的Component 集中到一起，并删除对应的Component，如： @Module abstract class ActivityBindingModule { @ActivityScoped @ContributesAndroidInjector(modules = [MainActivityModule.class]) abstract fun mainActivity() : MainActivity @ActivityScoped @ContributesAndroidInjector(modules = [AddEditTaskModule.class]) abstract fun addEditTaskActivity(): AddEditTaskActivity } 删除 原有module中的bind*方法 @Module public class MainActivityModule{ } 注入Fragment 注入Fragment与注入Activity类似，唯一不同的地方在于我们需要在onAttach方法中执行AndroidSupportInject.inject(this) class BlankFragment : Fragment() { override fun onAttach(context: Context?) { AndroidSupportInjection.inject(this) super.onAttach(context) } } @dagger.Module abstract class FragmentBindModule { @ContributesAndroidInjector abstract fun blankFragment(): BlankFragment } @dagger.Component( modules = [AndroidInjectionModule::class, AndroidSupportInjectionModule::class, ActivityBinder::class, FragmentBindModule::class ] ) interface AppComponent : AndroidInjector&lt;MyApplication&gt; { @dagger.Component.Factory interface Factory : AndroidInjector.Factory&lt;MyApplication&gt; } 对于FragmentBindModule不仅可以放入到AppComponent中，也可以放入到MainActivityComponent,或者FragmentComponent如： @dagger.Subcomponent(modules = [FragmentBindModule::class]) interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt;{ @dagger.Subcomponent.Factory interface Factory: AndroidInjector.Factory&lt;MainActivity&gt; } @dagger.Module(subcomponents = [ MainActivityComponent::class // 将fragment放入到了activity对应的Component ]) abstract class MainActivityModule{ @Binds @IntoMap @ClassKey(MainActivity::class) abstract fun bind(factory:MainActivityComponent.Factory):AndroidInjector.Factory&lt;*&gt; } 一些问题 @Model 注解的是抽象类时 @provides 标注的必须是静态方法 A @Module may not contain both non-static @Provides methods and abstract @Binds or @Multibinds declarations 这个错误提示是将Module定义成了抽象类，这在java中只需要将@Provide标注的方法设置为静态方法即可，但是在Kotlin中是行不通的，因为在kotlin中静态方法是写在companion object代码块内，所以解决方法有两种： 用Module标注companion object @dagger.Module abstract class MainActivityModule() { @dagger.Module companion object { @JvmStatic @Provides fun provideFragment() = BlankFragment() } @Binds abstract fun context(activity: MainActivity): Context } 使用多个Module将抽象方法和@provide标注的方法分开，如： @Module abstract class MainActivityBindsModule { @Binds abstract fun context(activity: MainActivity): Context } @Module(includes = arrayOf(MainActivityBindsModule ::class)) class MainActivityProvidesModule { @Provides fun provideFragment() = BlankFragment() } 总结 通过前面的例子我们亦可以看出： Dagger2-android 使用的是Dagger2中的继承关系； 使用它，我们就可以不用写那么多的模版代码，相对于Dagger2方便了许多； Dagger2-Android 比Dagger2更强大，我们使用@Binds绑定抽象方法来注入一些提供初始化的类等。 ","link":"https://www.xiaowujiang.cn/posts/e781e647/"},{"title":"Dagger 2 Component 与 SubComponent","content":"Dagger 2 完全解析（一）,基本使用与原理 Dagger 2 完全解析（二）, 进阶使用 Dagger 2 完全解析（三）, Component 与 SubComponent Dagger 2 完全解析（四）,在Android中的使用 本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本 理解前面两篇文章后，可以使用 Dagger 2框架完成一个对象的依赖注入。但是在实战中会存在多个需要注入依赖的对象，也就是说会有多个 Component，它们之间会有相同的依赖，那么该如何处理它们之间的关系呢？ 我们先来看一个简单的例子： 假如有三个类：A、B和C, A和B都各自持有C的实例，并且通过Dagger2进行注入 class A { @Inject lateinit var c: C } class B { @Inject lateinit var c: C } class C @Inject constructor() Component: @Component interface AComponent { fun injectA(a: A) } @Component interface BComponent { fun injectA(b: B) } 如果要让A、B持有的实例C相同的话，我们该如何处理？ 很多人第一时间会想到下面这种设计： @Singleton @Component(modules = [CModule::class]) interface AComponent { fun injectA(a: A) } @Singleton @Component(modules = [CModule::class]) interface BComponent { fun injectA(b: B) } @Module class CModule { companion object { private var c: C? = null } @Singleton @Provides fun provideC(): C { if (c == null) { c = C() } return c!! } } 把 Component 需要的依赖都在modules属性中声明，但是这样有两个问题： （1）有时依赖实例需要共享，例如上面场景中，A和C都持有C的实例，并且根据Module里的实现，会存在谁先创建C实例的问题。 （2）Scope 作用域容易失效，例如 CModule 的provideCar()使用 @Singleton 作用域，AComponent和BComponent也要用 Singleton 标注，但它们都会持有一个C实例。 假如A先创建了C那么，BComponent需要依赖 AComponent提供的 C实例，这就是 Component 组织关系中的一种。 Component 的组织关系 Component 管理着依赖实例，根据依赖实例之间的关系就能确定 Component 的关系。这些关系可以用object graph描述，我称之为依赖关系图。在 Dagger 2 中 Component 的组织关系分为两种： 依赖关系，一个 Component 依赖其他 Compoent公开的依赖实例，用 Component 中的dependencies声明。 继承关系，一个 Component 继承（也可以叫扩展）某 Component 提供更多的依赖，SubComponent 就是继承关系的体现。 所以前文中AComponent和BComponent是依赖关系。 依赖关系 具体的实现代码： @Component(modules = [CModule::class]) interface AComponent { fun injectA(a: A) fun c(): C } @Component(dependencies = [AComponent::class]) interface BComponent { fun injectA(b: B) } @Module class CModule { @Provides fun provideC(): C = C() } 注：因为 BComponent和 AComponent是依赖关系，如果AComponent声明了作用域的话，那么BComponent也必须声明（反之可以），而且它们的 Scope 不能相同，并且两个都有作用域的情况下 @Singleton 修饰的 Component （BComponent）不能依赖其他的 Component。 public final class DaggerBComponent implements BComponent { private final AComponent aComponent; private DaggerBComponent(AComponent aComponentParam) { this.aComponent = aComponentParam; } .... @Override public void injectA(B b) { injectB(b);} private B injectB(B instance) { // 注入时，使用了aComponent.c() B_MembersInjector.injectC(instance, Preconditions.checkNotNull(aComponent.c(), &quot;Cannot return null from a non-@Nullable component method&quot;)); return instance; } ... } 编译时生成的代码 DaggerBComponent 中会调用aComponent.c()，如果 AComponent 没有向外提供C 实例的接口的话，DaggerBComponent 就会注入失败。 依赖注入： val aComponent = DaggerAComponent.builder().build() DaggerBComponent.builder().aComponent(aComponent).build().inject(b) 依赖关系就跟生活中的朋友关系相当，注意事项如下： 被依赖的 Component 需要把暴露的依赖实例用显式的接口声明。 依赖关系中的 Component 的 Scope 不能相同，因为它们的生命周期不同。 继承关系 继承关系跟面向对象中的继承的概念有点像，SubComponent称为子 Component，类似于平常说的子类。下面先看看下面这个场景： class Parent { @Inject lateinit var car: Car } class Child { @Inject lateinit var car: Car @Inject lateinit var bike: Bike } class Car @Inject constructor() class Bike @Inject constructor() Child 可以开Parent的车 car，也可以骑自己的自行车 bike。依赖关系图： 上图中 ChildComponent 在 ParentComponent之中，ChildComponent子承父业，可以访问 ParentComponent 的依赖，而 ParentComponent只知道 ChildComponent 是它的子类，可以访问 SubComponent.Builder，却无法访问 SubComponent 中的依赖。 @Component(modules = [CarModule::class]) interface ParentComponent { fun inject(parent: Parent) } @Subcomponent(modules = [BikeModule::class]) interface ChildComponent { fun inject(child: Child) // SubComponent 必须显式地声明 Subcomponent.Builder，parentComponent 需要用 Builder 来创建 ChildComponent @Subcomponent.Builder interface Builder { fun build(): ChildComponent } } @SubComponent的写法与@Component一样，只能标注接口或抽象类，与依赖关系一样，SubComponent 与 parent Component 的 Scope 不能相同，只是 SubComponent 表明它是继承扩展某 Component 的。怎么表明一个 SubComponent 是属于哪个 parent Component 的呢？只需要在 parent Component 依赖的 Module 中的subcomponents加上 SubComponent 的 class，然后就可以在 parent Component 中请求 SubComponent.Builder。 @Component(modules = [CarModule::class]) interface ParentComponent { ... // 用来创建childComponent fun childComponent(): ChildComponent.Builder } @Subcomponent(modules = [BikeModule::class]) interface ChildComponent { ... // SubComponent 必须显式地声明 Subcomponent.Builder，parentComponent 需要用 Builder 来创建 ChildComponent @Subcomponent.Builder interface Builder { fun build(): ChildComponent } } // 在CarModule上添加subComponents @Module(subcomponents = [ChildComponent::class]) class CarModule { @Provides fun provideCar() = Car() } @Module class BikeModule { @Provides fun provideBike() = Bike() } 上面的代码经过make project后，dagger2生成的代码： public final class DaggerParentComponent implements ParentComponent { ... @Override public ChildComponent.Builder childComponent() { return new ChildComponentBuilder();} ... private final class ChildComponentBuilder implements ChildComponent.Builder { @Override public ChildComponent build() { return new ChildComponentImpl(new BikeModule()); } } private final class ChildComponentImpl implements ChildComponent { private final BikeModule bikeModule; private ChildComponentImpl(BikeModule bikeModuleParam) { this.bikeModule = bikeModuleParam; } ... private Child injectChild(Child instance) { // 注入car时，调用的parentComponent的carModule提供 Child_MembersInjector.injectCar(instance, CarModule_ProvideCarFactory.provideCar(DaggerParentComponent.this.carModule)); Child_MembersInjector.injectBike(instance, BikeModule_ProvideBikeFactory.provideBike(bikeModule)); return instance; } } } SubComponent 编译时不会生成 DaggerChildComponent，需要通过 parentComponent 的获取 SubComponent.Builder 方法获取 ChildComponent 实例。 val parentComponent = DaggerParentComponent.builder().build() parentComponent.childComponent().build().inject(child) 继承关系和依赖关系最大的区别就是：继承关系中不用显式地提供依赖实例的接口，SubComponent 继承 parent Component 的所有依赖。 依赖关系 vs 继承关系 相同点： 两者都能复用其他 Component 的依赖 有依赖关系和继承关系的 Component 不能有相同的 Scope 区别： 依赖关系中被依赖的 Component 必须显式地提供公开依赖实例的接口，而 SubComponent 默认继承 parent Component 的依赖。 依赖关系会生成两个独立的 DaggerXXComponent 类，而 SubComponent 不会生成 独立的 DaggerXXComponent 类。 在 Android 开发中，Activity 是 App 运行中组件，Fragment 又是 Activity 一部分，这种组件化思想适合继承关系，所以在 Android 中一般使用 SubComponent。 SubComponent 的其他问题 抽象工厂方法定义继承关系 除了使用 Module 的subcomponents属性定义继承关系，还可以在 parent Component 中声明返回 SubComponent 的抽象工厂方法来定义： @Component(modules = [CarModule::class]) interface ParentComponent { ... // 用来创建childComponent //// 这个抽象工厂方法表明 ChildComponent 继承 ParentComponent fun childComponent(): ChildComponent } @Subcomponent(modules = [BikeModule::class]) interface ChildComponent { ... } @Module class CarModule { @Provides fun provideCar() = Car() } @Module class BikeModule { @Provides fun provideBike() = Bike() } 这种定义方式不能很明显地表明继承关系，一般推荐使用 Module 的subcomponents属性定义。 重复的 Module 当相同的 Module 注入到 parent Component 和它的 SubComponent 中时，则每个 Component 都将自动使用这个 Module 的同一实例。也就是如果在 SubComponent.Builder 中调用相同的 Module 或者在返回 SubComponent 的抽象工厂方法中以重复 Module 作为参数时，会出现错误。（前者在编译时不能检测出，是运行时错误） @Component(modules = {RepeatedModule.class, ...}) interface ComponentOne { ComponentTwo componentTwo(RepeatedModule repeatedModule); // 编译时报错 ComponentThree.Builder componentThreeBuilder(); } @Subcomponent(modules = {RepeatedModule.class, ...}) interface ComponentTwo { ... } @Subcomponent(modules = {RepeatedModule.class, ...}) interface ComponentThree { @Subcomponent.Builder interface Builder { Builder repeatedModule(RepeatedModule repeatedModule); ComponentThree build(); } } DaggerComponentOne.create().componentThreeBuilder() .repeatedModule(new RepeatedModule()) // 运行时报错 UnsupportedOperationException! .build(); 总结 Component 之间共用相同依赖，可以有两种组织关系：依赖关系与继承关系。至于如何选择试具体情况而定，但在 Android 开发中，一般使用继承关系，以 AppComponent 作为 root Component，AppComponent 一般还会使用 @Singleton 作用域，而 ActivityComponent 为 SubComponent。 ","link":"https://www.xiaowujiang.cn/posts/e30bee8a/"},{"title":"Dagger 2 进阶使用","content":"Dagger 2 完全解析（一）,基本使用与原理 Dagger 2 完全解析（二）, 进阶使用 Dagger 2 完全解析（三）, Component 与 SubComponent Dagger 2 完全解析（四）,在Android中的使用 本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本 在Dagger 2 完全解析（一）,基本使用与原理中介绍了 Dagger 2 基本使用，但是在实战中基本使用是远远不够的，我们还需要掌握一些其它的知识，下面由简入繁地讲解这几个概念，同时结合 Dagger 2 的编译时生成代码分析背后的原理（示例代码沿用第一篇的）。 下面开始对Lazy、Provider、Qualifier和 Scope进行分析。 Lazy （延迟注入） 有时我们想注入的依赖在使用时再完成初始化，提高加载速度，就可以使用注入Lazy&lt;T&gt;。只有在调用Lazy的 get() 方法时才会初始化依赖实例注入依赖。 public interface Lazy&lt;T&gt; { T get(); } 在A中使用： class A { ... @Inject lateinit var lazyD: Lazy&lt;D&gt; fun doWork(){ lazyD.get() // 返回D的实例 } } Make app后，在DaggerAComponent中： public final class DaggerAComponent implements AComponent { private final AModule aModule; ... @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); A_MembersInjector.injectC(instance, new C()); // DoubleCheck 是线程安全的Lazy实例初始化类 A_MembersInjector.injectLazyD(instance, DoubleCheck.lazy(D_Factory.create())); return instance; } ... DoubleCheck 是线程安全的Lazy实例初始化工具类 public static &lt;P extends Provider&lt;T&gt;, T&gt; Lazy&lt;T&gt; lazy(P provider) { if (provider instanceof Lazy) { @SuppressWarnings(&quot;unchecked&quot;) final Lazy&lt;T&gt; lazy = (Lazy&lt;T&gt;) provider; return lazy; } return new DoubleCheck&lt;T&gt;(checkNotNull(provider)); } // 在需要使用的时候调用此方法进行返回相应的实例 @Override public T get() { Object result = instance; if (result == UNINITIALIZED) { synchronized (this) { result = instance; if (result == UNINITIALIZED) { result = provider.get(); instance = reentrantCheck(instance, result); provider = null; } } } return (T) result; } Provider 注入 有时候不仅仅是注入单个实例，我们需要多个实例，这时可以使用注入Provider&lt;T&gt;，每次调用它的 get() 方法都会调用到 @Inject 构造函数创建新实例或者Module 的 provide 方法返回实例。 class A { @Inject lateinit var providerD: Provider&lt;D&gt; fun createDFactory(): MutableList&lt;D&gt; { val ds = mutableListOf&lt;D&gt;() for (i in 0..10) { ds.add(providerD.get()) } return ds } } Make app后，在DaggerAComponent中： public final class DaggerAComponent implements AComponent { private final AModule aModule; ... @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); A_MembersInjector.injectC(instance, new C()); A_MembersInjector.injectLazyD(instance, DoubleCheck.lazy(D_Factory.create())); // 注入provider ,将`Factory`传入 A_MembersInjector.injectProviderD(instance, D_Factory.create()); return instance; } ... 再来看看D_Factory： public final class D_Factory implements Factory&lt;D&gt; { private static final D_Factory INSTANCE = new D_Factory(); // 每次调用get方法都会重新创建实例 @Override public D get() { return new D(); } public static D_Factory create() { return INSTANCE; } public static D newInstance() { return new D(); } } 通过上面可以看到，每次调用get方法都会重新创建实例, D_Factory实现了Factory&lt;D&gt;而Factory&lt;D&gt;继承自Provider&lt;D&gt;。 public final class D_Factory implements Factory&lt;D&gt; {} public interface Factory&lt;T&gt; extends Provider&lt;T&gt; {} Qualifier（限定符） 试想这样一种情况：在 AModule提供了两个生成B 实例的provide 方法，如果使用 Dagger 2 在 A 中注入B实例时应该选择哪一个方法呢？ @Module class AModule { @Provides fun provideB(): B = B() @Provides fun provideOther(): B = B() } 这时 Dagger 2 不知道使用provideB还是provideOther提供的实例，在编译时就会出现： [Dagger/DuplicateBindings] *.data.B is bound multiple times: 而@Qualifier注解就是用来解决这个问题，使用注解来确定使用哪种 provide 方法。 @Target(ANNOTATION_TYPE) @Retention(RUNTIME) @Documented public @interface Qualifier {} 我们可以发现@Qualifier是用来修饰注解的，所以它是不能直接作用到provide方法上。 下面是自定义的@Named注解，你也可以用自定义的其他 Qualifier 注解： @Qualifier @Documented @Retention(RUNTIME) public @interface Named { String value() default &quot;&quot;; } 在 provide 方法上加上@Named注解，用来区分 @Module class AModule { @Named(&quot;b&quot;) @Provides fun provideB(): B = B() @Named(&quot;other&quot;) @Provides fun provideOther(): B = B() } 还需要在Inject 注入的地方加上@field:Named注解: class A { @Inject @field:Named(&quot;other&quot;) lateinit var b: B ... } **tips: ** 在kotlin中使用@Name给属性注入时需要添加@field，不然注解不生效。 这样在依赖注入时，Dagger 2 就会使用provideB方法提供的实例，所以Qualifier（限定符）的作用相当于起了个区分的别名。 public final class DaggerAComponent implements AComponent { private final AModule aModule; ... @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { // 使用的是 provide方法 A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); ... return instance; } ... } 当然啦，我们也可以自定义注解进行区分，比如： @Qualifier @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD) annotation class Other 然后在provideOther和lateinit var b: B上加上@Other即可。 Scope（作用域） Scope 是用来确定注入的实例的生命周期的，如果没有使用 Scope 注解，Component 每次调用 Module 中的 provide 方法或 Inject 构造函数生成的工厂时都会创建一个新的实例，而使用 Scope 后可以复用之前的依赖实例。下面先介绍 Scope 的基本概念与原理，再分析 Singleton、Reusable 等作用域。 Scope 基本概念 先介绍 Scope 的用法，@Scope是元注解，是用来标注自定义注解的，如下： @Target(ANNOTATION_TYPE) @Retention(RUNTIME) @Documented public @interface Scope {} **Scope 注解只能标注目标类、@provide 方法和 Component。**Scope 注解要生效的话，需要同时标注在 Component 和提供依赖实例的Module 或目标类上。Module 中 provide 方法中的 Scope 注解必须和 与之绑定的 Component 的 Scope 注解一样，否则作用域不同会导致编译时会报错。 那么 Scope 注解又是如何产生作用的呢，怎么保证生成的依赖实例的生命周期呢？ 在 Dagger 2 官方文档中我找到一句话，非常清楚地描述了@Scope的原理： When a binding uses a scope annotation, that means that the component object holds a reference to the bound object until the component object itself is garbage-collected. 当 Component 与 Module、目标类（需要被注入依赖）使用 Scope 注解绑定时，意味着 Component 对象持有绑定的依赖实例的一个引用直到 Component 对象本身被回收。也就是作用域的原理，其实是让生成的依赖实例的生命周期与 Component 绑定，Scope 注解并不能保证生命周期，要想保证赖实例的生命周期，需要确保 Component 的生命周期。 下面以@AScope为例，看 Scope 注解背后的代码： 先定义AScope @Scope @Retention(RUNTIME) @Target(FIELD, FUNCTION, CLASS) annotation class AScope 使用Module方式 在AModule中： @Module class AModule { @AScope @Provides fun provideB(): B = B() } 在AComponent中 @Component(modules = [AModule::class]) @AScope interface AComponent { fun injectA(a: A) } 这样生成的 B实例就与 AComponent 绑定了。下面看编译时生成的代码： public final class DaggerAComponent implements AComponent { private Provider&lt;B&gt; provideBProvider; private DaggerAComponent(AModule aModuleParam) { initialize(aModuleParam); } ... @SuppressWarnings(&quot;unchecked&quot;) private void initialize(final AModule aModuleParam) { this.provideOtherProvider = DoubleCheck.provider(AModule_ProvideBFactory.create(aModuleParam)); } @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { // provideOtherProvider 不再由Factory创建，而是DobuleCheck A_MembersInjector.injectB(instance, provideBProvider.get()); return instance; } ... } 从上面 DaggerAComponent的代码可以看出使用了 AScope 作用域后，provideBProvider由AModule_ProvideCarFactory.create()变为了DoubleCheck.provider(AModule_ProvideBFactory.create())。而 DoubleCheck 包装的意义在于持有了 B的实例，而且只会生成一次实例，也就是说：没有用 MyScope 作用域之前，DaggerAComponent 每次注入依赖都会新建一个 B实例，而用 AScope 作用之后，每次注入依赖都只会返回第一次生成的实例。通过生成的代码可以发现这和Lazy的方式很相似。 注解到目标类方式 class A { @AScope @Inject lateinit var b: B } @AScope class B @Inject constructor() @AScope @Component(modules = [AModule::class]) interface AComponent { fun injectA(a: A) } @Module class AModule { } 使用这种方式生成的代码： public final class DaggerAComponent implements AComponent { private Provider&lt;B&gt; bProvider; private DaggerAComponent() { initialize(); } ... @SuppressWarnings(&quot;unchecked&quot;) private void initialize() { // 此处使用的是Factory,不是AModule_ProvideBFactory this.bProvider = DoubleCheck.provider(B_Factory.create()); } @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { A_MembersInjector.injectB(instance, bProvider.get()); return instance; } ... } Scope 作用域的本质：Component 间接持有依赖实例的引用，把实例的作用域与 Component 绑定 Singleton 在了解作用域的原理后，再来理解 Dagger 2 提供的自带作用域就容易了。@Singleton顾名思义保证单例，那么它又是如何实现的呢，实现了单例模式那样只返回一个实例吗？ 把上面例子中@AScope换成@Singleton，发现生成的 DaggerAComponent 和其他类没有变化。也只是用DoubleCheck包装了工厂而已，并没有什么特殊实现。所以 Singleton 作用域可以保证一个 Component 中的单例，但是如果产生多个 Component 实例，那么实例的单例就无法保证了。 所以在网上一些例子中，有看到AppComponent使用 Singleton 作用域，保证绑定的依赖实例的单例。它生效的原因是AppComponent只会在 Application 中创建一次，由AppComponent的单例来保证绑定的依赖实例的单例。 **注意：Component 可以同时被多个 Scope 标记。**即 Component 可以和多个 Scope 的 Moudle 或目标类绑定。 Reusable 上文中的自定义的@AScope和@Singleton都可以使得绑定的 Component 缓存依赖的实例，但是与之绑定 Component 必须有相同的 Scope 标记。假如我只想单纯缓存依赖的实例，可以复用之前的实例，不想关心与之绑定是什么 Component，应该怎么办呢？。 这时就可以使用@Reusable作用域，**Reusable 作用域不关心绑定的 Component，Reusable 作用域只需要标记目标类或 provide 方法，不用标记 Component。**下面先看看使用 Reusable 作用域后，生成的 DaggerAComponent 的变化： public final class DaggerAComponent implements AComponent { private Provider&lt;B&gt; provideBProvider; private DaggerAComponent(AModule aModuleParam) { initialize(aModuleParam); } @SuppressWarnings(&quot;unchecked&quot;) private void initialize(final AModule aModuleParam) { this.provideBProvider = SingleCheck.provider(AModule_ProvideBFactory.create(aModuleParam)); } @Override public void injectA(A a) { injectA2(a); } private A injectA2(A instance) { A_MembersInjector.injectB(instance, provideBProvider.get()); return instance; } ... } 从上面代码可以看出使用@Reusable作用域后，利用到 Reusable 实例的 Component 会间接持有实例的引用。但是这里是用SingleCheck而不是DoubleCheck，在多线程情况下可能会生成多个实例。因为@Reusable作用域目的只是可以复用之前的实例，并不需要严格地保证实例的唯一，所以使用 SingleCheck 就足够了。 Releasable references（可释放引用） 相关内容在新版Dagger2已经废除。 Binding Instances 通过前面作用域的讲解，可以清楚 Component 可以间接持有 Module 或 Inject 目标类构造函数提供的依赖实例，除了这两种方式，Component 还可以在创建 Component 的时候绑定依赖实例，用以注入。这就是@BindsInstance注解的作用，只能在 Component.Builder 中使用。 在 Android 中使用 Dagger 2 时，activity 实例经常也需要作为依赖实例用以注入，在之前只能使用 Module： @Module class MainActivityModule { private val mainActivity: MainActivity constructor(mainActivity: MainActivity) { this.mainActivity = mainActivity } @Provides fun provideMainActivity(): MainActivity { return this.mainActivity } } 而使用@BindsInstance的话会更加简单： @Component interface MainActivityComponent { fun injectMainActivity(activity: MainActivity) @Component.Builder interface Builder { @BindsInstance fun activity(activity: Activity): Builder fun build(): MainActivityComponent } } 注意在调用build()创建 Component 之前，所有@BindsInstance方法必须先调用。上面例子中 MainActivityComponent还可以注入 Activity 类型的依赖，但是不能注入 MainActivity，因为 Dagger 2 是使用具体类型作为依据的（也就是只能使用@Inject Activity activity而不是@Inject MainActivity activity）。 如果@BindsInstance方法的参数可能为 null，需要再用@Nullable标记，同时标注 Inject 的地方也需要用@Nullable标记。这时 Builder 也可以不调用@BindsInstance方法，这样 Component 会默认设置 instance 为 null。 总结 Lazy 可以延时注入，Provider 可以创建多个实例 Qualifier 限定符用来解决同一个实例不同方法提供冲突的问题，可以依赖实例起个别名用来区分，或者自定义注解 Scope 作用域的本质是 Component 会持有与之绑定的依赖实例的引用，要想确保实例的生命周期，关键在于控制 Component 的生命周期。 推荐优先使用@BindsInstance方法，相对于写一个带有构造函数带有参数的 Module。 ","link":"https://www.xiaowujiang.cn/posts/b74c4b6c/"},{"title":"Dagger 2 的基本使用与原理","content":"Dagger 2 完全解析（一）,基本使用与原理 Dagger 2 完全解析（二）, 进阶使用 Dagger 2 完全解析（三）, Component 与 SubComponent Dagger 2 完全解析（四）,在Android中的使用 本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本 依赖注入 什么是依赖 依赖(Dependency) 是类与类之间的联接。依赖关系表示一个类依赖于另一个类的定义, 一般而言，依赖关系在语言中体现为局部变量、方法的形参，或者对静态方法的调用。 我们在Android开发中 经常会在build.gradle中引入第三方包的依赖包，然后就完成了对第三方的依赖。那么到底什么是依赖呢？下面我举个例子： 假如有两个类 : A和B, A中持有B的实例，则可认为 A依赖B // Class A class A( private val b: B = B()// A中定义了b,并创建了B实例 ) // Class B class B 上面这种写法是最常见的写法，但是在下面几个场景中存在一些问题： 如果要修改 B 的构造函数，例如需要使用b= B(name)的方式构造时，还要修改 A的代码； 不利于单元测试，如单元测试中使用 mock 的 B测试A 。 什么是依赖注入(Dependency Injection) 依赖注入（简称 DI）是用于实现控制反转（ IOC）最常见的方式之一，IOC是面向对象编程中的一种设计思想，用以降低代码之间耦合度。控制反转的基本思想是：借助“第三方”实现具有依赖关系的对象之间的解耦。 就拿上面的例子来说，我们在A中创建并持有B的实例，A依赖B ，并且创建的主动权在A, 实现了 Ioc 后，对象 A 依赖于IOC 容器，对象 A 被动地接受容器提供的对象 B 实例，由主动变为被动，因此称为控制反转。 注意，控制反转不等同于依赖注入，控制反转还有一种实现方式叫“依赖查找”（Denpendency Lookup） 依赖注入就是将对象实例传入到一个对象中去（Denpendency injection means giving an object its instance variables）。依赖注入是一种设计模式，降低了依赖和被依赖对象之间的耦合，方便扩展和单元测试。 依赖注入的实现方式 其实在平常编码的过程中，已经不知觉地使用了依赖注入 基于构造函数，在构造对象时注入所依赖的对象。 class A( private val b: B // 由创建A 是 传入B的实例 ) 基于 set 方法，使用 setter 方法来让外部容器调用传入所依赖的对象。 class A { private lateinit var b: B // 通过外部调用setB()实现实例注入 fun setB(b: B) { this.b = b } } 基于接口，使用接口来提供 setter 方法。 interface BInjector { fun injectB(b: B) } class A : BInjector { private var b: B? = null override fun injectB(b: B) { this.b = b } } 基于注解，Dagger 2 依赖注入框架就是使用@Inject完成注入。 class A { @Inject lateinit var b: B } Dagger 2 Dagger 2 是 Java 和Android下的一个完全静态、编译时生成代码的依赖注入框架，由 Google 维护，早期的版本 Dagger 是由 Square 创建的。 Dagger 2 是基于 Java Specification Request(JSR) 330标准。利用 JSR 注解在编译时生成代码，来注入实例完成依赖注入。 下面是 Dagger 2 的一些资源地址： Github：https://github.com/google/dagger 官方文档：https://google.github.io/dagger// API：http://google.github.io/dagger/api/latest/ Dagger 2 的基本使用 上面介绍了依赖注入和 Dagger 2，下面由简单的示例开始一步一步地解析 Dagger 2 的基本使用与原理。 引入 Dagger 2 在build.gradle中添加依赖和plugin： apply plugin: 'kotlin-kapt' dependencies { implementation 'com.google.dagger:dagger:2.23.2' kapt 'com.google.dagger:dagger-compiler:2.32.2' } 如果 Android gradle plugin 的版本低于2.2，还需要引入 android-apt 插件。 使用 @Inject 标注需要注入的依赖 @Inject package javax.inject; @Target({ METHOD, CONSTRUCTOR, FIELD }) @Retention(RUNTIME) @Documented public @interface Inject {} 继续使用上面 A 的例子： class A { @Inject lateinit var b: B } 使用javax.inject.Inject注解来标注需要 Dagger 2 注入的依赖，make module或者build后可以在build/generated/source/kapt目录下看到 Dagger 2 编译时生成的成员属性注入类。 public final class A_MembersInjector implements MembersInjector&lt;A&gt; { private final Provider&lt;B&gt; bProvider; public A_MembersInjector(Provider&lt;B&gt; bProvider) { this.bProvider = bProvider; } public static MembersInjector&lt;A&gt; create(Provider&lt;B&gt; bProvider) { return new A_MembersInjector(bProvider);} @Override public void injectMembers(A instance) { injectB(instance, bProvider.get()); } public static void injectB(A instance, B b) { instance.b = b; } } 从上面的injectMembers方法中可以看到注入依赖的代码是instance.b= bProvider.get();，所以@Inject标注的成员属性不能是private的，不然无法注入。A中@Inject注解了n不同的类型变量，那么A_MembersInjector就会持有n个Provider。 创建所依赖对象的实例 用@Inject标注构造函数时，Dagger 2 会完成实例的创建。 class B @Inject constructor() build 后可以在build/generated/source/kapt目录下看到 Dagger 2 编译时生成的工厂类。 public final class B_Factory implements Factory&lt;B&gt; { private static final B_Factory INSTANCE = new B_Factory(); @Override public B get() { return new B(); } public static B_Factory create() { return INSTANCE; } public static B newInstance() { return new B(); } } 依赖注入是依赖的对象实例–&gt;需要注入的实例属性，上面完成两步，通过 Dagger 2 生成的代码代码可以知道，生成了 A的成员属性注入类和 B的工厂类，接下来需要的就是新建工厂实例并调用成员属性注入类完成 B的实例注入。完成这个过程的桥梁就是dagger.Component。 Component 桥梁 @Component可以标注接口或抽象类 @Retention(RUNTIME) @Target(TYPE) @Documented public @interface Component { @Target(TYPE) @Documented @interface Builder {} @Target(TYPE) @Documented @interface Factory {} } Component可以完成依赖注入过程，其中最重要的是定义注入接口，调用注入接口就可以完成 A 所需依赖的注入。 @Component interface AComponent { fun injectA(a: A) } build 后会生成带有Dagger前缀的实现该接口的类：DaggerManComponent public final class DaggerAComponent implements AComponent { private DaggerAComponent() { } public static Builder builder() { return new Builder(); } public static AComponent create() { return new Builder().build(); } @Override public void injectA(A a) { injectA2(a); } private A injectA2(A instance) { A_MembersInjector.injectB(instance, new B()); return instance; } public static final class Builder { private Builder() { } public AComponent build() { return new DaggerAComponent(); } } } 从上面生成的代码可以看出来 DaggerAComponent就是连接依赖的对象A实例和需要注入的B实例属性之间的桥梁。DaggerAComponent会查找目标类对应的成员属性注入类（即A_MembersInjector），然后调用A_MembersInjector.injectB(instance, new B())就能完成依赖注入。注意，Component 中注入接口的参数必须为需要注入依赖的类型，不能是 要注入类型的父类或子类，注入接口返回值为 void，接口名可以任意。 接下来只需要在 A中调用injectA方法就能完成注入。 class A { init{ DaggerManComponent.create().injectA(this) } } Module 使用@Inject标注构造函数来提供依赖的对象实例的方法，不是万能的，在以下几种场景中无法使用： 接口没有构造函数 第三方库的类不能被标注 构造函数中的参数必须配置 为了解决上面的问题，Dagger又提供了一种新的注解方式：Module 在Module中，Module 即用@Module标注的类。所以 Module 是提供依赖的对象实例的另一种方式。 @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Module { Class&lt;?&gt;[] includes() default {}; @Beta Class&lt;?&gt;[] subcomponents() default {}; } 在Module可以用@Provides标注的方法来提供依赖实例，方法的返回值就是依赖的对象实例。 @Module class AModule { @Provides fun provideB(): B = B() } 约定俗成的是@Provides方法一般以provide为前缀，Moudle 类以Module为后缀，一个 Module 类中可以有多个@Provides方法。 接下来，关联Module与Component： @Component(modules = [AModule::class]) interface AComponent { fun injectA(a: A) } build之后，Module 和 Component 生成的类为： public final class DaggerAComponent implements AComponent { private final AModule aModule; private DaggerAComponent(AModule aModuleParam) { this.aModule = aModuleParam; } .... private A injectA2(A instance) { A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); return instance; } public static final class Builder { private AModule aModule; private Builder() { } public Builder aModule(AModule aModule) { this.aModule = Preconditions.checkNotNull(aModule); return this; } public AComponent build() { if (aModule == null) { this.aModule = new AModule(); } return new DaggerAComponent(aModule); } } } 生成的 DaggerAComponent 和之前相比主要是injectA2()方法不一样，具体体现在： 没有Module时： A_MembersInjector.injectB(instance, new B()); 有Module时： A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); AModule_ProvideBFactory实现 Factory 接口。 public final class AModule_ProvideBFactory implements Factory&lt;B&gt; { private final AModule module; public AModule_ProvideBFactory(AModule module) { this.module = module; } @Override public B get() { return provideB(module); } public static AModule_ProvideBFactory create(AModule module) { return new AModule_ProvideBFactory(module); } public static B provideB(AModule instance) { return Preconditions.checkNotNull(instance.provideB(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;); } } 总结 现在再来看 Dagger 2 最核心的三个部分： 需要注入依赖的目标类，需要注入的实例属性由@Inject标注。 提供依赖对象实例的工厂，用@Inject标注构造函数或定义Module这两种方式都能提供依赖实例，Dagger 2 的注解处理器会在编译时生成相应的工厂类。Module的优先级比@Inject标注构造函数的高，意味着 Dagger 2 会先从 Module 寻找依赖实例。 把依赖实例工厂创建的实例注入到目标类中的 Component。 下面再讲述上面提到的在 Dagger 2 种几个注解的用法： @Inject 一般情况下是标注成员属性和构造函数，标注的成员属性不能是private，Dagger 2 还支持方法注入，@Inject还可以标注方法。 @Provides 只能标注方法，必须在 Module 中。 @Module 用来标注 Module 类 @Component 只能标注接口或抽象类，声明的注入接口的参数类型必须和目标类一致。 ","link":"https://www.xiaowujiang.cn/posts/cbb172f8/"},{"title":"Android DataBinding 从入门到进阶","content":"DataBinding 是google发布的一个数据绑定框架，用于降低布局和逻辑的耦合性，使代码逻辑更加清晰。大量减少 Activity 内的代码，数据能够单向或双向绑定到 layout 文件中，有助于防止内存泄漏，而且能自动进行空检测以避免空指针异常。 环境配置 详情内容请参考：https://developer.android.com/topic/libraries/data-binding/start 启用 DataBinding 的方法是在对应 Model 的 build.gradle 文件里加入以下代码，同步后就能引入对 DataBinding 的支持 android { ... dataBinding { enabled = true } } 如果Android Studio的版本小于3.2的需要在gradle.properties中添加： android.databinding.enableV2=true tips: 1. 推荐使用最新的Android Studio版本和AndroidX库。 ​ 2.build.gradle中添加'apply plugin : 'kotlin-kapt'。 基础入门 改变布局文件 layout 启用 DataBinding 后，打开原有的布局文件，选中根布局的 根布局，按住 Alt + 回车键，点击 “Convert to data binding layout”，就可以生成 DataBinding 需要的布局规则。 转换后的内容为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; 和原始布局的区别在于多出了一个 layout 标签将原布局包裹了起来； data 标签用于声明要用到的变量以及变量类型，它搭建了 View 和 Model 之间的通道。 创建Model package com.github.ixiaow.databindingsample.model data class User(val name:String, val password: String) Model 与 布局文件关联 在 data 标签里声明要使用到的变量名、类的全路径 &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.github.ixiaow.databindingsample.model.User&quot;/&gt; &lt;/data&gt; 在 相应部分使用User &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;data&gt; ... &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView ... android:text=&quot;@{user.name}&quot;/&gt; &lt;TextView ... android:text=&quot;@{user.password}&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; 给Model赋值 写好布局文件后，在 Android Studio中执行make project或者make app, 完成后，在Activity中: class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val dataBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) // 给user初始化值 dataBinding.user = User(&quot;zhangsan&quot;, &quot;12345&quot;) } } 运行App后就可以看到结果啦。 补充知识 import 我们可以像使用java或者kotlin文件一样，导入需要的类名路径即可，比如说： 如果 User 类型要多处用到，也可以直接将之 import 进来，这样就不用每次都指明整个包名路径了，而 java.lang.* 包中的类会被自动导入，所以可以直接使用： &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.databindingsample.model.User&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot;/&gt; &lt;/data&gt; 导入java或kotlin文件中的系统类，比如 import 集合 list &lt;data&gt; &lt;import type=&quot;java.util.List&quot;/&gt; &lt;import type=&quot;com.github.ixiaow.sample.model.User&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot;/&gt; &lt;variable name=&quot;users&quot; type=&quot;List&lt;User&gt;&quot;/&gt; &lt;/data&gt; ❤️ &lt;需要被替换成&amp;lt; 如果存在 import 的类名相同的情况，可以使用 alias 指定别名 &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.sample.model1.User&quot; /&gt; &lt;import alias=&quot;TempUser&quot; type=&quot;com.github.ixiaow.sample.model2.User&quot; /&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot; /&gt; &lt;variable name=&quot;tempUserInfo&quot; type=&quot;TempUser&quot; /&gt; &lt;/data&gt; 预览添加默认值 由于 @{user.name}在布局文件中并没有明确的值，所以在预览视图中什么都不会显示，不便于观察文本的大小和字体颜色等属性，此时可以为之设定默认值（文本内容或者是字体大小等属性都适用），默认值将只在预览视图中显示，且默认值不能包含引号 android:text=&quot;@{userInfo.name,default=defaultValue}&quot; 此外，也可以通过 ActivityMainBinding 直接获取到指定 ID 的控件: dataBinding.mUserName.text = &quot;lisi&quot; 自定义生成的绑定类的类名 每个数据绑定布局文件都会生成一个绑定类，ViewDataBinding 的实例名是根据布局文件名来生成，采用驼峰命名法来命名，并省略布局文件名包含的下划线。控件的获取方式类似，但首字母小写。 通过如下方式自定义 ViewDataBinding 的实例名 &lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt; 在 Fragment 和 RecyclerView 中使用 在 Fragment 中的使用 class BlankFragment : Fragment() { override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { val blankFragmentBinding: BlankFragmentBinding = DataBindingUtil.inflate(inflater, R.layout.blank_fragment, container, false) return blankFragmentBinding.root } } 在RecyclerView中使用 具体使用请参考：DataBinding 应用于RecyclerView override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerViewHolder { val itemMvvmBinding = DataBindingUtil.inflate&lt;ViewDataBinding&gt;( LayoutInflater.from(parent.context), R.layout.item_mvvm, parent, false ) itemMvvmBinding.getRoot().setOnClickListener(this) return RecyclerViewHolder(itemMvvmBinding) } override fun onBindViewHolder(holder: RecyclerViewHolder, position: Int) { val itemMvvmBinding = holder.getBinding() val userBean = data.get(position) itemMvvmBinding.setUser(userBean) //将position保存在itemView的Tag中，以便点击时进行获取 itemMvvmBinding.getRoot().setTag(position) itemMvvmBinding.btnUpdate.setOnClickListener(OnBtnClickListener(1, userBean)) itemMvvmBinding.btnDelete.setOnClickListener(OnBtnClickListener(2, position)) // 立刻执行绑定 itemMvvmBinding.executePendingBindings() } 以上实现数据绑定的方式，每当绑定的变量发生变化的时候，都需要重新向 ViewDataBinding 传递新的变量值才能刷新 UI 。接下来看如何实现自动刷新 UI 单向数据绑定 实现数据变化自动驱动 UI 刷新的方式有三种：BaseObservable、ObservableField、ObservableCollection BaseObservable 一个简单的ViewModel 类被更新后，并不会让 UI 自动更新。而数据绑定后，我们自然会希望数据变更后 UI 会即时刷新，Observable 就是为此而生的概念。 BaseObservable 提供了 notifyChange() 和 notifyPropertyChanged() 两个方法。 notifyChange() 它会刷新所有的值。 notifyPropertyChanged() 它只会根据对应的BR的flag更新，该 BR 的生成通过注释 @Bindable 生成，可以通过 BR notify 特定属性关联的视图。 由于kotlin的属性默认是public修饰，所以可以直接在属性上@Bindable, 如何设置了修饰符且不为public的话，则可使用@get BIndable（表示在get()方法上标记@Bindable） import androidx.databinding.BaseObservable import androidx.databinding.Bindable import com.github.ixiaow.sample.BR class UserInfo : BaseObservable() { // 对name进行@Bindable标志，然后会生成BR.name @Bindable var name: String = &quot;&quot; set(value) { field = value // 当name,发生改变时只会刷新与name相关控件的值，不会刷新其他的值 notifyPropertyChanged(BR.name) } @get: Bindable var password: String = &quot;&quot; set(value) { field = value // 当password 发生改变时，也会刷新其他属性相关的控件的值 notifyChange() } } 布局文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;com.github.ixiaow.sample.model.UserInfo&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView app:layout_constraintVertical_chainStyle=&quot;spread&quot; android:id=&quot;@+id/mUserName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{userInfo.name}&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{userInfo.password}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mUserName&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; OnPropertyChangedCallback 实现了 Observable 接口的类允许注册一个监听器OnPropertyChangedCallback，当可观察对象的属性更改时就会通知这个监听器。 当中 propertyId 就用于标识特定的字段 user.addOnPropertyChangedCallback(object : Observable.OnPropertyChangedCallback(){ override fun onPropertyChanged(sender: Observable, propertyId: Int) { } }) ObservableField 继承于 Observable 类相对来说限制有点高，且也需要进行notify 操作，因此为了简单起见可以选择使用 ObservableField。 可以理解为官方对 BaseObservable 中字段的注解和刷新等操作的封装，官方原生提供了对基本数据类型的封装，例如 ObservableBoolean、ObservableByte、ObservableChar、ObservableShort、ObservableInt、ObservableLong、ObservableFloat、ObservableDouble 以及 ObservableParcelable ，也可通过 ObservableField 泛型来申明其他类型。 class ObservableUser { val name = ObservableField&lt;String&gt;() val password = ObservableField&lt;String&gt;() } 对 ObservableUser属性值的改变都会立即触发 UI 刷新，概念上与Observable 区别不大，具体效果可看下面提供的源代码，这里不再赘述 ObservableCollection dataBinding 也提供了包装类用于替代原生的 List 和 Map，分别是 ObservableList 和 ObservableMap,当其包含的数据发生变化时，绑定的视图也会随之进行刷新 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;androidx.databinding.ObservableList&quot;/&gt; &lt;import type=&quot;androidx.databinding.ObservableMap&quot;/&gt; &lt;import type=&quot;com.github.ixiaow.sample.model.User&quot;/&gt; &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt; &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt; &lt;variable name=&quot;list&quot; type=&quot;ObservableList&lt;User&gt;&quot;/&gt; &lt;variable name=&quot;map&quot; type=&quot;ObservableMap&lt;String, User&gt;&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView app:layout_constraintVertical_chainStyle=&quot;spread&quot; android:id=&quot;@+id/mUserName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{list[index].name}&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{map[key].password}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mUserName&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val dataBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) dataBinding.map = ObservableArrayMap&lt;String, User&gt;().apply { &quot;android&quot; to User(&quot;android&quot;, &quot;12367&quot;) &quot;java&quot; to User(&quot;java&quot;, &quot;12534&quot;) &quot;c&quot; to User(&quot;c&quot;, &quot;12344&quot;) &quot;c++&quot; to User(&quot;c++&quot;, &quot;14423&quot;) &quot;c#&quot; to User(&quot;c#&quot;, &quot;12334&quot;) } dataBinding.key = &quot;c&quot; dataBinding.list = ObservableArrayList&lt;User&gt;().apply { add(User(&quot;android&quot;, &quot;123&quot;)) add(User(&quot;java&quot;, &quot;1234&quot;)) add(User(&quot;c&quot;, &quot;1235&quot;)) add(User(&quot;c++&quot;, &quot;123447&quot;)) } dataBinding.index = 3 } } 双向数据绑定 双向绑定的意思即为当数据改变时同时使视图刷新，而视图改变时也可以同时改变数据 看以下例子，当 EditText的输入内容改变时，会同时同步到变量 user,绑定变量的方式比单向绑定多了一个等号：android:text=&quot;@={user.name}&quot; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;com.github.ixiaow.sample.model.ObservableUser&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;EditText app:layout_constraintVertical_chainStyle=&quot;spread&quot; android:id=&quot;@+id/mUserName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@={userInfo.name, default=`name`}&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;EditText android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@={userInfo.password, default=`1234`}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mUserName&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val dataBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) val observableUser = ObservableUser() observableUser.name.set(&quot;我是name&quot;) observableUser.password.set(&quot;我是password&quot;) dataBinding.userInfo = observableUser } } 事件绑定 严格意义上来说，事件绑定也是一种变量绑定，只不过设置的变量是回调接口而已。 事件绑定可用于以下多种回调事件： android:onClick android:onLongClick android:afterTextChanged android:onTextChanged ... 新建一个 UserPresenter 类来声明 onClick() 和 afterTextChanged() 事件相应的回调方法 class UserPresenter { fun onUserNameClick(user: ObservableUser) { } fun afterTextChanged(s: Editable) { } fun saveUser(view: View, user: ObservableUser){ } } &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.sample.UserPresenter&quot;/&gt; &lt;variable name=&quot;presenter&quot; type=&quot;UserPresenter&quot;/&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;com.github.ixiaow.sample.model.ObservableUser&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;EditText app:layout_constraintVertical_chainStyle=&quot;spread&quot; android:id=&quot;@+id/mUserName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{()-&gt; presenter.onUserNameClick(userInfo)}&quot; android:text=&quot;@={userInfo.name, default=`name`}&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;EditText android:id=&quot;@+id/mPassword&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:afterTextChanged=&quot;@{presenter::afterTextChanged}&quot; android:text=&quot;@={userInfo.password, default=`1234`}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mUserName&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;EditText android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{(theView)-&gt;presenter.saveUser(theView, userInfo)}&quot; android:text=&quot;@={userInfo.password, default=`1234`}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mPassword&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; 方法引用的方式与调用函数的方式类似， 可以选择保持事件回调方法的签名一致：@{presenter.afterTextChanged}，此时方法名可以不一样，但方法参数和返回值必须和原始的回调函数保持一致。 可以引用不遵循默认签名的函数：@{()-&gt;presenter.onUserNameClick(userInfo)}，这里用到了 Lambda 表达式，这样就可以不遵循默认的方法签名，将userInfo对象直接传回点击方法中。此外，也可以使用方法引用 :: 的形式来进行事件绑定 使用类方法 首先定义一个静态方法 object StringUtils { fun toUpperCase( str:String):String { return str.toUpperCase(); } } 在 data 标签中导入该工具类 &lt;import type=&quot;com.github.ixiaow.sample.StringUtils&quot; /&gt; 然后就可以像对待一般的函数一样来调用了 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{()-&gt;userPresenter.onUserNameClick(userInfo)}&quot; android:text=&quot;@{StringUtils.toUpperCase(userInfo.name)}&quot; /&gt; 运算符 基础运算符 DataBinding 支持在布局文件中使用以下运算符、表达式和关键字 算术 + - / * % 字符串合并+ 逻辑&amp;&amp; || 二元&amp; | ^ 一元 + - ! ~ 移位&gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较== &gt; &lt; &gt;= &lt;= Instanceof Grouping () character, String, numeric, null Cast 方法调用 Field 访问 Array访问 [] 三元?: 目前不支持以下操作 this super new 显示泛型调用 此外，DataBinding 还支持以下几种形式的调用: Null Coalescing 空合并运算符 ?? 会取第一个不为 null 的值作为返回值 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{user.name ?? user.password}&quot; /&gt; 等价于 android:text=&quot;@{user.name != null ? user.name : user.password}&quot; 属性控制 可以通过变量值来控制 View 的属性 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;可见性变化&quot; android:visibility=&quot;@{user.male ? View.VISIBLE : View.GONE}&quot; /&gt; 避免空指针异常 DataBinding 也会自动帮助我们避免空指针异常 例如，如果 &quot;@{userInfo.password}&quot; 中 userInfo 为 null 的话，userInfo.password 会被赋值为默认值 null，而不会抛出空指针异常 include 和 viewStub include 对于 include 的布局文件，一样是支持通过 dataBinding 来进行数据绑定，此时一样需要在待 include 的布局中依然使用 layout 标签，声明需要使用到的变量 view_include.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.databindingsample.model.User&quot; /&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;User&quot; /&gt; &lt;/data&gt; &lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#acc&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:padding=&quot;20dp&quot; android:text=&quot;@{userInfo.name}&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; &lt;/layout&gt; 在主布局文件中将相应的变量传递给 include 布局，从而使两个布局文件之间共享同一个变量 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.databindingsample.model.User&quot; /&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;User&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.Main6Activity&quot;&gt; &lt;include layout=&quot;@layout/view_include&quot; bind:userInfo=&quot;@{userInfo}&quot; /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; viewStub dataBinding 一样支持 ViewStub 布局 在布局文件中引用 viewStub 布局 &lt;ViewStub android:id=&quot;@+id/view_stub&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout=&quot;@layout/view_stub&quot;/&gt; 获取到 ViewStub 对象，由此就可以来控制 ViewStub 的可见性 ActivityMain6Binding activityMain6Binding = DataBindingUtil.setContentView(this, R.layout.activity_main6); View view = activityMain6Binding.viewStub.getViewStub().inflate(); 如果需要为 ViewStub 绑定变量值，则 ViewStub 文件一样要使用 layout 标签进行布局，主布局文件使用自定义的 bind 命名空间将变量传递给 ViewStub &lt;ViewStub android:id=&quot;@+id/view_stub&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout=&quot;@layout/view_stub&quot; bind:userInfo=&quot;@{userInfo}&quot; /&gt; 如果在 xml 中没有使用 bind:userInfo=&quot;@{userInf}&quot;对 ViewStub 进行数据绑定，则可以等到当 ViewStub Inflate 时再绑定变量，此时需要为 ViewStub 设置 setOnInflateListener回调函数，在回调函数中进行数据绑定 activityMain6Binding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() { @Override public void onInflate(ViewStub stub, View inflated) { //如果在 xml 中没有使用 bind:userInfo=&quot;@{userInf}&quot; 对 viewStub 进行数据绑定 //那么可以在此处进行手动绑定 ViewStubBinding viewStubBinding = DataBindingUtil.bind(inflated); viewStubBinding.setUserInfo(user); Log.e(TAG, &quot;onInflate&quot;); } }); BindingAdapter dataBinding 提供了 BindingAdapter 这个注解用于支持自定义属性，或者是修改原有属性。注解值可以是已有的 xml 属性，例如 android:src、android:text等，也可以自定义属性然后在 xml 中使用 例如，对于一个 ImageView ，我们希望在某个变量值发生变化时，可以动态改变显示的图片，此时就可以通过 BindingAdapter 来实现 需要先定义一个静态方法，为之添加 BindingAdapter 注解，注解值是为 ImageView 控件自定义的属性名，而该静态方法的两个参数可以这样来理解：当 ImageView 控件的 url 属性值发生变化时，dataBinding 就会将 ImageView 实例以及新的 url 值传递给 loadImage() 方法，从而可以在此动态改变 ImageView 的相关属性 @BindingAdapter({&quot;url&quot;}) public static void loadImage(ImageView view, String url) { Log.d(TAG, &quot;loadImage url : &quot; + url); } 在 xml 文件中关联变量值，当中，bind 这个名称可以自定义 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.databindingsample.model.Image&quot; /&gt; &lt;variable name=&quot;image&quot; type=&quot;Image&quot; /&gt; &lt;/data&gt; &lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/ic_launcher_background&quot; bind:url=&quot;@{image.url}&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; &lt;/layout&gt; BindingAdapter 更为强大的一点是可以覆盖 Android 原先的控件属性。例如，可以设定每一个 Button 的文本都要加上后缀：“-Button” @BindingAdapter(&quot;android:text&quot;) public static void setText(Button view, String text) { view.setText(text + &quot;-Button&quot;); } &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{()-&gt;handler.onClick(image)}&quot; android:text='@{&quot;改变图片Url&quot;}'/&gt; 这样，整个工程中使用到了 &quot;android:text&quot; 这个属性的控件，其显示的文本就会多出一个后缀 BindingConversion dataBinding 还支持对数据进行转换，或者进行类型转换 与 BindingAdapter 类似，以下方法会将布局文件中所有以@{String}方式引用到的String类型变量加上后缀-conversionString @BindingConversion public static String conversionString(String text) { return text + &quot;-conversionString&quot;; } xml 文件 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text='@{&quot;xxx&quot;}' android:textAllCaps=&quot;false&quot;/&gt; 可以看到，对于 Button 来说，BindingAdapter 和 BindingConversion 同时生效了，而 BindingConversion 的优先级要高些, 此外，BindingConversion 也可以用于转换属性值的类型 看以下布局，此处在向 background 和 textColor 两个属性赋值时，直接就使用了字符串，按正常情况来说这自然是会报错的，但有了 BindingConversion 后就可以自动将字符串类型的值转为需要的 Drawable 和 Color 了 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background='@{&quot;红色&quot;}' android:padding=&quot;20dp&quot; android:text=&quot;红色背景蓝色字&quot; android:textColor='@{&quot;蓝色&quot;}'/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;20dp&quot; android:background='@{&quot;蓝色&quot;}' android:padding=&quot;20dp&quot; android:text=&quot;蓝色背景红色字&quot; android:textColor='@{&quot;红色&quot;}'/&gt; @BindingConversion public static Drawable convertStringToDrawable(String str) { if (str.equals(&quot;红色&quot;)) { return new ColorDrawable(Color.parseColor(&quot;#FF4081&quot;)); } if (str.equals(&quot;蓝色&quot;)) { return new ColorDrawable(Color.parseColor(&quot;#3F51B5&quot;)); } return new ColorDrawable(Color.parseColor(&quot;#344567&quot;)); } @BindingConversion public static int convertStringToColor(String str) { if (str.equals(&quot;红色&quot;)) { return Color.parseColor(&quot;#FF4081&quot;); } if (str.equals(&quot;蓝色&quot;)) { return Color.parseColor(&quot;#3F51B5&quot;); } return Color.parseColor(&quot;#344567&quot;); } Array、List、Set、Map ... dataBinding 也支持在布局文件中使用 数组、Lsit、Set 和 Map，且在布局文件中都可以通过 list[index] 的形式来获取元素 而为了和 variable 标签的尖括号区分开，在声明 Lsit&lt; String &gt; 之类的数据类型时，需要使用尖括号的转义字符 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;java.util.List&quot; /&gt; &lt;import type=&quot;java.util.Map&quot; /&gt; &lt;import type=&quot;java.util.Set&quot; /&gt; &lt;import type=&quot;android.util.SparseArray&quot; /&gt; &lt;variable name=&quot;array&quot; type=&quot;String[]&quot; /&gt; &lt;variable name=&quot;list&quot; type=&quot;List&lt;String&gt;&quot; /&gt; &lt;variable name=&quot;map&quot; type=&quot;Map&lt;String, String&gt;&quot; /&gt; &lt;variable name=&quot;set&quot; type=&quot;Set&lt;String&gt;&quot; /&gt; &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&lt;String&gt;&quot; /&gt; &lt;variable name=&quot;index&quot; type=&quot;int&quot; /&gt; &lt;variable name=&quot;key&quot; type=&quot;String&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView ··· android:text=&quot;@{array[1]}&quot; /&gt; &lt;TextView ··· android:text=&quot;@{sparse[index]}&quot; /&gt; &lt;TextView ··· android:text=&quot;@{list[index]}&quot; /&gt; &lt;TextView ··· android:text=&quot;@{map[key]}&quot; /&gt; &lt;TextView ··· android:text='@{map[&quot;leavesC&quot;]}' /&gt; &lt;TextView ··· android:text='@{set.contains(&quot;xxx&quot;)?&quot;xxx&quot;:key}' /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 资源引用 dataBinding 支持对尺寸和字符串这类资源的访问 dimens.xml &lt;dimen name=&quot;paddingBig&quot;&gt;190dp&lt;/dimen&gt; &lt;dimen name=&quot;paddingSmall&quot;&gt;150dp&lt;/dimen&gt; string.xml &lt;string name=&quot;format&quot;&gt;%s is %s&lt;/string&gt; layout.xml &lt;data&gt; &lt;variable name=&quot;flag&quot; type=&quot;boolean&quot; /&gt; &lt;/data&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;@{flag ? @dimen/paddingBig:@dimen/paddingSmall}&quot; android:text='@{@string/format(&quot;leavesC&quot;, &quot;Ye&quot;)}' android:textAllCaps=&quot;false&quot; /&gt; ","link":"https://www.xiaowujiang.cn/posts/3c6ea6b6/"},{"title":"360加固Gradle插件实现","content":"最近码了一个基于360加固的流程实现的Gradle插件，在自动编译打包后进行360加固流程操作。只需要配置一些参数后，就可以实现自动打包编译和加固。 项目地址:https://github.com/ixiaow/android-gradle-plugin 使用步骤 1. 添加依赖 在根build.gradle中添加： allprojects { repositories { maven { url &quot;https://jitpack.io&quot; } } } dependencies { ... classpath 'com.github.ixiaow:android-gradle-plugin:$version' } (请替换 $version为最新的版本号:) 在app的模块build.gradle中添加： apply plugin: 'com.github.ixiaow.jiagu' 2. 参数配置 使用这款插件需要在app的build.gradle中添加一些配置信息，如下： jiagu { home '../360jiagu' // 360加固软件的根目录 buildTypes 'release', 'debug' // 需要加固的编译类型 configs '-crashlog' // 选择360的可选配置服务 username 'user' // 360加固用户名 password 'password' // 360加固密码 charsetName 'GBK' // 360加固控制台输出字符编码 // apk签名文件， 如果在Android中配置了签名文件，此项可以不用配置，插件会自动读取名为'release'的签名文件 signingConfig { key_alias : KEY_ALIAS, key_password : KEY_PASSWORD, key_store_password: KEY_STORE_PASSWORD, key_store_file : KEY_STORE_FILE } } 3. 开始加固 确认上述参数无误后，就可以在控制台中切换到当前项目根目录执行 # 各个系统的控制台gradle命令可能不一样： ./gradlew 或 gradlew ./gradlew clean jiaGuApk 文档 android-gradle-plugin 360加固助手 360加固助手 ","link":"https://www.xiaowujiang.cn/posts/6c01e784/"},{"title":"Android通过Intent简单实现分享功能","content":"现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过Intent方式打开在系统中安装的具有分享功能的App的分享页面。 方法如下： public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){ Intent intent = new Intent(); intent.setAction(Intent.ACTION_SEND); intnet.setType(&quot;text/plain&quot;); PackageManager packageManager = context.getPackageManager(); List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0); return resloveInfos; } 如果只需要QQ和微信分享，可以进行如下操作： public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){ Intent intent = new Intent(); intent.setAction(Intent.ACTION_SEND); intnet.setType(&quot;text/plain&quot;); PackageManager packageManager = context.getPackageManager(); List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0); List&lt;ResolveInfo&gt; shareItems = new ArrayList(); for(ResolveInfo info: resolveInfos) { String name = info.activityInfo.packageName; if (TextUtils.equals(packageName, &quot;com.tencent.mm&quot;) || TextUtils.equals(packageName, &quot;com.tencent.mobileqq&quot;)) { shareItems.add(resolveInfo); } } return shareItems; } 通过ResolveInfo获取图标ICON和Label: Drawable drawable = resloveInfo.loadIcon(packageManager); CharSequence label = resolveInfo.loadLabel(packageManager); 通过Intent发起分享： public static void share(Context context, ResolveInfo info, String shareContent){ Intent itnent = new Intent(); intnet.setAction(Intent.ACTION_SEND); String pkg = resolveInfo.activityInfo.packageName; String cls = resolveInfo.activityInfo.name; intent.setComponent(new Component(pkg, cls)); intent.putExtra(Intent.EXTRA_TEXT, shareContent); context.startActivity(intent); } ","link":"https://www.xiaowujiang.cn/posts/73a6d0c4/"},{"title":"Http框架封装","content":"用过了现有的一些http请求框架，决定自己也来简单的封装一个。本文只是基于一些http请求框架二次封装的，高手勿喷。源码 http的请求和响应 一个http的请求通常包含请求头、请求体、响应头和响应体，考虑到这些因素，HttpConfig和 ApiResponse就诞生了: HttpConfig HttpConfig http参数配置类，应该包含如下属性: baseUrl/url 如果使用restful形式，baseUrl是不能为空并且url为业务path, 如果是非restful,url必须为请求全路径 GET/POST 有了url，接下来需要有请求的方法类型，由于我这边只用到了GET和POST,所以只对此做了封装。 特别说明： POST 有三种提交方式（form表单、json形式和 复杂形式） FORM_DATA(&quot;application/x-www-form-urlencoded;charset=utf-8&quot;), JSON_DATA(&quot;application/json;charset=utf-8&quot;), MULTI_PART_DATA(&quot;multipart/form-data;charset=utf-8&quot;); headers http的请求头封装，采用(Map&lt;String,String&gt;)集合 params http的请求参数，采用(Map&lt;String,Object&gt;)如果请求方法是GET形式，那么采用拼接字符串的形式将参数拼接到url中; 如果请求方法是POST形式，则需要根据提交参数的方式不同，会有不同的请求体。 cacheStrategy 考虑到App的使用交互和服务器减压，我们要考虑有一些请求可以做一些缓存，那么常用的缓存策略有CACHE_ONLY、CACHE_FIRST、NET_ONLY和NET_CACHE type type是响应数据的type,这个主要用在Http请求结果返回后将json转为bean对象的映射类型，需要考虑泛型和非泛型（Class和ParamizableType） tag 给每一个请求链接打一个标签，可用于一些其它的操作，如根据tag取消请求 isAsync 当前请求是同步执行还是异步执行的标志，异步执行会在子线程中进行http请求，同步执行在当前线程中执行http请求。 ApiResponse 使用ApiResponse的原因是为了规范请求结果返回的表现形式，他有一个T类型的数据。 code 状态码,与http请求响应状态码一致，200~300 请求成功，304 使用缓存 message 请求响应的错误信息 data 响应的数据，泛型T, 根据httpConfig中的type,映射 json--&gt; bean Http引擎 IHttpEngine是一个接口，使用者可以根据实际的情况做具体的实现。 public interface IHttpEngine { // 开始执行 http请求 &lt;T&gt; execute(HttpConfig config, MultableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData); // 根据tag取消 void cancel(Object tag); } 由于http请求有同步和异步两种情况并且又牵扯到了缓存策略问题（如果先进行缓存返回在执行网络请求并返回数据），在异步回调的情况下这些问题可以通过回调解决，但是在同步情况下，这些问题并不能很好的处理，曾经有使用过将当前请求clone,然后再次调用请求服务器的方法，但是在使用过jetpack的LiveData框架后这些问题都可以解决了。 OkhttpEngine Android开发目前来说大多数项目使用的都是Okhttp来做请求，本次我使用的默认引擎也是使用它来作为默认的实现。OkHttpEngine okhttp简单配置 对okhttp进行一些简单的配置就可以进行网络请求了，如下： 创建okHttpClient private static final OkHttpClient OK_HTTP_CLIENT; // 添加日志拦截器 HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor(); loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); OK_HTTP_CLIENT = new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .readTimeout(15, TimeUnit.SECONDS) .writeTimeout(15, TimeUnit.SECONDS) .addInterceptor(loggingInterceptor) .build(); 添加证书管理 TrustManager[] trustManagers = new TrustManager[]{ new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {} @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {} @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } } }; SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;); sslContext.init(null, trustManagers, new SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory()); HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -&gt; true); 实现Http请求 IHttpEngine中的execute方法是具体的http请求方法，所有实现IHttpEngine的方法都需要实现此方法。 @NonNull @Override public &lt;T&gt; void execute(@NonNull Config config, @NonNull MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) { Request request = generateRequest(config); Call call = OK_HTTP_CLIENT.newCall(request); if (!config.isAsync) { execute(call, config, liveData); } else { enqueue(call, config, liveData); } } execute方法中大致需要做以下事： 创建request--&gt; genearteRequest 发送http请求 ---&gt; execute/enqueue 创建httpRequest generateRequest()根据HttpConfig中的请求方式来创建不同的http请求。 /** * 根据配置信息生成request * * @param config 配置信息 * @return request */ @NonNull private Request generateRequest(@NonNull Config config) { switch (config.method) { case Config.GET: return generateGetRequest(config); case Config.POST: return generatePostRequest(config); default: throw new IllegalStateException(&quot;this request method invalidate: &quot; + config.method); } } GET请求的创建方式 genearteGetReques()方法，利用okhttp的Request类创建request实例，并利用UrlCreator将参数拼接到url中。Url拼接时需要注意使用UrlEncoder编码，不然可能会造成服务器和客户端解析数据不一致的情况。 /** * 生成get方式的请求 * * @param config 请求配置 * @return 返回get方式的request */ @NonNull private Request generateGetRequest(@NonNull Config config) { Request.Builder builder = new Request.Builder().get(); builder.tag(config.tag); addHeader(builder, config); String url = UrlCreator.generateUrlForParams(config.url(), config.getParams()); return builder.url(url).build(); } POST请求的创建方式 POST请求方式提交内容时相对于GET方式要复杂许多，他需要根据提交方式的不同添加不同的header和内容body, 在generatePostRequest()方法中先利用okhttp的request类创建request实例，根据调用者在HttpConfig中设置formData来创建不同形式的body。 /** * 生成post请求 * * @param config http请求配置信息 * @return 请求request */ @NonNull private Request generatePostRequest(@NonNull Config config) { Request.Builder builder = new Request.Builder().url(config.url()); builder.tag(config.tag); addHeader(builder, config); // 根据提交方式添加header信息 Pair&lt;String, String&gt; header = config.formData.getHeader(); builder.addHeader(header.first, header.second); // 创建body RequestBody body = generatePostRequestBody(config); return builder.post(body).build(); } 判断formData类型，创建不同的request body。 /** * 获取post提交体 * * @param config 请求配置信息 * @return RequestBody */ @NonNull private RequestBody generatePostRequestBody(@NonNull Config config) { FormData formData = config.formData; switch (formData) { case FORM_DATA: return getFormDataRequestBody(config); case JSON_DATA: return getJsonDataRequestBody(config); case MULTI_PART_DATA: return getMultiDataRequestBody(config); default: throw new IllegalArgumentException(&quot;post formData is invalidate: &quot; + formData); } } 创建FormData(表单) form表单形式比较简单，只需要创建一个okhttp的FormBody并将param添加，需要注意的是添加param时调用的是addEncoded方法。 /** * 生成form data形式的post数据 * * @param config 请求配置 * @return FromBody */ @NonNull private RequestBody getFormDataRequestBody(@NonNull Config config) { FormBody.Builder builder = new FormBody.Builder(StandardCharsets.UTF_8); Map&lt;String, Object&gt; params = config.getParams(); for (Map.Entry&lt;String, Object&gt; entry : params.entrySet()) { builder.addEncoded(entry.getKey(), String.valueOf(entry.getValue())); } return builder.build(); } json形式 利用okHttp中的RequestBody.create()方法创建一个json形式的body,需要传递json和json形式的header。 /** * 生成json形式的post数据 * * @param config 请求配置 * @return RequestBody */ @NonNull private RequestBody getJsonDataRequestBody(@NonNull Config config) { if (config.getParams().isEmpty()) { throw new IllegalArgumentException(&quot;json data is null&quot;); } Object json = config.getParams().get(Config.JSON_KEY); return RequestBody.create(String.valueOf(json), MediaType.parse(config.formData.getValue())); } 复杂形式的body 复杂形式的body，主要是用在文件上传这一块儿。它需要判断当前param是普通key-value、单文件和多文件。 利用okhttp的MultiparBody创建body对象并根据内容类型调用的不同的body,然后调用addFormDataPart添加到MultipartBody中。 /** * 获取复杂的post提交体 * * @param config 请求配置信息 * @return MultipartBody */ @NonNull @SuppressWarnings(&quot;unchecked&quot;) private RequestBody getMultiDataRequestBody(@NonNull Config config) { MultipartBody.Builder builder = new MultipartBody.Builder(); builder.setType(MultipartBody.FORM); for (Map.Entry&lt;String, Object&gt; entry : config.getParams().entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); if (value instanceof File) { File file = (File) value; RequestBody requestBody = MultipartBody.create(file, getFileMediaType(file)); builder.addFormDataPart(key, file.getName(), requestBody); } else if (value instanceof List) { List&lt;File&gt; files = (List&lt;File&gt;) value; for (int i = 0; i &lt; files.size(); i++) { File file = files.get(i); RequestBody requestBody = MultipartBody.create(file, getFileMediaType(file)); builder.addFormDataPart(key + i, file.getName(), requestBody); } } else { builder.addFormDataPart(key, String.valueOf(value)); } } return builder.build(); } 添加文件时需要有文件的类型，文件类型的获取方式是通过UrlConnection的getFileNameMap方法获取。 /** * 获取文件的type类型 * * @param file 文件 * @return MediaType */ @Nullable private MediaType getFileMediaType(@NonNull File file) { FileNameMap fileNameMap = URLConnection.getFileNameMap(); String contentTypeFor = fileNameMap.getContentTypeFor(file.getAbsolutePath()); if (contentTypeFor == null) { contentTypeFor = &quot;application/octet-stream&quot;; } return MediaType.parse(contentTypeFor); 通过以上的几种方式就可以创建一个http请求了，接下来需要发送请求了，发送请求需要通过httpConfig中的isAsync来判断是开启一个子线程还是在当前线程中执行操作（同步与异步）。 发送http请求 发送http请求会有同步请求(execute)和异步请求(enqueue), 同步请求是在当前线程中发送http请求，异步请求采用okhttp线程池发送请求。处理请求时在合适的地方需要判断该请求是否被取消。 if (call.isCanceled()) { return; } 同步请求(execute) 在发送http请求时会根据缓存策略进行响应的处理，而同步请求没有办法做到return后可以继续进行网络请求，所以引入了LiveData来发送数据。 目前缓存策略有四种，我们需要根据判断来进行不同的操作，关于缓存的创建和获取后续会有说明，这块儿只有根据缓存策略处理数据。 /** * 同步执行的方法 */ @SuppressWarnings(&quot;unchecked&quot;) private &lt;T&gt; void execute(Call call, Config config, MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) { ApiResponse&lt;T&gt; apiResponse; Logs.d(&quot;execute before cache: &quot; + Thread.currentThread().getName()); // 只访问本地数据 if (config.cacheStrategy == Config.CACHE_ONLY) { apiResponse = readCache(call.request().url().toString()); liveData.postValue(apiResponse); return; } // 先访问本地数据，然后再发起网络请求 if (config.cacheStrategy == Config.CACHE_FIRST) { apiResponse = readCache(call.request().url().toString()); liveData.postValue(apiResponse); } Logs.d(&quot;execute current thread: &quot; + Thread.currentThread().getName()); // ..... 此处开始进行http网络请求 if (call.isCanceled()) { return; } // liveData发送数据 liveData.postValue(apiResponse); if (config.cacheStrategy != Config.NET_ONLY) { saveCache(call.request().url().toString(), apiResponse); } } 使用okhttp的execute方法发送http请求,并利用ConvertFactory进行数据解析，ConvertFactory后续会介绍。 try { Response response = call.execute(); IConvert&lt;Response, T&gt; convert = ConvertFactory.create(); apiResponse = convert.convert(response, config.type); } catch (IOException e) { e.printStackTrace(); apiResponse = new ApiResponse&lt;&gt;(); apiResponse.status = 500; apiResponse.message = e.getMessage(); } 异步请求(enqueue) 异步请求与同步请求一样也需要进行缓存策略进行缓存处理，这块儿的处理逻辑一致，所以下面的代码块将这部分省略。使用okhttp的enqueue方法发送http请求,在onResponse中并利用ConvertFactory进行数据的解析，在onFailure中自定义错误信息的返回。 private &lt;T&gt; void enqueue(Call call, Config config, MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) { //... 缓存策略判断数据处理返回 ... // 开始请求服务器 call.enqueue(new Callback() { @Override public void onFailure(@NotNull Call call, @NotNull IOException e) { if (call.isCanceled()) { return; } ApiResponse&lt;T&gt; apiResponse = new ApiResponse&lt;&gt;(); apiResponse.status = 500; apiResponse.message = e.getMessage(); liveData.postValue(apiResponse); } @SuppressWarnings(&quot;unchecked&quot;) @Override public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException { if (call.isCanceled()) { return; } IConvert&lt;Response, T&gt; convert = ConvertFactory.create(); ApiResponse&lt;T&gt; apiResponse = convert.convert(response, config.type); liveData.postValue(apiResponse); if (config.cacheStrategy != Config.NET_ONLY) { saveCache(call.request().url().toString(), apiResponse); } } }); } 取消请求 cancle()方法中，利用Okhttp来取消请求，主要是比对tag, 如下： @Override public void cancel(@NonNull Object tag) { if (OK_HTTP_CLIENT == null) { return; } //查找当前需要取消的tag是否在未执行的请求中 for (Call call : OK_HTTP_CLIENT.dispatcher().queuedCalls()) { if (tag.equals(call.request().tag())) { call.cancel(); } } //查找当前需要请求的tag是否在正在执行的请求中 for (Call call : OK_HTTP_CLIENT.dispatcher().runningCalls()) { if (tag.equals(call.request().tag())) { call.cancel(); } } } 响应数据转换 从服务器返回数据后，需要将数据格式进行转换成数据模型bean，由于数据返回的形式有多种，所以解析方式也会有多种，所以这块儿可以考虑使用数据解析工厂类去做数据解析，不同的解析数据做不同的逻辑实现，达到解偶。 定义一个Convert类，利用泛型的方式进行参数传递。 public interface IConvert&lt;T, R&gt; { // 数据的返回形式必须是ApiResponse, type即为泛型T的类型 @NonNull ApiResponse&lt;R&gt; convert(@NonNull T t, @NonNull Type type); } 这边提供了一种简单的convert调用方式，后面可以要考虑进行扩展选择： IConvert&lt;Response, T&gt; convert = ConvertFactory.create(); apiResponse = convert.convert(response, config.type); ConverFactory为IConvert的实现类。 public class ConvertFactory&lt;R&gt; implements IConvert&lt;Response, R&gt; { private static ConvertFactory convertFactory; public static ConvertFactory create() { if (convertFactory == null) { convertFactory = new ConvertFactory(); } return convertFactory; } ........... } 本地缓存 数据缓存采用的是Room数据库进行数据的存储，room是jetpack中的一种组件。它的创建方式也很简单。 创建数据库表 // Entity 表示该对象是一张数据库表 @Entity(tableName = &quot;cache&quot;) public class Cache { // primarykey表示表的主键 @PrimaryKey @NonNull public String key; // ColumnInfo表示该字段在表中显示的字段名 @ColumnInfo(name = &quot;_data&quot;) public byte[] data; } 创建数据库 // entities 表示 需要在该数据库中创建的表，可以创建多张 // version 数据库的版本号 // exportSchema 导出表创建的语句 @Database(entities = Cache.class, version = 1, exportSchema = true) public abstract class CacheDatabase extends RoomDatabase { private static final CacheDatabase cacheDatabase; static { Application application = AppGlobals.getApplication(); cacheDatabase = Room.databaseBuilder(application, CacheDatabase.class, &quot;net_cache.db&quot;) .allowMainThreadQueries() .build(); } // 数据库与Dao关联 public abstract CacheDao getCacheDao(); public static CacheDatabase get() { return cacheDatabase; } } 创建数据库表操作类Dao // Dao 用来表示当前类是数据库表的操作类 @Dao public interface CacheDao { // Insert 表示增加一条记录到数据库表中 // onConflict 表示如果添加数据时出现冲突的解决策略 @Insert(onConflict = OnConflictStrategy.REPLACE) void save(@NonNull Cache cache); // Delete 表示删除一条记录 @Delete int delete(@NonNull Cache cache); // Update 表示更新一条记录 // onConflict 表示如果更新数据时出现冲突的解决策略 @Update(onConflict = OnConflictStrategy.REPLACE) int update(@NonNull Cache cache); // Query 查找一条记录 @Query(&quot;SELECT * FROM cache WHERE `key`=:key&quot;) Cache query(@NonNull String key); } Type类型 由于java中的泛型在编译完毕后会擦除该类型，所以我们无法在同步执行或者多级泛型嵌套的情况下拿到泛型的实际类型。目前的解决方式有两种。 调用者传入实际类型 提供可以传入实际类型的方法，调用处将明确类型传递。 利用子类实现的方式获取实际类型 Java代码在编译成字节码class文件时会保留子类的泛型信息。所以大部分的json数据解析都是采用的此方法，如：Gson中的TypeToken 以及fasjson中的TypeReference。 public abstract class TypeToken&lt;T&gt; { // 泛型T的实际类型 protected Type type; public TypeToken() { Type superClass = getClass().getGenericSuperclass(); // 获取泛型的实际类型 Type oriType = ((ParameterizedType) superClass).getActualTypeArguments()[0]; if (oriType instanceof Class) { type = oriType; } else { //修复在安卓环境中问题 type = putCacheTypeIfAbsent(oriType); } } } 由于本次封装的返回的数据类型是ApiResponse&lt;T&gt;所以需要对泛型进行二次解析，所以新建了一个ApiResponseToken。 public abstract class ApiResponseToken&lt;T&gt; extends TypeToken&lt;T&gt; { public ApiResponseToken() { Type superClass = getClass().getGenericSuperclass(); Type oriType = ((ParameterizedType) superClass).getActualTypeArguments()[0]; if (oriType instanceof Class) { type = oriType; } else { // 解决ApiResponse&lt;T&gt;这种情况 if (oriType instanceof ParameterizedType) { oriType = ((ParameterizedType) oriType).getActualTypeArguments()[0]; } type = putCacheTypeIfAbsent(oriType); } } } 由于本次框架的数据返回使用了LiveData&lt;T&gt;的形式，并通过订阅的方式实现数据返回，所以又添加了一个类型，用于自行获取type。 public abstract class HttpObserver&lt;T&gt; extends ApiResponseToken&lt;T&gt; implements Observer&lt;T&gt; { } 在使用LiveData的observe方法订阅时，在创建一个HttpObserserver实例，在构造方法中就可以解析出T的类型，就不需要我们手动传入T的真实类型了。 /** * 开始订阅请求网络数据 */ public &lt;T&gt; void observe(LifecycleOwner owner, HttpObserver&lt;ApiResponse&lt;T&gt;&gt; observer) { // 由于HttpObserver是继承ApiResponseToken的， // 所以可以快速的获取到泛型T的实际类型 Type type = observer.getType(); mConfig.type = type; Logs.e(&quot;type: &quot; + type); } 使用方式： .observe(owner, // 通过new HtppObserver的方式就可以拿到具体的泛型值 new HttpObserver&lt;ApiResponse&lt;JSONObject&gt;&gt;() { @Override public void onChanged(ApiResponse&lt;JSONObject&gt; apiResponse) { ..... } } ); Http请求入口类 LiveHttp的封装，LiveHttp主要提供了以下功能： 持有一个默认的http引擎 可支持设置baseUrl和设置引擎的入口 设置HttpConfig中的参数 执行Http请求入口 提供取消http请求的入口 支持链式调用 以上几点都很简单，主要是来说一下执行http请求入口： /** * 开始订阅请求网络数据 */ public &lt;T&gt; void observe(LifecycleOwner owner, HttpObserver&lt;ApiResponse&lt;T&gt;&gt; observer) { // 获取泛型实际类型 Type type = observer.getType(); mConfig.type = type; Logs.d(&quot;type: &quot; + type); if (TextUtils.isEmpty(mConfig.url())) { throw new IllegalArgumentException(&quot;请求路径不能为空&quot;); } MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData = new MutableLiveData&lt;&gt;(); // liveData的订阅必须是要在主线程中 TaskExecutor.get().postToMain(() -&gt; liveData.observe(owner, observer)); sHttpEngine.execute(mConfig, liveData); } ","link":"https://www.xiaowujiang.cn/posts/84a009ed/"},{"title":"PicGo搭建github图床","content":"使用图床可以节省本地服务器空间，加快图片打开速度，对于写博客或者一些网站使用很有必要，本次介绍的是PicGo的使用。 下载PicGo并安装； 生成Githubtoken 步骤如下： 点击个人中心，选择Settings,打开个人设置页面； 在个人设置页面选择Developer Settings 进入Developer settings页后，点击Personal access tokens打开新的页面后,并点击右边的Generate new token 生成token 在生成token页面，勾选repo 创建公共仓库，用来存放相关资源图片 ​ 在github上创建一个仓库，用来存放一些资源 在PicGo中配置github图床相关信息 打开PicGo 后，先安装一个插件github-plus，该插件是用来将图片上传到gitee或github上，比自带的github图床方便(自带的没有办法删除远程记录) 安装完成后，插件配置： ① 处是需要存放图片的仓库，格式为 github用户名/ 仓库名; ② 处是存放图片路径的仓库下的分支，默认master分支； ③ token 为第二步骤上生成的github token； ④ 远程仓库存放图片的的路径，可自定义，可不填； ⑤ 自定义的图片路径，由于我使用了jsDelivr来实现github的cdn缓存，所以设置了此路径，如果不需要可不填； jsDelivr路径规则： https://cdn.jsdelivr.net/gh/用户名/仓库名@版本号，我这边版本号设置的是latest表示获取最新资源。 ⑥ origin 表示 仓库可以是gitee或github,根据前面的步骤，此处只能是github； ⑦ 将其设置为默认图床 注意事项 如果仓库需要设置自定义域名，需要将我们的资源提交到一个gh-pages分区 如果你的自定义域名配置dns区分了境外和国内，那么就需要注意，访问该仓库可能会出现404的情况 解决办法： 创建一条新的cname解析，添加一个二级域名即可 ","link":"https://www.xiaowujiang.cn/posts/2513fba4/"},{"title":"Dart 语言简述","content":"最近开始接触Flutter相关的项目，通过源码、例子和一些资料的阅读，发现如果掌握了Dart的一些语法和一些基础对于Flutter的学习有着事半功倍的效果。下面是我在查阅一些资料和实际的开发中的一些总结。希望对今后的学习有所帮助。 Dart 诞生于 2011.10.10 日， 谷歌 Dart 语言项目的领导人 Lars Bak 在丹麦举行的Goto 会议上 布， Dart 种“结构化的 Web 程”语言， Dart 编程语言在所有现代浏览器和环境中提供高性能。 Dart语言的特性： Dart 是AOT（Ahead Of Time）编译的，编译成快速、可预测本地的代码。 Dart也可以JIT（Just In Time）编译，开发周期异常快，包括Flutter流行的亚秒级有状态热重载。 Dart可以更轻松地创建以60fps运行的流畅动画和状态，Dart可以在没有锁的情况下进行对象分配和垃圾回收。 Dart使Flutter不需要单独的声明式布局语言，或单独的可视化界面构建器，因为Dart的声明式编程布局易于阅读和可视化。 Dart重要概念： 一切皆对象，无论是变量、数字、函数等都是对象，所有的对像都继自Object， 这点类似于 Java 语言。 程序中指定数据类型使得程序合理地分配内存空间，并帮助编绎器进行语法检查，由于Dart 言是弱数据类型， 所以类型不是必须的 。 Dart 代码在运行前解析 指定数据类型和编译时的常量， 可以提高运行速度。 Dart 程序有统 的程序人口： main （） 这一点与 Java C 和 C＋＋ 语言很像。 Dart 没有 public protected private 这些修饰符的概念，私有特性通过变量或函数加上下划线来表示。 Dart 工具可以检查出警告信息(warning) 和 错误信息(errors)， 警告信息只是表明代码可能不工作，但是不会妨碍程序运行，错误信息可以是编译时的错误，也可能是运行时的错误， 编译时的错误将阻止程序运行，运行时的错误将会以异常（exception ）的方式呈现。 Dart 支持 anync/await 异步处理。 关键字（ 56 个）如下： 带有上标 1 的关键字是 内置关键字。避免把内置关键字当做标识符使用。 也不要把内置关键字 用作类名字和类型名字。 带有上标 2 的关键字，是在 Dart 1.0 发布以后又新加的，用于支持异步相关的特性。 变量与基本类型 变量的声明 在Dart里，变量的声明有三种方式： 用var关键字 用var声明变量时，如果未指定初始值，可以变成任意类型。如果指定了类型，则类型会被锁定。如： void main() { var v; // 初始值未指定类型 v = '2'; // 可以变为任意类型 v = 3; print('v: $v'); var v1 = '111'; // 初始化时已经指定类型 var v1 = 222; // 此时无法赋值成功，编译时报错 } 用dynamic关键字 dynamic声明的变量，表示动态任意类型，编译时不检查类型。如： void main() { dynamic d1 = '111'; d1 = 222; d1 = 333.0; print(&quot;d1: $d1&quot;); // dynamic修饰的变量，在编译时不做检查 d1.test(); // 这行还代码，在编译时是不会检查错误信息的，运行时会报错 } 用Object Object声明的变量，表示任意动态类型，编译时检查类型。如： void main() { Object o1 = &quot;sss&quot;; o1 = 222; o1.test(); // 编译时会做检查，报错 } 变量的默认值 没有初始化的变量会自动获取一个默认值null 一切皆为对象，对象的默认值为null final 和 const ​ final 或 const 修饰的变量为常量或固定值。 共同点： 声明的类型可以省略 初始化后不能再赋值 不能和var同时使用 不同点： 类级别常量，使用 static const const 可以使用其它const常量的值来初始化其值 使用const赋值声明，const可省略 可以更改非final、非const变量的值，即使曾经具有const值 const 导致的不可变性是可传递的 相同的const常量不会在内存中重复创建 const需要编译时常量 基本类型 Dart语言常用的基本数据类型包括： Number，String，Boolean，List和Map Number类型 Number 类型包括 int 整形，double浮点类型，他们都是num类型的子类 String类型 Dart 字符串是 utf-16 编码的字符序列，可以使用单引号或者双引号来创建字符 可以使用三个单引号或者双引号创建多行字符串对象 可以使用r前缀创建原始字符串，即输出原始字符，字符串里的转义等符号不会生效 可以在字符串中使用表达式：&quot;${expression}&quot;，如果表达式是一个标识符，可以省略{}，如果表达式的结果为一个对象，则 Dart会调用对象的toString方法 Boolean类型 Dart是强bool类型检查，只有bool类型的值是true才被认为是true， 如果未赋初值，则为null List类型 在Dart语言中，具有一系列相同类型的数据称为List对象。Dart中List可以直接打印出出各个元素，而java中则是地址。 Map类型 与java类似。 Set set1.difference(set2): 返回 set1 集合里有但 set2 里没有的元素集合 set1.intersection(set2)：返回set1和set2的交集 set1.union(set2)：返回set1和set2的并集 set1.retainAll()：set1只保留某些元素(要保留的元素要在原set中存在） Runs 用在符串中表示Unicode字符 使用String.fromCharCodes显示字符图形 如果非4个数值，需要把编码值放到大括号中 函数 Dart是一个面向对象的语言,所以函数也是对象，函数属于Function对象。函数可以像参数一样传递给其他函数。 函数定义 定义函数时可以省略类型(不建议) void func(a, b){} // 参数a,b都省略了类型 支持缩写语法=&gt; void main() =&gt; runApp(MyApp()); // 当函数体只有一条语句时可以使用此种写法 可在函数内定义函数 可以在函数里定义函数，如： int func(int a, int b) { int sum(int a, int b, int c) { return a + b + c; } return sum(a, b, 1); } dart 函数支持闭包 Function addFunction(int a) { return (y) =&gt; a + y; } void main() { var addFunc = addFunction(12); print(addFunc(22)); } 函数返回值 所有的函数都有返回值 如果没有指定函数返回值，则默认的返回值是null 没有返回值的函数,系统会在最后添加隐式的return语句 可选参数 可选命名参数 使用{param1, param2,...}的形式来指定命名参数。 main() { func(a:1); func(b:1); func(a:1, b:1); } int func({int a, int b}) { return a + b; } 可选位置参数 将参数使用中括号[]括起来,用来表明是可选位置参数，必填参数要放在可选参数前面。 String getUserInfo(String name, String sex, [String from]) {} 其中name和sex是必须传入的参数,from参数可以不传 参数默认值 如果参数指定了默认值,当不传入值时，函数就会使用这个默认值。通常默认值参数为null。 String getUserInfo(String name, String sex, [String from = '中国']) {} 可选命名参数默认值(默认值必须是编译时常量)，可以使用等号= 或冒号:，Dart SDK 1.21 之前只能用冒号，冒号的支持以后会移除，所以建议使用等号。 可选位置参数默认值(默认值必须是编译时常量)，只能使用等号=。 可使用list或map作为默认值，但必须是const。 int fun([List list = const [1, 2, 3]]) {} 匿名函数 可赋值给变量，通过变量调用 main() { var func = (int a, int b) =&gt; a + b; func(1, 2); } 可在其他函数中直接调用或传递给其他函数 函数别名 函数别名使用typedef表示，如： typedef Fun1(int a, int b); typedef Fun2&lt;T, K&gt;(T a, K b); typedef给函数起一个别名，使用比较方便。例如定义一个方法的回调，直接使用别名定义。 没返回值，则只要参数匹配就行了，如果定义了返回值，则返回值不一样会报错。 main函数 Flutter应用程序必须要有一个main函数作为程序的入口函数。 运算符 Dart所有的运算符如下表所示， 与java不同的有8个，如下： ?.，条件成员访问 和 . 类似，但是左边的操作对象不能为 null，例如 foo?.bar 如果 foo 为 null 则返回 null，否则返回 bar 成员。 ~/，除后取整。 as，类型转换。 is，如果对象是指定类型返回true。 is!，如果对象是指定类型返回false。 ??，双问号左边为true返回左边结果，否则返回右边结果。 ..，级联语法。严格来说， 两个点的级联语法不是一个操作符。 只是一个 Dart 特殊语法。 ??:，如果左边是 null，则右边赋值给左边；如果不是 null，则左边的值保持不变。 描述 操作符 后缀操作 expr++ expr-- () [] . ?. 前缀操作 -expr !expr ~expr ++expr --expr 乘除 * / % ~/ 加减 + - 位移 &lt;&lt; &gt;&gt; 按位与 &amp; 按位异或 ^ 按位或 | 类型操作 &gt;= &gt; &lt;= &lt; as is is! 相等 == != 逻辑与 &amp;&amp; 逻辑或 || 是否为空 ?? 三目运算 expr1 ? expr2 : expr3 级联 .. 赋值 = *= /= ~/= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |= ??= 流程控制语句 Dart中控制流程语句和Java类似。List和Set等实现了Iterable接口的类支持for-in遍历元素。 if else for forEach for-in while do-while break continue switch case assert try-catch throw 异常处理 异常是表示发生意外错误，如果没有捕获异常，引发异常的隔离程序将被挂起，并且程序终止。 Dart代码可抛出并捕获异常，但Dart的所有异常都是未检查异常，方法不声明他们可能抛出的异常,也不需要捕获任何异常。 Dart 代码可以抛出任何非 null 对象为异常，不仅仅是实现了 Exception 或者 Error 的对象。 可以使用on 或者 catch 来声明捕获语句，也可以 同时使用。使用 on 来指定异常类型，使用 catch 来 捕获异常对象。 抛出异常 // 抛出Exception对象 throw FormatException('抛出一个ｆormatException') // 抛出Error对象 throw OutMemoryError(); //或自定义异常 throw '数据非法' 捕获异常 catch() 可以指定一个或两个参数来捕获异常，第一个是抛出的异常，第二个是堆栈跟踪，如： try { ... } on Error catch (e) { // 捕获异常详细信息 } catch (e, s) { // 堆栈跟踪信息 } rethrow 把捕获的异常重新抛出 Finally 面向对象 Dart作为高级语言支持面向对象的很多特性并且支持基于mixin的继承方式。基于mixin的继承方式是值：一个类可以继承多个父类，相当于其他语言里的多继承，所有的类都有同一个基类Object。 实例化成员变量 类定义中所有的变量都会隐式的定义Setter方法，针对非空的变量会额外增加getter方法 构造函数 dart的构造函数有多种形式，如下： 常规构造函数 class User { String name; int age; User(String name, int age) { this.name = name; this.age = age; } // 或 User(this.name, this.age); } 命名的构造函数 class User { String name; int age; User.fromJson(Map json) { name = json['name']; age = json['age']; } } 使用命名构造函数可以为一个类实现多个构造函数， 或者使用命名构造函数来更清晰的表明你的意图。 重定向构造函数 class User { String name; int age; User(this.name, this.age); User.create(String name): this(name,12); } 一个重定向构造函数是没有代码的，在构造函数声明后，使用 冒号调用其他构造函数。 构造函数初始化列表 class User { // final 修饰的成员变量，只能通过构造方法进行赋值 final String name; final int age; // 初始化列表 User(name, age) : name = name, age = age; } 在构造函数体执行之前可以初始化实例参数。 使用逗号分隔初始化表达式。初始化列表非常适合用来设置 final 变量的值。 调用超类构造函数 在构造方法处使用super关键字，如： class User extends Person { // final 修饰的成员变量，只能通过构造方法进行赋值 final String name; final int age; // 初始化列表 User(this.name, this.age):super(name,age); } 常量构造函数 class User { // 定义const构造函数要确保所有的成员变量都是final修饰 final String name; final int age; static final User user = const User('111', 12); // const 关键字放在构造函数名前，且不能有函数体 const User(this.name, this.age); } 工厂构造函数(单例) class User { String name; //工厂构造函数无法访问this，所以这里要用static static User _user; //工厂方法构造函数，关键字factory factory User([String name]) { return User._user ??= User._(name); } //定义一个命名构造函数用来生产实例 User._(this.name); } 读取和写入对象（Getter、Setter） get()和set()方法是专门用于读取和写入对象的属性的方法。 每一个类的实例，系统都隐式地包含有get()和set()方法。 final 修饰的变量没有setter方法。 可以使用get 和 set 关键字定义getter和setter。 class User { String name; User(this.name); String get username =&gt; 'getter ${this.name}'; set username(String name) =&gt; this.name = name; } 重载操作 采用operator修饰，如： class Vector { final int x; final int y; const Vector(this.x, this.y); Vector operator +(Vector v) { return Vector(x + v.x, y + v.y); } } 抽象类 抽象类采用abstract关键字修饰class。f 不能被实例化，除非定义一个工厂构造函数。 抽象类通常用来定义接口， 以及部分实现。 抽象类通常具有抽象方法，抽象方法不需要关键字，以分号结束即可。 接口方式使用时，需要重写抽象类的成员变量和方法，包括私有的。 一个类可以implement一个普通类。Dart任何一个类都是接口。 一个类可以implement多个接口。 可调用类 类实现 call() 方法可以让类像函数一样能够被调用。 class ClassFunction { call(String a, String b, String c) =&gt; '$a, $b, $c'; } main() { var cf = ClassFunction(); var out = cf('a1', 'b1', 'c1'); print('out: $out'); print(cf.runtimeType); print(out.runtimeType); print(cf is Function); } 枚举类 与java一致，采用enum修饰。 enum Type { A, B, C } Mixins Mixins(混入功能)相当于多继承，使用with关键字来实现Mixins的功能 class S { a() =&gt; print('S.a'); } class A { a() =&gt; print('A.a'); b() =&gt; print('A.b'); } class T = A with S; 子类没有重写超类A方法的前提下，如果2个或多个超类拥有相同签名的A方法，那么子类会以继承的最后一个超类中的A方法为准。 如果子类自己重写了A方法则以本身的A方法为准。 泛型 Dart1.21开始可以使用泛型函数。泛型函数可以在以下几个地方使用类型参数： 函数的返回值类型。 参数的类型。 局部变量的类型。 main() { K addCache&lt;K, V&gt;(K key, V value) { K temp = key; print('${key}: ${value}'); return temp; } var key = addCache('key', 'value'); print(key); } 要在使用构造函数时指定一个或多个类型，可将类型放在类名称后面的尖括号&lt;...&gt;中: main() { var p = Phone&lt;String&gt;('123456'); print(p.mobileNumber); } class Phone&lt;T&gt; { final T mobileNumber; Phone(this.mobileNumber); } 实现泛型类型时，您可能希望限制其参数的类型，可以在&lt;&gt;里面使用extends。 main() { var man = Man(); var m = User&lt;Man&gt;(man); m.man.doMassage(); } class User&lt;T extends Man&gt; { final T man; User(this.man); } class Man { void doMassage() {} } 与java一致， 唯一区别：Java泛型是编译时的，在运行时泛型信息会被擦除，Dart的泛型类型是固化的，在运行时也可以判断具体类型。 var names = List&lt;String&gt;(); print(names is List&lt;String&gt;);//true print(names.runtimeType); // List&lt;String&gt; 库的使用 引用库 通过import语句在一个库中引入另一个库文件： 在import语句后面需要接上库文件的路径 对dart语言提供的库文件使用dart:xx格式 第三方的库文件使用package:xx格式 import 'dart:io'; import 'package:mylib/mylib.dart'; import 'package :utils/utils.dart' ; 指定一个库的前缀 当引用的库拥有相互冲突的名字，可以为其中一个或几个指定不一样的前缀。 import 'package:libl/ libl.dart '; import 'package:lib2 / lib2.dart ' as lib2 ; 引用库的一部分 如果只需要使用库的一部分内容，可以有选择性地引用，有如下关键字： show 关键字： 只引用一点 hide 关键字： 除此之外都引用 ／／ 导入 foo import 'package:libl/libl.dart' show foo; ／／ 除了 foo 导入其他所有内容 import 'package:lib2 / lib2.dart' hide foo; 库的延迟载入 使用deferred as导入 使用标识符调用loadLibrary() 加载库 import 'dart:io' deferred as io; lazyLoad() async { //使用 await 关键字暂停代码执行一直到库加载完成。 await io.loadLibrary(); } main() { lazyLoad(); } 优点： 可提高程序启动速度。 用在不常使用的功能。 用在载入时间过长的包。 执行 A/B 测试，例如 尝试各种算法的 不同实现。 异步使用 Dart支持异步操作，一般使用async函数和await表达式实现异步操作，Dart库提供asynchronous功能,该功能提供接口来消耗时间的操作，比如文件读写,网络请求。该功能返回Future或Stream对象。 可以通过如下的方式来获取asynchronous功能返回的Future对象值: 使用async函数和await表达式 使用Future功能提供的API 可以通过如下方式来获取asynchronous功能返回的Stream对象的值: 使用async和一个异步的循环(await for) 使用Stream的相关API async / await await关键字必须在async函数内部使用，await表达式可以使用多次 void main(){ getName1(); getName2(); getName3(); } Future getName1() async { await getStr1(); await getStr2(); print('getName1’); } getStr1() { print('getStr1’); } getStr2() { print('getStr2’); } getName2() { print('getName2’); } getName3() { print('getName3’); } /// 输出结果： getStr1 getName2 getName3 getStr2 getName1 then,catchError,whenComplete 如果需要监听“完毕”这个状态，那么用whenComplete，需要监听“成功”这个状态，用then，需要监听“失败”这个状态，用catchError。 如果重写了test方法，test返回true就可以在catchError的onError方法里捕获到异常，如果test返回false，就把该异常继续抛出而不会在catchError方法里被捕获，如果不写test默认实现一个返回true的test方法 void main() { Future(() =&gt; futureTask()) //异步任务的函数 .then((m) =&gt; &quot;result:$m&quot;) //任务执行完后的子任务 .then((m) =&gt; m.length) //其中m为上个任务执行完后的返回的结果 .then((m) =&gt; printLength(m)) .catchError(print) // 拦截错误，如果实现了test方法，只有return true时才会拦截，否则不会 .whenComplete(() =&gt; whenTaskCompelete()); //所有任务完成后的回调函数 } whenTaskCompelete() { print('task complete'); } futureTask() async { return 'future'; } printLength(dynamic name) { if (name is! String || name.length &lt; 3 || name.length &gt; 15) { throw '长度错误'; } } Event-Looper 一个消息循环的职责就是不断从消息队列中取出消息并处理他们直到消息队列为空。 消息队列中的消息可能来自用户输入，文件I/O消息，定时器等。例如上图的消息队列就包含了定时器消息和用户输入消息。 Dart中的Main Isolate只有一个Event Looper，但是存在两个Event Queue: Event Queue以及Microtask Queue。 Event Queue和Microtask Queue 优先全部执行完Microtask Queue中的Event。 直到Microtask Queue为空时，才会执行Event Queue中的Event。 当Event Looper正在处理Microtask Queue中的Event时候，Event Queue中的Event就停止了处理了，此时App不能绘制任何图形，不能处理任何鼠标点击，不能处理文件IO等等。 绘制图形，处理鼠标点击，处理文件IO等都是在Event Queue里完成的。 任务调度 使用Future类，可以将任务加入到Event Queue的队尾 使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾 优先全部执行完Microtask Queue中的Event，直到Microtask Queue为空时，才会执行Event Queue中的Event。 Future 使用 Future（）将任务加入event队列。 Future中的then并没有创建新的Event丢到Event Queue中，而只是一个普通的Function Call，在FutureTask执行完后，立即开始执行。 如果在then()调用之前Future就已经执行完毕了，那么任务会被加入到microtask队列中，并且该任务会执行then()中注册的回调函数。 使用Future.value构造函数的时候，就会上一条一样，创建Task丢到microtask Queue中执行then传入的函数。 Future.sync构造函数执行了它传入的函数之后，也会立即创建Task丢到microtask Queue中执行。 当任务需要延迟执行时，可以使用new Future.delay()来将任务延迟执行。 void main(){ testFuture(); } void testFuture() { Future f = new Future(() =&gt; print('f1')); Future f1 = new Future(() =&gt; null); //Future f1 = new Future.delayed(Duration(seconds: 1) ,() =&gt; null); Future f2 = new Future(() =&gt; null); Future f3 = new Future(() =&gt; null); f3.then((_) =&gt; print('f2')); f2.then((_) { print('f3'); new Future(() =&gt; print('f4')); f1.then((_) { print('f5'); }); }); f1.then((m) { print('f6'); }); print('f7'); } scheduleMicrotask() 如果可以，尽量将任务放入event队列中。 使用Future的then方法或whenComplete方法来指定任务顺序。 为了保持你app的可响应性，尽量不要将大计算量的任务放入这两个队列。 大计算量的任务放入额外的isolate中。 import 'dart:async'; void main(){ testScheduleMicrotask(); } void testScheduleMicrotask(){ scheduleMicrotask(() =&gt; print('s1')); new Future.delayed(new Duration(seconds: 1), () =&gt; print('s2')); new Future(() =&gt; print('s3')).then((_) { print('s4'); scheduleMicrotask(() =&gt; print('s5')); }).then((_) =&gt; print('s6')); new Future(() =&gt; print('s7')); scheduleMicrotask(() =&gt; print('s8')); print('s9'); } 隔离（isolate） 所有Dart代码都在隔离区内运行，而不是线程。每个隔离区都有自己的内存堆，确保不会从任何其他隔离区访问隔离区的状态。 Dart没有共享内存的并发，没有竞争的可能性所以不需要锁，也就不用担心死锁的问题。 isolate之间没有共享内存，所以他们之间的通信唯一方式只能是通过Port进行，而且Dart中的消息传递总是异步的。 isolate神似Thread，但实际上两者有本质的区别。操作系统内的线程之间是可以有共享内存的而isolate没有，这是最为关键的区别。 元数据 使用元数据给代码添加更多的信息。元数据是以＠开始的修饰符，在＠后面接着编译时的常量或者一个常量构造函数。 @deprecated 被弃用 @override 重写 @proxy 代理 元数据可以修饰 library、class、typedef、type parameter、constructor、factory、function、field、parameter、variable declaration。 注释 单行注释以//开头。Dart编译器会忽略//和行尾之间的所有内容。 // 这是单行注释 多行注释以/开头，以/结尾。介于/*和 */两者之间的内容会被编译器忽略（除非该注释是一个文档注释)。 /* * 这是多行注释 * 这是多行注释 */ 多行注释可以嵌套 文档注释以///或者/**开头。可以通过dartdoc命令导出文档。 /// 这是文档注释 /** * 这是文档注释 */ ","link":"https://www.xiaowujiang.cn/posts/b8c700d2/"},{"title":"Java高级语言特性","content":"Java知识是作为Android开发的语言基础，虽然现在我们已经推出了kotlin，但是基于以下原因我们还是需要好好牢牢掌握java： 1）SDK还是改成java，kotlin也需要编译成为java运行； 2）目前大量的第三方库和继承与前任的代码都是java所写的； 3）Java语言应用不仅仅在Android，就是在后台开发中也是一个最流行的语言； 4）大公司面试都要求我们有扎实的Java语言基础。所以，请大家不要轻视提高自己Java基础的机会，请大家认真学习，做好笔记，争取取得更大的进步。 Java中的泛型 为什么我们需要泛型? 我们有如下两个场景： 场景一： 实际开发中，经常有数值类型求和的需求，例如实现int类型的加法, 有时候还需要实现long类型的求和, 如果还需要double类型的求和，需要重新在重载一个输入是double类型的add方法。 public int addInt(int x, int y) { return x + y; } public float addFloat(float x, float y) { return x + y; } 场景二 定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现错误。因为编译阶段正常，而运行时会出现 ClassCastException 异常。因此，导致此类错误编码过程中不易发现。 public class NonGeneric2 { public static void main(String[] args) { List list = new ArrayList(); list.add(&quot;字符串&quot;); list.add(&quot;string&quot;); list.add(12); for (int i = 0; i &lt; list.size(); i++) { String name = (String) list.get(i); System.out.println(&quot;name: &quot; + name); } } } 在如上的编码过程中，我们发现主要存在两个问题： ​ 1. 当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。 因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。 所以泛型的好处就是： 适用于多种数据类型执行相同的代码； 泛型中的类型在使用时指定，不需要强制类型转换。 泛型类和泛型接口 泛型，即“参数化类型”，就是将类型由原来的具体类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 引入一个类型变量 T（其他大写字母都可以，不过常用的就是T，E，K，V等），并且用&lt;&gt;括起来，并放在类名的后面。泛型类是允许有多个类型变量的。 // 单个泛型类型参数 public class NormalGeneric&lt;T&gt; { private T data; public NormalGeneric(T t) { this.data = t; } } // 多个泛型类型参数 public class NormalGeneric2&lt;T, K&gt; { private T data; private K result; public NormalGeneric2(T t, K k) { this.data = t; this.result = k; } } 泛型接口与泛型类的定义基本相同。 public interface Generator&lt;T&gt; { public T next(); } 而实现泛型接口的类，有两种实现方法： 未传入泛型实参时: public class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt; { private T data; public GeneratorImpl(T data) { this.data = data; } @Override public T next() { return data; } } 在new出类的实例时，需要指定具体类型： public static void main(String[] args) { Generator&lt;String&gt; generator = new GeneratorImpl&lt;&gt;(&quot;impl&quot;); System.out.println(generator.next()); } 传入泛型实参 public class GeneratorImpl2 implements Generator&lt;String&gt; { @Override public String next() { return &quot;ok&quot;; } } 在new出类的实例时，和普通的类没区别。 泛型方法 public class GeneratorMethod { // 泛型方法 public &lt;T&gt; T generatorMethod(T... a) { return a[a.length / 2]; } public static void main(String[] args) { GeneratorMethod generatorMethod = new GeneratorMethod(); System.out.println(generatorMethod.generatorMethod(1, 2)); System.out.println(generatorMethod.generatorMethod(&quot;1&quot;, &quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;)); } } 泛型方法，是在调用方法的时候指明泛型的具体类型 ，泛型方法可以在任何地方和任何场景中使用，包括普通类和泛型类。注意泛型类中定义的普通方法和泛型方法的区别。 普通方法： public class Generic&lt;T&gt; { private T data; public Generic(T t) { this.data = t; } // 此方法是普通方法，不是泛型方法 public T getData() { return data; } } 泛型方法 public &lt;T&gt; T showKeyName(Generic&lt;T&gt; generic) { System.out.println(&quot;data: &quot; + generic.getData()); return generic.getData(); } 限定类型变量 有时候，我们需要对类型变量加以约束，比如计算两个变量的最小，最大值。 public static &lt;T&gt; T min(T a, T b) { return a.compareTo(b) &gt; 0 ? a : b; } 请问，如果确保传入的两个变量一定有compareTo方法？那么解决这个问题的方案就是将T限制为实现了接口Comparable的类 public static &lt;T extends Comparable&gt; T min(T a, T b) { return a.compareTo(b) &gt; 0 ? a : b; } T extends Comparable 中 T 表示应该绑定类型的子类型，Comparable 表示绑定类型，子类型和绑定类型可以是类也可以是接口。 如果这个时候，我们试图传入一个没有实现接口Comparable的类的实例，将会发生编译错误。 public static void main(String[] args) { System.out.println(min(1, 2)); System.out.println(min(&quot;aaaa&quot;, &quot;bbbb&quot;)); // 下面是编译会报错 System.out.println(min(new GeneratorImpl2(), new GeneratorImpl2())); } 同时extends左右都允许有多个，如T,V extends Comparable &amp; Serializable 注意限定类型中，只允许有一个类，而且如果有类，这个类必须是限定列表的第一个。 这种类的限定既可以用在泛型方法上也可以用在泛型类上。 泛型中的约束和局限性 现在我们有泛型类 public class Restrict&lt;T&gt; {} 不能用基本类型实例化类型参数 // 编译报错 Restrict&lt;int&gt; restrict = new Restrict&lt;&gt;(); 运行时类型检查只适用于原始类型 Restrict&lt;Boolean&gt; restrict = new Restrict&lt;&gt;(); Restrict&lt;String&gt; stringRestrict = new Restrict&lt;&gt;(); // 这种操作不被允许，编译时报错 //if (restrict instanceof Restrict&lt;Boolean&gt;) {} // 这种操作不被允许，编译时报错 //if (restrict instanceof Restrict&lt;T&gt;) {} System.out.println(restrict.getClass() == stringRestrict.getClass()); System.out.println(restrict.getClass().getName()); 泛型类的静态上下文中类型变量失效 // 静态域或方法里不能引用类型变量 // protected static T instance; 不能在静态域或方法中引用类型变量。因为泛型是要在对象创建时才知道具体类型，而对象创建的代码执行先后顺序是static的部分，然后才是构造函数等。所以在对象初始化之前static的部分已经执行了，如果你在静态部分引用的泛型，那么毫无疑问虚拟机根本不知道是什么东西，因为这个时候类还没有初始化。 不能创建参数化类型的数组 Restrict&lt;Double&gt;[] restricts; // 可以 // Restrict&lt;Double&gt;[] doubleRestricts = new Restrict&lt;Double&gt;[10]; // 不允许 不能实例化类型变量 private Restrict() { // 不能实例化类型变量 // this.data = new T(); } 不能捕获泛型类的实例 // 泛型类不能继承Exception/Throwable // public class Problem&lt;T&gt; extends Exception{} // 不能捕获泛型类对象 // public &lt;T extends Throwable&gt; void doWork(T t) { // try { // } catch (T e) { // } // } 但是这样可以： public &lt;T extends Throwable&gt; void doWork(T t) throws T { try { } catch (Throwable e) { throw t; } } 泛型类型的继承规则 现在我们有一个类、子类和泛型类 public class Employee {} public class Worker extends Employee {} public class Pair&lt;T&gt; {} 那么Pair&lt;Employee&gt;和Pair&lt;Worker&gt;是没有任何关系的： Employee employee = new Worker(); // 编译报错 // Pair&lt;Employee&gt; employeePair = new Pair&lt;Worker&gt;(); 但是泛型类可以继承或者扩展其他泛型类，比如List和ArrayList public class ExtendPair&lt;T&gt; extends Pair&lt;T&gt; {} // 允许 Pair&lt;Employee&gt; employeePair = new ExtendPair&lt;&gt;(); 通配符类型 正是因为前面所述的，Pair&lt;Employee&gt;和Pair&lt;Worker&gt;没有任何关系，如果我们有一个泛型类和一个方法 public static void print(GenericType&lt;Fruit&gt; p) { System.out.println(p.getData().getColor()); } public class GenericType&lt;T&gt; {} 现在我们有继承关系的类: public class Fruit { } public class Orange extends Fruit {} public class Apple extends Fruit {} public class HongFuShi extends Apple {} 则会产生这种情况： public static void main(String[] args) { GenericType&lt;Fruit&gt; fruitGenericType = new GenericType&lt;&gt;(); print(fruitGenericType); GenericType&lt;Orange&gt; orangeGenericType = new GenericType&lt;&gt;(); // print(orangeGenericType); // 此处不被允许，编译报错 } 为解决这个问题，于是提出了一个通配符类型 ? 有两种使用方式： ？ extends X 表示类型的上界，类型参数是X的子类 ？ super X 表示类型的下界，类型参数是X的超类 这两种 方式从名字上来看，特别是super，很有迷惑性，下面我们来仔细辨析这两种方法。 ？ extends X 表示传递给方法的参数，必须是X的子类（包括X本身） public static void print2(GenericType&lt;? extends Fruit&gt; p) { System.out.println(p.getData().getColor()); } public static void main(String[] args) { GenericType&lt;Fruit&gt; fruitGenericType = new GenericType&lt;&gt;(); print2(fruitGenericType); GenericType&lt;Orange&gt; orangeGenericType = new GenericType&lt;&gt;(); print2(orangeGenericType); } 但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法是不允许被调用的，会出现编译错误 public class GenericType&lt;T&gt; { private T data; public T getData() { return data; } public void setData(T data) { this.data = data; } public static void main(String[] args) { GenericType&lt;? extends Fruit&gt; fruitGenericType = new GenericType&lt;&gt;(); Apple apple = new Apple(); // 这样不被允许 fruitGenericType.setData(apple); // 这样是可以的 Fruit fruit = fruitGenericType.getData(); } } get方法则没问题，会返回一个Fruit类型的值。 这是因为？ extends X 表示类型的上界，类型参数是X的子类，那么可以肯定的说，get方法返回的一定是个X（不管是X或者X的子类）编译器是可以确定知道的。但是set方法只知道传入的是个X，至于具体是X的那个子类，不知道。 总结：主要用于安全地访问数据，可以访问X及其子类型，并且不能写入非null的数据。 ？ super X 表示传递给方法的参数，必须是X的超类（包括X本身） public static void printSuper(GenericType&lt;? super Apple&gt; p) { System.out.println(p.getData()); } public static void main(String[] args) { GenericType&lt;Fruit&gt; fruitGenericType = new GenericType&lt;&gt;(); GenericType&lt;Orange&gt; orangeGenericType = new GenericType&lt;&gt;(); GenericType&lt;Apple&gt; appleGenericType = new GenericType&lt;&gt;(); GenericType&lt;HongFuShi&gt; shiGenericType = new GenericType&lt;&gt;(); printSuper(fruitGenericType); printSuper(appleGenericType); // 编译出错 printSuper(orangeGenericType); // 编译出错 printSuper(shiGenericType); } 但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法可以被调用的，且能传入的参数只能是X或者X的子类 public class GenericType&lt;T&gt; { private T data; public T getData() { return data; } public void setData(T data) { this.data = data; } public static void main(String[] args) { GenericType&lt;? super Apple&gt; fruitGenericType = new GenericType&lt;&gt;(); fruitGenericType.setData(new Apple()); fruitGenericType.setData(new HongFuShi()); // 此操作不被允许 fruitGenericType.setData(new Orange()); // 此操作不被允许 fruitGenericType.setData(new Fruit()); Object object = fruitGenericType.getData(); } } get方法只会返回一个Object类型的值。 这是因为，？ super X 表示类型的下界，类型参数是X的超类（包括X本身），那么可以肯定的说，get方法返回的一定是个X的超类，那么到底是哪个超类？不知道，但是可以肯定的说，Object一定是它的超类，所以get方法返回Object。编译器是可以确定知道的。对于set方法来说，编译器不知道它需要的确切类型，但是X和X的子类可以安全的转型为X。 总结：主要用于安全地写入数据，可以写入X及其子类型。 无限定的通配符 ? 表示对类型没有什么限制，可以把？看成所有类型的父类，如Pair&lt; ?&gt;； 比如： ArrayList&lt;T&gt; al=new ArrayList&lt;T&gt;(); 指定集合元素只能是T类型 ArrayList&lt;?&gt; al=new ArrayList&lt;?&gt;();集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法。 在使用上： ？ getFirst() ： 返回值只能赋给 Object，； void setFirst(?) ： setFirst 方法不能被调用， 甚至不能用 Object 调用； 虚拟机是如何实现泛型的？ 泛型思想早在C++语言的模板（Template）中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。由于Java语言里面所有的类型都继承于java.lang.Object，所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期之中。 泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List＜int＞与List＜String＞就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。 Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜Integer＞与ArrayList＜String＞就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。 通过反射获取泛型信息 由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。因此，JCP组织对虚拟机规范做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[3]，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。 另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。 反射原理及动态代理模式 反射（Reflect） 反射之中包含了一个「反」字，所以了解反射我们先从「正」开始。 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。 反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用new 关键字来创建对象了。这时候，我们使用 JDK 提供的反射 API 进行反射调用。反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。 Java反射机制主要提供了以下功能： 在运行时构造任意一个类的对象 在运行时获取任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法（属性） Java 是一门面向对象的语言。在面向对象的世界里，万事万物皆对象，既然万事万物皆对象，那么我们的类是不是对象呢？我们写的每一个类都可以看成一个对象，是java.lang.Class 类的对象。每一个类对应的Class放在哪里呢？当我们写完一个类的Java文件，编译成class文件的时候，编译器都会将这个类的对应的class对象放在class文件的末尾。里面都保存了些什么？大家可以理解保存了类的元数据信息，一个类的元数据信息包括什么？有哪些属性，方法，构造器，实现了哪些接口等等，那么这些信息在Java里都有对应的类来表示。 Class类 Class是一个类，封装了当前对象所对应的类的信息 一个类中有属性，方法，构造器等，比如说有一个Person类，一个Order类，一个Book类，这些都是不同的类，现在需要一个类，用来描述类，这就是Class，它应该有类名，属性，方法，构造器等。Class是用来描述类的类。 Class类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等 对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个Class实例 获取Class对象的三种方式 1.通过类名获取 类名.class 2.通过对象获取 对象名.getClass() 3.通过全类名获取 Class.forName(全类名) Class类的常用方法 方法名 功能说明 static Class&lt;?&gt; forName(String className) 返回指定类名name的class public T newInstance() 调用缺省构造函数，返回该class对象的一个实例 public T newInstance(Object ... initargs) 返回当前格式构造函数，返回该Class对象的一个实例 getName() 返回此Class对象所标识的实体（类，接口，数组类，基本类型或void）名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class[] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 代理模式和静态代理 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 目的：（1）通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性； （2）通过代理对象对原有的业务增强； 代理模式一般会有三个角色： 抽象角色：指代理角色和真实角色对外提供的公共方法，一般为一个接口 真实角色：需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业务逻辑在此。 代理角色：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。将统一的流程控制都放到代理角色中处理！ 而访问者不再访问真实角色，而是去访问代理角色。 静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。一般来说，被代理对象和代理对象是一对一的关系，当然一个代理对象对应多个被代理对象也是可以的。 静态代理，一对一则会出现时静态代理对象量多、代码量大，从而导致代码复杂，可维护性差的问题，一对多则代理对象会出现扩展能力差的问题。 动态代理 是指在使用时再创建代理类和实例 优点 只需要1个动态代理类就可以解决创建多个静态代理的问题，避免重复、多余代码 更强的灵活性 缺点 效率低，相比静态代理中 直接调用目标对象方法，动态代理则需要先通过Java反射机制 从而 间接调用目标对象方法 应用场景局限，因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），即只能针对接口 创建 代理类，不能针对类创建代理类。 在java的动态代理机制中，有两个重要的类或接口，一个是InvocationHandler接口、另一个则是 Proxy类，这个类和接口是实现我们动态代理所必须用到的。 InvocationHandler接口是给动态代理类实现的，负责处理被代理对象的操作的，而Proxy是用来创建动态代理类实例对象的，因为只有得到了这个对象我们才能调用那些需要代理的方法。 动态代理用例： public static void main(String[] args) { // 真实对象 HuaWeiFactory huaWeiFactory = new HuaWeiFactory(); // 根据真实对象动态生成的代理对象 PhoneFactory instance = (PhoneFactory) Proxy.newProxyInstance(huaWeiFactory.getClass().getClassLoader(), huaWeiFactory.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] objects) throws Throwable { if (method.getName().equals(&quot;productPhone&quot;)) { System.out.println(&quot;拦截到方法了.........&quot;); return method.invoke(huaWeiFactory, objects); } return method.invoke(huaWeiFactory, objects); } }); instance.productPhone(&quot;哈哈哈&quot;); } 动态代理实现原理 观察Proxy.newProxyInstance方法，与创建对象有关的代码主要有： 获得代理类的class对象： /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); 获得代理类的构造器： final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); 创建代理类的实例 return cons.newInstance(new Object[]{h}); 看来其中的关键点就是如何获得代理类的class对象，我们进入**getProxyClass0方法，进而进入proxyClassCache.get**方法，通过这个方法所在的类名，我们可以推测，JDK内部使用了某种机制缓存了我们的代理类的class对象，同时get方法接受的参数是被代理类的类加载器和类实现的的接口。 然后我们查看proxyClassCache的初始化的方法： private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); 查看ProxyClassFactory类： /** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */ private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; { ... @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) { ... /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); // 生成代理类名称 String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ // 生成代理类 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try { return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); } catch (ClassFormatError e) { throw new IllegalArgumentException(e.toString()); } } } 而最终生成代理类的class对象是defineClass0方法，但是这个方法是个native方法，所以我们不去也无法深究它，但是通过这个方法的参数我们可以明显看到它接收了上面所生成的byte数组。 而我们通过ProxyUtils，这个自己写的工具类，将这个byte数组写入文件，我们并反编译，我们将会看到 public static void generateClassFile(Class originClazz, Class clazz, String proxyName) { byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, clazz.getInterfaces()); String path = originClazz.getResource(&quot;.&quot;).getPath(); System.out.println(&quot;resource path: &quot; + path); try (FileOutputStream outputStream = new FileOutputStream(path + File.separator + proxyName + &quot;.class&quot;)) { outputStream.write(proxyClassFile); outputStream.flush(); } catch (IOException e) { e.printStackTrace(); } } 同时我们还会看到其中实现了业务接口的方法 而h则来自派生类Proxy中 这个h的实例来自哪里？不就是我们在创建代理类的实例时传入的吗？ 使用了动态代理的Retrofit Retrofit简单的说就是一个网络请求的适配器，它将一个基本的Java接口通过动态代理的方式翻译成一个HTTP请求，并通过OkHttp去发送请求。此外它还具有强大的可扩展性，支持各种格式转换以及RxJava。我们基于Retrofit2解析。 先定义一个名为X的java接口，当然里面有各种注解。 @FormUrlEncoded注解表示from表单，另外还有@Multipart等注解。@POST表示post请求，此外还可以使用@GET请求 然后如何使用的呢？ 首先将域名传入构造一个Retrofit，然后通过retrofit中的create方法传入一个Java接口并得到一个x(当然x这个对象是经过处理了的)调用getPersonalListInfo(12)然后返回一个Call，最后这个Call调用了enqueue方法去异步请求http，这就是一个基本的Retrofit的网络请求。Retrofit2中Call接口的默认实现是OkHttpCall，它默认使用OkHttp3作为底层http请求client。 我们只定义了一个接口X，并没有实现这个接口，那么它是如何工作的呢？我们看看create方法的实现。 create()方法是个泛型方法，调用它时会返回一个范型T的对象，我们这里类型是X接口，在内部实现上，很明显了使用了动态代理返回了一个X的代理类。当调用X内部方法的时候，会调用invoke方法。invoke方法内则通过内部一系列的封装最后返回一个Call对象。 多线程与Android线程性能优化 基础概念 CPU核心数和线程数的关系 多核心: 也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理 多线程: Simultaneous Multithreading.简称SMT.SMT可通过复制处理器上的结构状态,让同一个处理器上的多个线程同步执行并共享处理器的执行资源可最大限度地实现宽发射、乱序的超标量处理,提高处理器运算部件的利用率,缓和由于数据相关或 Cache未命中带来的访问内存延时。 核心数、线程数:目前主流CPU有双核、三核和四核,六核也在2010年发布。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系 CPU时间片轮转机制 我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。 时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。 百度百科对CPU时间片轮转机制原理解释如下: 如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾。 时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。 为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发 结论可以归结如下: 时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。 在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KⅢ掉的,我想也正是因为这种机制的缘故。 什么是进程和线程 进程是程序运行资源分配的最小单位 进程是操作系统进行资源分配的最小单位, 其中资源包括:CPU、内存空间、磁盘10等, 同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。 线程是CPU调度的最小单位,必须依赖于进程而存在 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 线程无处不在 任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。 澄清并行和并发 我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的并行车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。 当谈论并发的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。 俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。 综合来说： 并发: 指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到&quot;同时执行效果&quot;,其实并不是的,只是计算机的速度太快,我们无法察觉到而已. 并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行 两者区别:一个是交替执行,一个是同时执行. 高并发编程的意义、好处和注意事项 由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。 (1) 充分利用CPU的资源 从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。 (2) 加快响应用户的时间 我们在做程序开发的时候, 特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。 (3) 可以使你的代码模块化,异步化,简单化 例如我们在做 Android程序开发的时候,主线程的UI展示部分是一块主代码程序部分,但是UI上的按钮用相应事件的处理程序就可以做个单独的模块程序拿出来。这样既增加了异步的操,又使程序模块化,清晰化和简单化。 时下最流行的异步程序处理机制,正是多线程、并发程序最好的应用例子。 多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。 多线程程序需要注意事项 (1) 线程之间的安全性 从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。 (2) 线程之间的死循环过程 为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。 假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生 (3) 线程太多了会将服务器资源耗尽形成死机当机 线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢? 某些系统资源是有限的, 如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。 认识Java里的线程 Java里的程序天生就是多线程的 一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。 通过以下代码可以查看当前存在的线程： ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); for (ThreadInfo threadInfo : threadInfos) { System.out.println(threadInfo.getThreadName()); } [6] Monitor Ctrl-Break //监控Ctrl-Break中断信号的 [5] Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等 [4] Signal Dispatcher // 分发处理发送给JVM信号的线程 [3] Finalizer // 调用对象finalize方法的线程 [2] Reference Handler//清除Reference的线程 [1] main //main线程，用户程序入口 线程的启动与中止 线程的启动 启动线程的方式有： 1、X extends Thread，然后 X.run 2、X implements Runnable， 然后交给 Thread运行 3、X implements Callable，然后交给Thread运行 第1、2方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。 Callable、Future和FutureTask Runnable是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。 Callable 位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()，这是一个泛型接口，call() 函数返回的类型就是传递进来的 V 类型。 Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。 因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {} public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {} FutureTask 类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 事实上，FutureTask是Future接口的一个唯一实现类。 要new一个FutureTask的实例，有两种方法 public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable } public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable } 中止 线程自然终止：要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。 手动中止 暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()。但是这些API是过期的，也就是不建议使用的。不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。 安全的中止则是其他线程通过调用某个线程A的**interrupt()方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()**来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。 如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。 不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，一、一般的阻塞方法，如sleep等本身就支持中断的检查，二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。 注意：处于死锁状态的线程无法被中断 对Java里的线程再多一点点认识 深入理解run()和start() Thread 类是Java里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。 start()方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用。 而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，可以被单独调用。 其他的线程方法 yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行。 join方法：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。 wait()/notify()/notifyAll()：后面会单独讲述 线程间的共享和协作 线程间的共享 线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。 Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。 对象锁和类锁： 对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。 但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。 线程间的协作 线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。却存在如下问题： 1）难以确保及时性。 2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。 等待/通知机制 是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。 notify()： 通知一个在对象上等待的线程,使其从wait方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING状态。 notifyAll()： 通知所有等待在该对象上的线程 wait(): 调用该方法的线程进入WAITING状态,只有等待另外线程的通知或被中断才会返回.需要注意,调用wait()方法后,会释放对象的锁 wait(long): 超时等待一段时间, 这里的参数时间是毫秒, 也就是等待长达n毫秒, 如果没有通知就超时返回 wait (long,int): 对于超时时间更细粒度的控制,可以达到纳秒 等待和通知的标准范式 等待方遵循如下原则。 1）获取对象的锁。 2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。 3）条件满足则执行对应的逻辑。 syncronized(对象){// 不能是Class对象 while(条件不满足){ 对象.wait() } 对应的逻辑处理 } 通知方遵循如下原则。 1）获得对象的锁。 2）改变条件。 3）通知所有等待在对象上的线程。 syncronized(对象) { // 不能是Class对象 改变条件 对象.notifyAll() } 在调用wait() 之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法，进入wait（）方法后，当前线程释放锁，在从wait（）返回前，线程与其他线程竞争重新获得锁，notifyAll方法一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 notify和notifyAll应该用谁 尽可能用notifyall()，谨慎使用notify()。 public class Express { private int km;/*快递运输里程数*/ public Express(int km) { this.km = km; } /* 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理*/ public synchronized void changeKm(){ this.km = 101; notify(); } public synchronized void waitKm(){ while(this.km&lt;100){ try { wait(); System.out.println(&quot;check km thread[&quot; +Thread.currentThread().getName()+&quot;] is be notifyed&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;the km is&quot;+this.km+&quot;,I will change db.&quot;); } } public class TestCond { private static ExpressCond express = new ExpressCond(0); /*检查里程数变化的线程,不满足条件，线程一直等待*/ private static class CheckKm extends Thread{ @Override public void run() { express.waitKm(); } } public static void main(String[] args) throws InterruptedException { for(int i=0;i&lt;3;i++){ new CheckKm().start(); } Thread.sleep(1000); express.changeKm();//快递里程变化 } } ThreadLocal ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值, ThreadLocal往往用来实现变量在线程之间的隔离。 ThreadLocal类接口很简单，只有4个方法，我们先来了解一下： • void set(Object value) 设置当前线程的线程局部变量的值。 • public Object get() 该方法返回当前线程所对应的线程局部变量。 • public void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 • protected Object initialValue() 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。 public final static ThreadLocal RESOURCE = new ThreadLocal();RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。 显式锁 Lock接口和synchronized的比较 我们一般的Java程序是靠synchronized关键字实现锁功能的，使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。synchronized属于Java语言层面的锁，也被称之为内置锁。 synchronized这种机制，一旦开始获取锁，是不能中断的，也不提供尝试获取锁的机制。 而Lock是由Java在语法层面提供的，锁的获取和释放需要我们明显的去获取，因此被称为显式锁。并且提供了synchronized不提供的机制。 Lock接口和核心方法 在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。 lock.lock(); try { // TODO doSomething } finally { lock.unlock(); } 可重入锁ReentrantLock、所谓锁的公平和非公平 synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。ReentrantLock在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。 **公平和非公平锁 ** 如果在时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。 ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高。原因是，在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程A持有一个锁, 并且线程B请求这个锁。由于这个锁已被线程A持有,因此B将被挂起。当A释放锁时,B将被唤醒,因此会再次尝试获取锁。与此同时,如果C也请求这个锁,那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面:B获得锁的时刻并没有推迟,C更早地获得了锁,并且吞吐量也获得了提高。 读写锁ReentrantReadWriteLock 之前提到锁（synchronized和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。 除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。 一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量 Condition接口 任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。 用Lock和Condition实现等待通知 private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void conditionWait() { lock.lock(); try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void conditionSingle() { lock.lock(); try { condition.signal(); } finally { lock.unlock(); } } 线程池原理与AsyncTask 什么是线程池？为什么要用线程池? Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。线程池就是将线程进行池化，需要运行任务时从池中拿一个线程来执行，执行完毕，线程放回池中。 在开发过程中，合理地使用线程池能够带来3个好处。 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。 如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 JDK中的线程池和工作机制 线程池的创建各个参数含义 public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) corePoolSize 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize； 如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行； 如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize keepAliveTime 线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用 TimeUnit keepAliveTime的时间单位 workQueue workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能 什么是阻塞队列 队列： 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。 阻塞队列： 1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。 2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。 抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（&quot;Queuefull&quot;）异常。当队列为空时，从队列里获取元素会抛出NoSuchElementException异常。 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。 一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。 超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。 常用阻塞队列 ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 threadFactory 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字” RejectedExecutionHandler（饱和策略） 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略： （1）AbortPolicy：直接抛出异常，默认策略； （2）CallerRunsPolicy：用调用者所在的线程来执行任务； （3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； （4）DiscardPolicy：直接丢弃任务； 当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。 线程池的工作机制 1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。 2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。 3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。 合理配置线程池 要想合理地配置线程池，就必须首先分析任务特性 要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 任务的优先级：高、中和低。 任务的执行时间：长、中和短。 任务的依赖性：是否依赖其他系统资源，如数据库连接。 性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 AsyncTask 为什么需要AsyncTask？ 在Android当中，当一个应用程序的组件启动的时候，并且没有其他的应用程序组件在运行时，Android系统就会为该应用程序组件开辟一个新的线程来执行。默认的情况下，在一个相同Android应用程序当中，其里面的组件都是运行在同一个线程里面的，这个线程我们称之为Main线程。当我们通过某个组件来启动另一个组件的时候，这个时候默认都是在同一个线程当中完成的。 在Android当中，通常将线程分为两种，一种叫做Main Thread，除了Main Thread之外的线程都可称为Worker Thread。 当一个应用程序运行的时候，Android操作系统就会给该应用程序启动一个线程，这个线程就是我们的Main Thread，这个线程非常的重要，它主要用来加载我们的UI界面，完成系统和我们用户之间的交互，并将交互后的结果又展示给我们用户，所以Main Thread又被称为UI Thread。 Android系统默认不会给我们的应用程序组件创建一个额外的线程，所有的这些组件默认都是在同一个线程中运行。然而，某些时候当我们的应用程序需要完成一个耗时的操作的时候，例如访问网络或者是对数据库进行查询时，此时我们的UI Thread就会被阻塞。例如，当我们点击一个Button，然后希望其从网络中获取一些数据，如果此操作在UI Thread当中完成的话，当我们点击Button的时候，UI线程就会处于阻塞的状态，此时，我们的系统不会调度任何其它的事件，更糟糕的是，当我们的整个现场如果阻塞时间超过5秒钟(官方是这样说的)，这个时候就会出现 ANR (Application Not Responding)的现象，此时，应用程序会弹出一个框，让用户选择是否退出该程序。对于Android开发来说，出现ANR的现象是绝对不能被允许的。 另外，由于我们的Android UI控件是线程不安全的，所以我们不能在UI Thread之外的线程当中对我们的UI控件进行操作。因此在Android的多线程编程当中，我们有两条非常重要的原则必须要遵守： 绝对不能在UI Thread当中进行耗时的操作，不能阻塞我们的UI Thread 不能在UI Thread之外的线程当中操纵我们的UI元素 既然在Android当中有两条重要的原则要遵守，那么我们可能就有疑问了？我们既不能在主线程当中处理耗时的操作，又不能在工作线程中来访问我们的UI控件，那么我们比如从网络中要下载一张图片，又怎么能将其更新到UI控件上呢？这就关系到了我们的主线程和工作线程之间的通信问题了。在Android当中，提供了两种方式来解决线程直接的通信问题，一种是通过Handler的机制，这个时候就很可能自己会去封装一下thread+handler了，正是因为这类需求很多，google就帮我们封装了一下。其实我们也可以自己封装，但是我相信99%程序员自己封装的东西比不上google的。所以另外一种就是今天要详细讲解的 AsyncTask 机制。 原理分析 AsyncTask是个abstract类，所以在使用时需要实现一个AsyncTask的具体实现类，一般来说会覆盖4个方法，我们以前面所说的从网络中下载一张图片，然后更新到UI控件来说明： （1）onPreExecute()：在执行后台下载操作之前调用，将下载等待动画显示出来，运行在主线程中； （2）doInBackground()：核心方法，执行后台下载操作的方法，必须实现的一个方法，运行在子线程中；这个方法是执行在子线程中的。在onPreExecute()执行完后，会立即开启这个方法。 （3）onProgressUpdate()：在下载操作doInBackground()中调用publishProgress()时的回调方法，用于更新下载进度，运行在主线程中； （4）onPostExecute()：后台下载操作完成后调用，将下载等待动画进行隐藏，并更新UI，运行在主线程中； 通过上面的分析，我们可以知道，AsyncTask的构造方法和execute方法是我们分析AsyncTask的重点。 1）构造方法 AsyncTask的构造方法中 public AsyncTask(@Nullable Looper callbackLooper) { mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Result result = null; try { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); } catch (Throwable tr) { mCancelled.set(true); throw tr; } finally { postResult(result); } return result; } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } mWorker代表了AsyncTask要执行的任务，是对Callable接口的封装，意味着这个任务是有返回值的; mFuture代表了AsyncTask要执行的任务的返回结果，其实就是个FutureTask，按照FutureTask标准用法，mWorker作为Callable被传给了mFuture，那么mFuture的结果就从mWorker执行的任务中取得。仔细看mWorker，return语句返回的结果就是我们前面所说的doInBackground()的执行结果。 2）再看执行流程 查看源码 execute() -&gt; executeOnExecutor(sDefaultExecutor, params) -&gt; exec.execute(mFuture) 到了这一步，将mFuture传递给了AsyncTask的执行器进行执行。AsyncTask的执行器缺省是sDefaultExecutor。 找到成员变量sDefaultExecutor，最终定位到 SerialExecutor是对JDK里Executor的一个实现，被声明为一个静态变量，我们仔细看SerialExecutor的实现， private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 内部声明了一个双端队列ArrayDeque类型的mTasks（双端队列中offer方法表示从队列尾插入，poll()表示从队列头获取元素）。 每次调用execute，就创建一个Runnable匿名内部类对象，这个对象存入mTasks，在匿名内部类的run函数里面调用传入参数r.run()。然后通过一个scheduleNext函数把mTasks里面的所有对象通过THREAD_POOL_EXECUTOR.execute(mActive)执行一遍。说穿了，也就是说SerialExecutor类会把所有的任务丢入一个容器，之后把容器里面的所有对象**一个一个的排队（串行化）**执行THREAD_POOL_EXECUTOR.execute(mActive); 至于这个THREAD_POOL_EXECUTOR，是这样定义的： public static final Executor THREAD_POOL_EXECUTOR; static { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; } 我们可以看到这个线程池，被声明为一个静态变量，同时初始化的参数是： private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); // We want at least 2 threads and at most 4 threads in the core pool, // preferring to have 1 less than the CPU count to avoid saturating // the CPU with background work private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE_SECONDS = 30; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); 3)结果和进度的通知 AsyncTask的执行结果和进度是怎么通知给UI线程的呢？检视mFuture mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } 和更新进度时我们会调用的publishProgress方法 @WorkerThread protected final void publishProgress(Progress... values) { if (!isCancelled()) { getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); } } 我们可以看到都调用了sHandler protected final void publishProgress(Progress... values) { if (!isCancelled()) { getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); } } 说明当子线程需要和UI线程进行通信时，其实就是通过这个handler，往UI线程发送消息。 总结： 1）线程池的创建： 在创建了AsyncTask的时候，会默认创建两个线程池SerialExecutor和ThreadPoolExecutor，SerialExecutor负责将任务串行化，ThreadPoolExecutor是真正执行任务的地方，且无论有多少个AsyncTask实例，两个线程池都会只有一份。 2）任务的执行： 在execute中，会执行run方法，当执行完run方法后，会调用scheduleNext()不断的从双端队列中轮询，获取下一个任务并继续放到一个子线程中执行，直到异步任务执行完毕。 3）消息的处理： 在执行完onPreExecute()方法之后，执行了doInBackground()方法，然后就不断的发送请求获取数据；在这个AsyncTask中维护了一个InternalHandler的类，这个类是继承Handler的，获取的数据是通过handler进行处理和发送的。在其handleMessage方法中，将消息传递给onProgressUpdate()进行进度的更新，也就可以将结果发送到主线程中，进行界面的更新了。 4）使用AsyncTask的注意点 通过观察代码我们可以发现，每一个new出的AsyncTask只能执行一次execute()方法，多次运行将会报错，如需多次，需要新new一个AsyncTask。 @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } ... } AsyncTask优缺点 AsyncTask： 优点：AsyncTask是一个轻量级的异步任务处理类，轻量级体现在，使用方便、代码简洁上，而且整个异步任务的过程可以通过cancel()进行控制； 缺点：不适用于处理长时间的异步任务，一般这个异步任务的过程最好控制在几秒以内，如果是长时间的异步任务就需要考虑多线程的控制问题；当处理多个异步任务时，UI更新变得困难。 Handler: 优点：代码结构清晰，容易处理多个异步任务； 缺点：当有多个异步任务时，由于要配合Thread或Runnable，代码可能会稍显冗余。 **总之，**AsyncTask不失为一个非常好用的异步任务处理类，只要不是频繁对大量UI进行更新，可以考虑使用；而Handler在处理大量UI更新时可以考虑使用。 补充知识：CAS 什么是原子操作？如何实现原子操作？ 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。 实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争（事实上CPU的主要工作并非这些），同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。 实现原子操作还可以使用当前的处理器基本都支持CAS()的指令，只不过每个厂家所实现的算法并不一样罢了，**每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。**CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做CAS操作，直到成功为止。怎么实现线程安全呢？语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。 CAS实现原子操作的三大问题 ABA问题。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。 举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，这就是ABA问题。如果你是一个讲卫生讲文明的小伙子，不但关心水在不在，还要在你离开的时候水被人动过没有，因为你是程序员，所以就想起了放了张纸在旁边，写上初始值0，别人喝水前麻烦先做个累加才能喝水。 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。 ","link":"https://www.xiaowujiang.cn/posts/adf30ba7/"},{"title":"App启动优化","content":"随着手机的运行内存（RAM）越来越大，CPU处理能力越来越强的情况，App的启动速度给用户的印象越来越重要，所以App启动优化也势在必行，下面是我在App优化过程中做的一些笔记。 Android 系统的启动 Android开机执行过程如下图所示： 按下电源时，固化在ROM上的引导芯片代码会开始执行，去加载Bootloader到RAM并开始执行； Bootloader 会将操作系统拉起来并运行； Linux Kernel启动开启系统设置，找到文件init.rc启动初始化进程； init进程初始化和启动属性服务后开启Zygote进程； Zygote开启创建虚拟机并注册JNI方法，开启SystemServer； SystemServer 启动Binder线程池和SystemServiceManager并启动各种服务, 如ActivityManagerService； AMS(ActivityManagerService)启动Launcher Launcher启动 adb命令 查看当前的Activity名称 adb shell dumpsys activity activities 查看进程 adb shell ps Application启动 Launcher源码查看：Android XRef 当我们点击程序图标时，就会执行Launcher类中的onClick方法并把程序的相关信息传入； 先获取一个intent---&gt;startActivitySafely(v, intent, tag)--》startActivity(v, intent, tag);--&gt;startActivity(intent)； startActivity的流程如下： startActivity会开启一个App进程，ActivityThread.java 作为入口，用attach开启App然后再加载Application和ActivityThread.attach --&gt; mgr.attachApplication(mAppThread)，会通过远端进程去回调private void handleBindApplication(AppBindData data) private void handleBindApplication(AppBindData data){ Application app = data.info.makeApplication(创建Application对象 mInstrumentation.callApplicationOnCreate(app);----》 app.onCreate(); } 黑白屏问题 &lt;!--白屏--&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt; &lt;!--黑屏 （在以前的老版本上有效，现在的版本默认使用透明处理了）--&gt; &lt;style name=&quot;AppTheme&quot;&gt; 黑白屏的主要原因是我们app启动耗时太长即Application中onCreate方法执行时间太长导致的，目前的我所做的修改有如下2步。 提升用户体验 添加Splash主题，执行Applciation#onCreate()时显示该主题，这样可以快速打开App 在res/values/中修改样式： 在默认的res/values/styles/styles.xml中添加一个splash主题 &lt;style name=&quot;StartSplashTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;!--设置一张默认的背景图来替代白屏或者黑屏--&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/logo_splash&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 新建res/values/sytles-v21/styles.xml中添加一个splash主题： &lt;style name=&quot;StartSplashTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/logo_splash&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowDrawsSystemBarBackgrounds&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; &lt;/style&gt; 新建res/values/sytles-v27/styles.xml中添加一个splash主题： &lt;style name=&quot;StartSplashTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/ic_splash&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:windowDrawsSystemBarBackgrounds&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowLayoutInDisplayCutoutMode&quot; tools:targetApi=&quot;p&quot;&gt;shortEdges&lt;/item&gt; &lt;/style&gt; 在SplashActivity中设置主题 AndroidManifest.xml &lt;activity android:name=&quot;com.xx.xx.splash.SplashActivity&quot; android:label=&quot;@string/app_name&quot; android:screenOrientation=&quot;portrait&quot; &lt;!--设置该主题--&gt; android:theme=&quot;@style/StartSplashTheme&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 优化Application#onCreate()中的耗时方法 启动时间查看 4.4 以前可以使用adb命令： adb shell am start -W com.xx.xx.splash.SplashActivity 4.4 以后版本在Logcat输入Display筛选系统日志，不过滤信息No Filters 采用Trace工具分析代码执行时间 File file = new File(Environment.getExternalStorageDirectory(), &quot;xmh.trace&quot;); Debug.startMethodTracing(file.getAbsolutePath()); /*****************************************************************************/ .........需要检测的代码............ /*****************************************************************************/ Debug.stopMethodTracing(); 将文件拉取，然后在Android Studio中利用 Profile查看。 优化方案 开启一个优先级低的线程，去处理没有handler相关、不操作UI和对异步要求不高的； 懒加载， 用到的时候才去初始化，一些常量的初始化可以使用类的静态代码块去处理。 ","link":"https://www.xiaowujiang.cn/posts/6241fe4b/"},{"title":"Java中的静态代码块在kotlin中的表现形式","content":"在java中我们有时候会用到类的静态代码块来初始化一些变量，那么在kotlin中如何表示呢？ 看以下代码： TestStatic.java public class TestStatic { static { System.out.println(&quot;static test&quot;); } } 这段代码，在kotlin中可以这样表示： TestStatic.kt class TestStatic { companion oject { init { println(&quot;static test&quot;) } fun test(){ println(&quot;test&quot;) } } } 编译后的java代码: ... public final class StaticTest { public static final StaticTest.Companion Companion = new StaticTest.Companion((DefaultConstructorMarker)null); static { String var0 = &quot;static&quot;; System.out.println(var0); } ... public static final class Companion { public final void test() { String var1 = &quot;test&quot;; System.out.println(var1); } private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } } 可以看到，init方法最终被编译成了static代码块。 ","link":"https://www.xiaowujiang.cn/posts/8f46bf8a/"},{"title":"deepin日常使用","content":"持续更新中.................. 使用深度的deepin的linux发行版系统已经半年有余，对于一个开发者来说，日常使用基本满足并且开发的效率和编译的程序的效率相对于win10高很多，但是呢也会有一些小问题，下面是我刚接触到这个系统时遇到的一些，然后通过查找资料和实践做的一些笔记吧，这篇很不定时更新。 添加自定义程序到程序列表 自己下载的软件包，如何将程序加入程序列表中，以Typora为例： 将从官网下载的typora安装包：Typora-linux-x64.tar.gz，解压到相应的目录(目录自定义)，如：/home/**/App/typora 创建typora.desktop [Desktop Entry] Version=0.9.71 Type=Application Name=Typora Comment=a markdown editor Icon=/home/xw/App/typora/typora.png Exec=/home/xw/App/typora/Typora %F Categories=TextEditor; Terminal=false StartupNotify=false MimeType=text/english;text/plain; 在控制台中，执行cp命令，将typora.desktop放入到/usr/share/applications/下，此处需要su权限 注意： 需要给可执行文件添加可执行权限: sudo chmod u+x xxx.sh(appImage) 修改标题栏 From dde-kwin 0.0.11 version, you can config the titlebar height by create a config file at (please create the path if the path is not existed): # If you use light theme # If the path is not exists,you can use mkdir -p ~/.local/share/deepin/themes/deepin/light/titlebar.ini # If you use dark theme # If the path is not exists,you can use mkdir -p ~/.local/share/deepin/themes/deepin/dark/titlebar.ini and put the following content in the config file (replace 25 with the height you want): [Active] height=25 [Inactive] height=25 JAVA JDK安装 地址： jdk下载 用户名： 2696671285@qq.com 密码： Oracle123 添加Java和Android SDK环境变量 在控制台执行 sudo deepin-editor /etc/profile 打开后最后一行添加： #jdk export JAVA_HOME=/home/xw/App/jdk1.8.0_211 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH # android export ANDROID_HOME=/home/xw/App/android/sdk export ANDROID_NDK=/home/xw/App/android/sdk/ndk-bundle export PATH=$ANDROID_HOME/platform-tools:$ANDROID_HOME/tools:$ANDROID_NDK:$PATH Linux 代理 终端代理 安装proxychains sudo apt install proxychains 配置 安装完成之后在proxychains.conf下： vim /etc/proxychains.conf socks5 127.0.0.1 1080 如果有别的比如socks4 127.0.0.1 9050 那么就把它给注释掉 使用 如果你只是给一个命令实现代理,比如你要git clone什么东西,你只要在这个命令前面加上 proxychains这个命令就好,比如 proxychains git clone https://github.com/haad/proxychains.git 系统代理生成pac文件 sudo apt install python3-pip sudo pip3 install genpac proxychains4 genpac --pac-compress --pac-proxy 'SOCKS5 127.0.0.1:1080' --format pac -o ~/auto.pac file:///home/登录用户名/auto.pac Chrome设置代理 安装SwitchyOmega 情景模式 proxy socks5 127.0.0.1 1080 auto switch 规则地址 浏览器google-chrome.desktop设置 Exec=/usr/bin/google-chrome-stable %U --proxy-server=socks5://127.0.0.1:1080 Git相关 终端 git项目路径下显示git 分支 Ctrl + Alt+ T打开终端 vim ~/.bashrc 文件末尾添加： #show the current git branch find_git_branch () { local dir=. head until [ &quot;$dir&quot; -ef / ]; do if [ -f &quot;$dir/.git/HEAD&quot; ]; then head=$(&lt; &quot;$dir/.git/HEAD&quot;) if [[ $head = ref:\\ refs/heads/* ]]; then git_branch=&quot;(*${head#*/*/})&quot; elif [[ $head != '' ]]; then git_branch=&quot;(*(detached))&quot; else git_branch=&quot;(*(unknow))&quot; fi return fi dir=&quot;../$dir&quot; done git_branch='' } PROMPT_COMMAND=&quot;find_git_branch; $PROMPT_COMMAND&quot; PS1=&quot;\\u@\\h:\\w\\[\\033[0;32m\\]\\$git_branch\\[\\033[0m\\] \\$ &quot; tips: vim 编辑模式下粘贴上述代码会出现格式缩进看着非常乱，所以在粘贴前在vim中执行 :set paste git 避免多次输入密码 git config --global credential.helper store 输入完成后可以看到~/.gitconfig文件中 credential] helper = store 然后提交的时候还需要输入一次密码，之后就不需要了。 git fetch error: insufficient permission for adding an object to repository database ./objects 出现此错误是因为git库权限的问题 ls -al 查看git库的所有者 解决： 使用root进入.git所在的文件路径,将权限重新赋给git库拥有者 sudo chown -R &lt;username&gt; .git/* &lt;username&gt;可以通过 whoami 进行查看 Github 添加ssh 1、首先需要检查你电脑是否已经有 SSH key 运行 终端（Alt + Ctrl+ T），输入如下代码： $ cd ~/.ssh $ ls 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3。 2、创建一个 SSH key $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。 输入完上述命令后一直回车即可，然后就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 3、添加你的 SSH key 到 github上面去 a、首先你需要拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容，如： $ cat ~/.ssh/id_rsa.pub b、登录你的github账号，从又上角的设置（ Account Settings ）进入，然后点击菜单栏的 SSH key 进入页面添加 SSH key。 c、点击 Add SSH key 按钮添加一个 SSH key 。把你复制的 SSH key 代码粘贴到 key 所对应的输入框中，记得 SSH key 代码的前后不要留有空格或者回车。当然，上面的 Title 所对应的输入框你也可以输入一个该 SSH key 显示在 github 上的一个别名。默认的会使用你的邮件名称。 4、测试一下该SSH key 在git Bash 中输入以下代码 $ ssh -T git@github.com 当你输入以上代码时，会有一段警告代码，如： The authenticity of host 'github.com (207.97.227.239)' can't be established. # RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. # Are you sure you want to continue connecting (yes/no)? 这是正常的，你输入 yes 回车既可,如果出现： Hi username! You've successfully authenticated, but GitHub does not # provide shell access. 如果用户名是正确的,你已经成功设置SSH密钥。如果你看到 “access denied” ，者表示拒绝访问，那么你就需要使用 https 去访问，而不是 SSH 。 PlayOnLinux 中文支持 从windows字体目录中复制simsun.ttc到＂XXXX/drive_c/windows/Fonts＂和＂/usr/share/fonts/truetype/msfonts＂这两个目录下面（msfonts为自己建立的目录） 修改Wine的注册表 定位到HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes, 将 MS Shell Dlg 及 MS Shell Dlg 2 的值数据修改为simsun 定位到 HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts, 新建字符串项: simsun (TrueType)，修改此值数据为 z:\\usr\\share\\fonts\\truetype\\msfonts\\simsun.ttc XMIND-ZEN 激活 地址：激活地址 按照README操作即可 tips: 最好使用npm 不要使用代理，不然会报 ref@1.3.5 install: node-gyp rebuild错误 进入tty 当遇到桌面卡死的时候，我们可以通过tty进入命令行界面，然后重启系统，这样避免了强制关机等等操作； 进入命令：ctrl + alt+ F1 到F7 都可以进入 退出命令： 输入用户名密码登录成功后，输入exit回车即可。 安装软件缺少依赖问题解决 sudo apt-get --fix-broken install deepin20 大圆角修复补丁 链接: https://pan.baidu.com/s/1xSkYT5uTHu5DqD7u5813NQ 密码: 5mft markText无法启动 修改desktop Exec=&quot;/opt/Mark Text/marktext&quot; --no-sandbox %U 点击某个markdown文件，使用MarkText打开后，不显示该文件，解决方式，更改marktext.desktop中的启动方式 # 将U改为F Exec=&quot;/opt/Mark Text/marktext&quot; --no-sandbox %F ","link":"https://www.xiaowujiang.cn/posts/a02aa504/"},{"title":"Git切换分支保存修改的代码","content":"在使用git同步代码的过程中，也许会碰到一个项目有好几个分支的情况，就拿我最近的项目来说，我创建了两个分支：master和dev。 经常是在dev分支上开发好了，然后切换到master分支上进行merge, 但是有时候在dev分支上开发了一半，忽然又需要去master上改个需求或者bug，这时候该当如何呢？ 在这个场景下，我查找到了两种方式： 及时commit代码 在dev分支上把已经完成的部分commit后，不push，然后切换到master分支，改完后再commit 使用 git stash 有时候，在dev分支上写的代码，没有编译通过，就需要切换到master分支， 在这种情况下（代码还没有经过测试通过，还无法commit）可以使用git stash。 保存dev当前的修改 在命令行输入： git stash //会生成一个hash值作为版本标志 或者 git stash save &quot;修改的信息&quot; //会将`修改的信息`作为版本标志 这样你的代码就回到了上一个commit了。接下来就可以切换到master分支了。 返回到dev分支 当修改完master分支后，可以通过 git stash pop //将栈中的最后一个取出来 或者 git stash list //可以看到所有的版本信息 然后选择列表项，执行 git stash apply stash@{0} //git stash apply stash@{0}的作用是可以指定栈中的一个版本 ","link":"https://www.xiaowujiang.cn/posts/ec91b04f/"},{"title":"Git压缩提交记录次数","content":"最近在提交git项目中，又get到一项技能，发现自己提交次数有点多，想来合并以前的一些提交记录，减少提交次数。 命令如下: git rebase -i HEAD~n //n代表你要查看的提交记录条数 例如执行 git rebase -i HEAD~4 后会出现： pick d167a86 提交记录1 pick c56d2e4 提交记录2 pick c56d2e4 提交记录3 pick c56d2e4 提交记录4 # Rebase 7a28439..c56d2e4 onto 7a28439 (2 commands) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like &quot;squash&quot;, but discard this commit's log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 可以看到我们提交的4条记录，假如，我需要将记录2、记录3、记录4合并到记录2（只能将最新的合并，即就是 记录1可以合并记录2，但是记录2不能合并记录1），我们将记录3、记录4中的pick改为squash然后保存更改退出后，然后会进入： # This is a combination of 3 commits. # This is the 1st commit message: 提交记录2 # This is the commit message #2: 提交记录3 # This is the commit message #3: 提交记录4 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Fri Oct 12 14:58:12 2018 +0800 # # interactive rebase in progress; onto 7a28439 # Last commands done (2 commands done): # pick d167a86 解决测试中提出的bug,修改etag缓存策略 # squash c56d2e4 解决测试中的bug和修改UI布局,开发新漫画2.6.0版本 # No commands remaining. # You are currently rebasing branch 'develope' on '7a28439'. # # Changes to be committed: # modified: .gitignore # deleted: .gradle/.DS_Store # deleted: .gradle/2.14.1/.DS_Store # deleted: .gradle/2.14.1/taskArtifacts/cache.properties # deleted: .gradle/2.14.1/taskArtifacts/cache.properties.lock # deleted: .gradle/2.14.1/taskArtifacts/fileHashes.bin # deleted: .gradle/2.14.1/taskArtifacts/fileSnapshots.bin # deleted: .gradle/2.14.1/taskArtifacts/fileSnapshotsToTreeSnapshotsIndex.bin # deleted: .gradle/2.14.1/taskArtifacts/taskArtifacts.bin # deleted: .gradle/2.14.1/tasks/_app_compileDebugJavaWithJavac/localClassSetAnalysis/localClassSetAnalysis.bin # deleted: .gradle/2.14.1/tasks/_app_compileDebugJavaWithJavac/localClassSetAnalysis/localClassSetAnalysis.lock # deleted: .gradle/2.14.1/tasks/_app_compileDebugJavaWithJavac/localJarClasspathSnapshot/localJarClasspathSnapshot.bin# deleted: .gradle/2.14.1/tasks/_app_compileDebugJavaWithJavac/localJarClasspathSnapshot/localJarClasspathSnapshot.lock 我们删除上面的&quot;提交记录3、提交记录4&quot;后，保存退出，然后执行： git rebase --continue 执行完毕后会显示successful信息。 ","link":"https://www.xiaowujiang.cn/posts/Git压缩提交记录次数/"},{"title":"Git修改历史提交信息（包含作者信息）","content":"最近学到了 git 的一招对我来说的新技巧：修改历史提交的 author。 在某天打开码云，查看项目时，发现贡献者好几个，我就纳闷了我一个人写的代码怎么会有好几个贡献者，最后通过git log查看提交信息发现，确实是在提交的过程中用了好几个用户名，于是就百度了一下git命令，最后让我找到了git rebase。 使用方式 使用 git rebase -i HEAD~n 命令，n表示要修改前 n 次所有的提交， 说白了就是你要查看多少条提交记录。比如，我要查看从现在到30条范围内的提交记录，所以可以使用 git rebase -i HEAD~30。-i中的 i 是 interactive，交互的意思。 输入此命令后，显示以下结果： pick ac0fcc6 add file2 pick a0cbfbe add file3 pick 16ee6eb add file4 # Rebase d57f11f..16ee6eb onto d57f11f (3 command(s)) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like &quot;squash&quot;, but discard this commit's log message # x, exec = run command (the rest of the line) using shell 通过列表找到，需要要修改的提交信息，根据提示，如，上面的例子中，我需要修改第二行和第三行的提交信息，那我们就可以将第二行和第三行的 pick 改成 edit 或 e，保存退出。 保存上面的修改并退出后，git 会依次执行上面的操作，当操作为 pick 时，直接 commit。当操作为 edit 时，会中断，并提示以下信息： You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 这里的意思是说，你可以使用 git commit --amend 来修改此次提交，修改以后，觉得满意了，执行 git rebase --continue 继续剩下的流程。 由于我们的主要目的是修改提交者的信息，因此光用 git commit --amend 是不够的，我们要使用 git commit --amend --author &quot;xw &lt;aa.hbl@gmail.com&gt;&quot; 这样的操作，这一点是修改提交者信息的关键所在。 使用上面的命令成功修改此次提交的提交者信息后，一定要记得执行 git rebase --continue 继续。 最终完成以后提示如下： $ git rebase --continue Successfully rebased and updated refs/heads/master. 注意: 在本次操作中用到了git命令行和vim编辑模式，不明白的话就自行百度吧。 ","link":"https://www.xiaowujiang.cn/posts/6314a567/"}]}