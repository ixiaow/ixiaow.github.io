{"posts":[{"title":"Dagger2在Android中的使用","content":"Dagger 2 完全解析（一）,基本使用与原理 Dagger 2 完全解析（二）, 进阶使用 Dagger 2 完全解析（三）, Component 与 SubComponent Dagger 2 完全解析（四）,在Android中的使用 本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本 在Android项目中使用Dagger2时，像 Activity和Fragment这种类型的初始化操作都是有Android系统提供的，如果要往其注入对象，不免会有这样的写法： class MainActivity : AppCompatActivity() { @Inject lateinit var activity: MainActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) DaggerMainActivityComponent.builder() .mainActivityModule(MainActivityModule(this)) .appComponent( (application as MyApplication) .daggerAppComponent ).build() .inject(this) } } 上述写法，会有以下几个我们几乎无法避免的问题： 上述Dagger部分的代码存在模板代码，在每个Activity中都会这么写到，即便抽取到BaseActivity中，也有一些特殊部分需要在每个Activity中单独处理，随着业务的增加后期维护不易； 从上面的代码可以看出，MainActivityModule中持有了MainActivity实例，并且需要在MainActivity传入参数，它打破了依赖注入的核心原则：类不应该知道它是如何注入的。 因此为了解决上面的问题，谷歌官方推出了dagger.android。 下面是基本的使用方式，包括如何注入Activity和Fragment,本篇只讲如何使用，后续再分析其原理。 引入Dagger.android依赖 在build.gradle中添加： implementation 'com.google.dagger:dagger-android:2.23.2' implementation 'com.google.dagger:dagger-android-support:2.23.2' kapt 'com.google.dagger:dagger-android-processor:2.23.2' 注入Activity 以MainActivity为例 Dagger2中的写法 class MainActivity : AppCompatActivity() { // 这里只是做了一个例子 @Inject lateinit var activity: MainActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) DaggerMainActivityComponent.builder() .mainActivityModule(MainActivityModule(this)) .appComponent( (application as MyApplication) .daggerAppComponent ).build() .inject(this) } } @ActivityScope @Component(modules = [MainActivityModule::class], dependencies = [AppComponent::class]) interface MainActivityComponent { fun inject(activity: MainActivity) } @Module class MainActivityModule(private val activity: MainActivity) { @Provides fun provideMainActivity(): MainActivity = activity } @Scope annotation class ActivityScope Dagger2-Android中的写法 修改MainActivityComponent @ActivityScope @Subcomponent interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt; { // 声明MainActivity创建的工厂接口 @dagger.Subcomponent.Factory interface Factory : AndroidInjector.Factory&lt;MainActivity&gt; } 修改MainActivityModule @Module(subcomponents = [MainActivityComponent::class]) abstract class MainActivityModule { // module中提供绑定工厂方法 @Binds @IntoMap @ClassKey(MainActivity::class) abstract fun bind( factory: MainActivityComponent.Factory ): AndroidInjector.Factory&lt;*&gt; } 修改onCreate()中的Dagger注入 override fun onCreate(savedInstanceState: Bundle?) { // 在super.onCreate前添加 AndroidInjection.inject(this) super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } 修改MyApplication 通过dagger.android注入时，Application中也发生了相应的变化 class MyApplication : Application(), HasAndroidInjector { @Inject lateinit var dispatchingAndroidInjector: DqispatchingAndroidInjector&lt;Any&gt; override fun onCreate() { super.onCreate() DaggerAppComponent.factory().create(this).inject(this) } override fun androidInjector(): AndroidInjector&lt;Any&gt; { return dispatchingAndroidInjector } } @dagger.Component( modules = [AndroidInjectionModule::class,// 引入框架提供的InjectionModule AndroidSupportInjectionModule::class,// 如果使用了support相关的类，也需要引入 MainActivityModule::class // 这是我们自定义的Module ] ) interface AppComponent : AndroidInjector&lt;MyApplication&gt; { @dagger.Component.Factory interface Factory : AndroidInjector.Factory&lt;MyApplication&gt; } 我们需要将我们在MainActivity中的MainActivityModule加入到Application中的AppComponent的module,然后Make Project或Make App或build project，如果未报错即成功。 简洁写法 如果相应的ActivityComponent中只有以下操作时： @ActivityScope @Subcomponent interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt; { // 声明MainActivity创建的工厂接口 @dagger.Subcomponent.Factory interface Factory : AndroidInjector.Factory&lt;MainActivity&gt; } 我们可以新建一个module类， 将满足以上条件的Component 集中到一起，并删除对应的Component，如： @Module abstract class ActivityBindingModule { @ActivityScoped @ContributesAndroidInjector(modules = [MainActivityModule.class]) abstract fun mainActivity() : MainActivity @ActivityScoped @ContributesAndroidInjector(modules = [AddEditTaskModule.class]) abstract fun addEditTaskActivity(): AddEditTaskActivity } 删除 原有module中的bind*方法 @Module public class MainActivityModule{ } 注入Fragment 注入Fragment与注入Activity类似，唯一不同的地方在于我们需要在onAttach方法中执行AndroidSupportInject.inject(this) class BlankFragment : Fragment() { override fun onAttach(context: Context?) { AndroidSupportInjection.inject(this) super.onAttach(context) } } @dagger.Module abstract class FragmentBindModule { @ContributesAndroidInjector abstract fun blankFragment(): BlankFragment } @dagger.Component( modules = [AndroidInjectionModule::class, AndroidSupportInjectionModule::class, ActivityBinder::class, FragmentBindModule::class ] ) interface AppComponent : AndroidInjector&lt;MyApplication&gt; { @dagger.Component.Factory interface Factory : AndroidInjector.Factory&lt;MyApplication&gt; } 对于FragmentBindModule不仅可以放入到AppComponent中，也可以放入到MainActivityComponent,或者FragmentComponent如： @dagger.Subcomponent(modules = [FragmentBindModule::class]) interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt;{ @dagger.Subcomponent.Factory interface Factory: AndroidInjector.Factory&lt;MainActivity&gt; } @dagger.Module(subcomponents = [ MainActivityComponent::class // 将fragment放入到了activity对应的Component ]) abstract class MainActivityModule{ @Binds @IntoMap @ClassKey(MainActivity::class) abstract fun bind(factory:MainActivityComponent.Factory):AndroidInjector.Factory&lt;*&gt; } 一些问题 @Model 注解的是抽象类时 @provides 标注的必须是静态方法 A @Module may not contain both non-static @Provides methods and abstract @Binds or @Multibinds declarations 这个错误提示是将Module定义成了抽象类，这在java中只需要将@Provide标注的方法设置为静态方法即可，但是在Kotlin中是行不通的，因为在kotlin中静态方法是写在companion object代码块内，所以解决方法有两种： 用Module标注companion object @dagger.Module abstract class MainActivityModule() { @dagger.Module companion object { @JvmStatic @Provides fun provideFragment() = BlankFragment() } @Binds abstract fun context(activity: MainActivity): Context } 使用多个Module将抽象方法和@provide标注的方法分开，如： @Module abstract class MainActivityBindsModule { @Binds abstract fun context(activity: MainActivity): Context } @Module(includes = arrayOf(MainActivityBindsModule ::class)) class MainActivityProvidesModule { @Provides fun provideFragment() = BlankFragment() } 总结 通过前面的例子我们亦可以看出： Dagger2-android 使用的是Dagger2中的继承关系； 使用它，我们就可以不用写那么多的模版代码，相对于Dagger2方便了许多； Dagger2-Android 比Dagger2更强大，我们使用@Binds绑定抽象方法来注入一些提供初始化的类等。 ","link":"https://xiaowujiang.cn/posts/e781e647/"},{"title":"Dagger 2 Component 与 SubComponent","content":"Dagger 2 完全解析（一）,基本使用与原理 Dagger 2 完全解析（二）, 进阶使用 Dagger 2 完全解析（三）, Component 与 SubComponent Dagger 2 完全解析（四）,在Android中的使用 本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本 理解前面两篇文章后，可以使用 Dagger 2框架完成一个对象的依赖注入。但是在实战中会存在多个需要注入依赖的对象，也就是说会有多个 Component，它们之间会有相同的依赖，那么该如何处理它们之间的关系呢？ 我们先来看一个简单的例子： 假如有三个类：A、B和C, A和B都各自持有C的实例，并且通过Dagger2进行注入 class A { @Inject lateinit var c: C } class B { @Inject lateinit var c: C } class C @Inject constructor() Component: @Component interface AComponent { fun injectA(a: A) } @Component interface BComponent { fun injectA(b: B) } 如果要让A、B持有的实例C相同的话，我们该如何处理？ 很多人第一时间会想到下面这种设计： @Singleton @Component(modules = [CModule::class]) interface AComponent { fun injectA(a: A) } @Singleton @Component(modules = [CModule::class]) interface BComponent { fun injectA(b: B) } @Module class CModule { companion object { private var c: C? = null } @Singleton @Provides fun provideC(): C { if (c == null) { c = C() } return c!! } } 把 Component 需要的依赖都在modules属性中声明，但是这样有两个问题： （1）有时依赖实例需要共享，例如上面场景中，A和C都持有C的实例，并且根据Module里的实现，会存在谁先创建C实例的问题。 （2）Scope 作用域容易失效，例如 CModule 的provideCar()使用 @Singleton 作用域，AComponent和BComponent也要用 Singleton 标注，但它们都会持有一个C实例。 假如A先创建了C那么，BComponent需要依赖 AComponent提供的 C实例，这就是 Component 组织关系中的一种。 Component 的组织关系 Component 管理着依赖实例，根据依赖实例之间的关系就能确定 Component 的关系。这些关系可以用object graph描述，我称之为依赖关系图。在 Dagger 2 中 Component 的组织关系分为两种： 依赖关系，一个 Component 依赖其他 Compoent公开的依赖实例，用 Component 中的dependencies声明。 继承关系，一个 Component 继承（也可以叫扩展）某 Component 提供更多的依赖，SubComponent 就是继承关系的体现。 所以前文中AComponent和BComponent是依赖关系。 依赖关系 具体的实现代码： @Component(modules = [CModule::class]) interface AComponent { fun injectA(a: A) fun c(): C } @Component(dependencies = [AComponent::class]) interface BComponent { fun injectA(b: B) } @Module class CModule { @Provides fun provideC(): C = C() } 注：因为 BComponent和 AComponent是依赖关系，如果AComponent声明了作用域的话，那么BComponent也必须声明（反之可以），而且它们的 Scope 不能相同，并且两个都有作用域的情况下 @Singleton 修饰的 Component （BComponent）不能依赖其他的 Component。 public final class DaggerBComponent implements BComponent { private final AComponent aComponent; private DaggerBComponent(AComponent aComponentParam) { this.aComponent = aComponentParam; } .... @Override public void injectA(B b) { injectB(b);} private B injectB(B instance) { // 注入时，使用了aComponent.c() B_MembersInjector.injectC(instance, Preconditions.checkNotNull(aComponent.c(), &quot;Cannot return null from a non-@Nullable component method&quot;)); return instance; } ... } 编译时生成的代码 DaggerBComponent 中会调用aComponent.c()，如果 AComponent 没有向外提供C 实例的接口的话，DaggerBComponent 就会注入失败。 依赖注入： val aComponent = DaggerAComponent.builder().build() DaggerBComponent.builder().aComponent(aComponent).build().inject(b) 依赖关系就跟生活中的朋友关系相当，注意事项如下： 被依赖的 Component 需要把暴露的依赖实例用显式的接口声明。 依赖关系中的 Component 的 Scope 不能相同，因为它们的生命周期不同。 继承关系 继承关系跟面向对象中的继承的概念有点像，SubComponent称为子 Component，类似于平常说的子类。下面先看看下面这个场景： class Parent { @Inject lateinit var car: Car } class Child { @Inject lateinit var car: Car @Inject lateinit var bike: Bike } class Car @Inject constructor() class Bike @Inject constructor() Child 可以开Parent的车 car，也可以骑自己的自行车 bike。依赖关系图： 上图中 ChildComponent 在 ParentComponent之中，ChildComponent子承父业，可以访问 ParentComponent 的依赖，而 ParentComponent只知道 ChildComponent 是它的子类，可以访问 SubComponent.Builder，却无法访问 SubComponent 中的依赖。 @Component(modules = [CarModule::class]) interface ParentComponent { fun inject(parent: Parent) } @Subcomponent(modules = [BikeModule::class]) interface ChildComponent { fun inject(child: Child) // SubComponent 必须显式地声明 Subcomponent.Builder，parentComponent 需要用 Builder 来创建 ChildComponent @Subcomponent.Builder interface Builder { fun build(): ChildComponent } } @SubComponent的写法与@Component一样，只能标注接口或抽象类，与依赖关系一样，SubComponent 与 parent Component 的 Scope 不能相同，只是 SubComponent 表明它是继承扩展某 Component 的。怎么表明一个 SubComponent 是属于哪个 parent Component 的呢？只需要在 parent Component 依赖的 Module 中的subcomponents加上 SubComponent 的 class，然后就可以在 parent Component 中请求 SubComponent.Builder。 @Component(modules = [CarModule::class]) interface ParentComponent { ... // 用来创建childComponent fun childComponent(): ChildComponent.Builder } @Subcomponent(modules = [BikeModule::class]) interface ChildComponent { ... // SubComponent 必须显式地声明 Subcomponent.Builder，parentComponent 需要用 Builder 来创建 ChildComponent @Subcomponent.Builder interface Builder { fun build(): ChildComponent } } // 在CarModule上添加subComponents @Module(subcomponents = [ChildComponent::class]) class CarModule { @Provides fun provideCar() = Car() } @Module class BikeModule { @Provides fun provideBike() = Bike() } 上面的代码经过make project后，dagger2生成的代码： public final class DaggerParentComponent implements ParentComponent { ... @Override public ChildComponent.Builder childComponent() { return new ChildComponentBuilder();} ... private final class ChildComponentBuilder implements ChildComponent.Builder { @Override public ChildComponent build() { return new ChildComponentImpl(new BikeModule()); } } private final class ChildComponentImpl implements ChildComponent { private final BikeModule bikeModule; private ChildComponentImpl(BikeModule bikeModuleParam) { this.bikeModule = bikeModuleParam; } ... private Child injectChild(Child instance) { // 注入car时，调用的parentComponent的carModule提供 Child_MembersInjector.injectCar(instance, CarModule_ProvideCarFactory.provideCar(DaggerParentComponent.this.carModule)); Child_MembersInjector.injectBike(instance, BikeModule_ProvideBikeFactory.provideBike(bikeModule)); return instance; } } } SubComponent 编译时不会生成 DaggerChildComponent，需要通过 parentComponent 的获取 SubComponent.Builder 方法获取 ChildComponent 实例。 val parentComponent = DaggerParentComponent.builder().build() parentComponent.childComponent().build().inject(child) 继承关系和依赖关系最大的区别就是：继承关系中不用显式地提供依赖实例的接口，SubComponent 继承 parent Component 的所有依赖。 依赖关系 vs 继承关系 相同点： 两者都能复用其他 Component 的依赖 有依赖关系和继承关系的 Component 不能有相同的 Scope 区别： 依赖关系中被依赖的 Component 必须显式地提供公开依赖实例的接口，而 SubComponent 默认继承 parent Component 的依赖。 依赖关系会生成两个独立的 DaggerXXComponent 类，而 SubComponent 不会生成 独立的 DaggerXXComponent 类。 在 Android 开发中，Activity 是 App 运行中组件，Fragment 又是 Activity 一部分，这种组件化思想适合继承关系，所以在 Android 中一般使用 SubComponent。 SubComponent 的其他问题 抽象工厂方法定义继承关系 除了使用 Module 的subcomponents属性定义继承关系，还可以在 parent Component 中声明返回 SubComponent 的抽象工厂方法来定义： @Component(modules = [CarModule::class]) interface ParentComponent { ... // 用来创建childComponent //// 这个抽象工厂方法表明 ChildComponent 继承 ParentComponent fun childComponent(): ChildComponent } @Subcomponent(modules = [BikeModule::class]) interface ChildComponent { ... } @Module class CarModule { @Provides fun provideCar() = Car() } @Module class BikeModule { @Provides fun provideBike() = Bike() } 这种定义方式不能很明显地表明继承关系，一般推荐使用 Module 的subcomponents属性定义。 重复的 Module 当相同的 Module 注入到 parent Component 和它的 SubComponent 中时，则每个 Component 都将自动使用这个 Module 的同一实例。也就是如果在 SubComponent.Builder 中调用相同的 Module 或者在返回 SubComponent 的抽象工厂方法中以重复 Module 作为参数时，会出现错误。（前者在编译时不能检测出，是运行时错误） @Component(modules = {RepeatedModule.class, ...}) interface ComponentOne { ComponentTwo componentTwo(RepeatedModule repeatedModule); // 编译时报错 ComponentThree.Builder componentThreeBuilder(); } @Subcomponent(modules = {RepeatedModule.class, ...}) interface ComponentTwo { ... } @Subcomponent(modules = {RepeatedModule.class, ...}) interface ComponentThree { @Subcomponent.Builder interface Builder { Builder repeatedModule(RepeatedModule repeatedModule); ComponentThree build(); } } DaggerComponentOne.create().componentThreeBuilder() .repeatedModule(new RepeatedModule()) // 运行时报错 UnsupportedOperationException! .build(); 总结 Component 之间共用相同依赖，可以有两种组织关系：依赖关系与继承关系。至于如何选择试具体情况而定，但在 Android 开发中，一般使用继承关系，以 AppComponent 作为 root Component，AppComponent 一般还会使用 @Singleton 作用域，而 ActivityComponent 为 SubComponent。 ","link":"https://xiaowujiang.cn/posts/e30bee8a/"},{"title":"Dagger 2 进阶使用","content":"Dagger 2 完全解析（一）,基本使用与原理 Dagger 2 完全解析（二）, 进阶使用 Dagger 2 完全解析（三）, Component 与 SubComponent Dagger 2 完全解析（四）,在Android中的使用 本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本 在Dagger 2 完全解析（一）,基本使用与原理中介绍了 Dagger 2 基本使用，但是在实战中基本使用是远远不够的，我们还需要掌握一些其它的知识，下面由简入繁地讲解这几个概念，同时结合 Dagger 2 的编译时生成代码分析背后的原理（示例代码沿用第一篇的）。 下面开始对Lazy、Provider、Qualifier和 Scope进行分析。 Lazy （延迟注入） 有时我们想注入的依赖在使用时再完成初始化，提高加载速度，就可以使用注入Lazy&lt;T&gt;。只有在调用Lazy的 get() 方法时才会初始化依赖实例注入依赖。 public interface Lazy&lt;T&gt; { T get(); } 在A中使用： class A { ... @Inject lateinit var lazyD: Lazy&lt;D&gt; fun doWork(){ lazyD.get() // 返回D的实例 } } Make app后，在DaggerAComponent中： public final class DaggerAComponent implements AComponent { private final AModule aModule; ... @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); A_MembersInjector.injectC(instance, new C()); // DoubleCheck 是线程安全的Lazy实例初始化类 A_MembersInjector.injectLazyD(instance, DoubleCheck.lazy(D_Factory.create())); return instance; } ... DoubleCheck 是线程安全的Lazy实例初始化工具类 public static &lt;P extends Provider&lt;T&gt;, T&gt; Lazy&lt;T&gt; lazy(P provider) { if (provider instanceof Lazy) { @SuppressWarnings(&quot;unchecked&quot;) final Lazy&lt;T&gt; lazy = (Lazy&lt;T&gt;) provider; return lazy; } return new DoubleCheck&lt;T&gt;(checkNotNull(provider)); } // 在需要使用的时候调用此方法进行返回相应的实例 @Override public T get() { Object result = instance; if (result == UNINITIALIZED) { synchronized (this) { result = instance; if (result == UNINITIALIZED) { result = provider.get(); instance = reentrantCheck(instance, result); provider = null; } } } return (T) result; } Provider 注入 有时候不仅仅是注入单个实例，我们需要多个实例，这时可以使用注入Provider&lt;T&gt;，每次调用它的 get() 方法都会调用到 @Inject 构造函数创建新实例或者Module 的 provide 方法返回实例。 class A { @Inject lateinit var providerD: Provider&lt;D&gt; fun createDFactory(): MutableList&lt;D&gt; { val ds = mutableListOf&lt;D&gt;() for (i in 0..10) { ds.add(providerD.get()) } return ds } } Make app后，在DaggerAComponent中： public final class DaggerAComponent implements AComponent { private final AModule aModule; ... @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); A_MembersInjector.injectC(instance, new C()); A_MembersInjector.injectLazyD(instance, DoubleCheck.lazy(D_Factory.create())); // 注入provider ,将`Factory`传入 A_MembersInjector.injectProviderD(instance, D_Factory.create()); return instance; } ... 再来看看D_Factory： public final class D_Factory implements Factory&lt;D&gt; { private static final D_Factory INSTANCE = new D_Factory(); // 每次调用get方法都会重新创建实例 @Override public D get() { return new D(); } public static D_Factory create() { return INSTANCE; } public static D newInstance() { return new D(); } } 通过上面可以看到，每次调用get方法都会重新创建实例, D_Factory实现了Factory&lt;D&gt;而Factory&lt;D&gt;继承自Provider&lt;D&gt;。 public final class D_Factory implements Factory&lt;D&gt; {} public interface Factory&lt;T&gt; extends Provider&lt;T&gt; {} Qualifier（限定符） 试想这样一种情况：在 AModule提供了两个生成B 实例的provide 方法，如果使用 Dagger 2 在 A 中注入B实例时应该选择哪一个方法呢？ @Module class AModule { @Provides fun provideB(): B = B() @Provides fun provideOther(): B = B() } 这时 Dagger 2 不知道使用provideB还是provideOther提供的实例，在编译时就会出现： [Dagger/DuplicateBindings] *.data.B is bound multiple times: 而@Qualifier注解就是用来解决这个问题，使用注解来确定使用哪种 provide 方法。 @Target(ANNOTATION_TYPE) @Retention(RUNTIME) @Documented public @interface Qualifier {} 我们可以发现@Qualifier是用来修饰注解的，所以它是不能直接作用到provide方法上。 下面是自定义的@Named注解，你也可以用自定义的其他 Qualifier 注解： @Qualifier @Documented @Retention(RUNTIME) public @interface Named { String value() default &quot;&quot;; } 在 provide 方法上加上@Named注解，用来区分 @Module class AModule { @Named(&quot;b&quot;) @Provides fun provideB(): B = B() @Named(&quot;other&quot;) @Provides fun provideOther(): B = B() } 还需要在Inject 注入的地方加上@field:Named注解: class A { @Inject @field:Named(&quot;other&quot;) lateinit var b: B ... } **tips: ** 在kotlin中使用@Name给属性注入时需要添加@field，不然注解不生效。 这样在依赖注入时，Dagger 2 就会使用provideB方法提供的实例，所以Qualifier（限定符）的作用相当于起了个区分的别名。 public final class DaggerAComponent implements AComponent { private final AModule aModule; ... @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { // 使用的是 provide方法 A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); ... return instance; } ... } 当然啦，我们也可以自定义注解进行区分，比如： @Qualifier @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD) annotation class Other 然后在provideOther和lateinit var b: B上加上@Other即可。 Scope（作用域） Scope 是用来确定注入的实例的生命周期的，如果没有使用 Scope 注解，Component 每次调用 Module 中的 provide 方法或 Inject 构造函数生成的工厂时都会创建一个新的实例，而使用 Scope 后可以复用之前的依赖实例。下面先介绍 Scope 的基本概念与原理，再分析 Singleton、Reusable 等作用域。 Scope 基本概念 先介绍 Scope 的用法，@Scope是元注解，是用来标注自定义注解的，如下： @Target(ANNOTATION_TYPE) @Retention(RUNTIME) @Documented public @interface Scope {} **Scope 注解只能标注目标类、@provide 方法和 Component。**Scope 注解要生效的话，需要同时标注在 Component 和提供依赖实例的Module 或目标类上。Module 中 provide 方法中的 Scope 注解必须和 与之绑定的 Component 的 Scope 注解一样，否则作用域不同会导致编译时会报错。 那么 Scope 注解又是如何产生作用的呢，怎么保证生成的依赖实例的生命周期呢？ 在 Dagger 2 官方文档中我找到一句话，非常清楚地描述了@Scope的原理： When a binding uses a scope annotation, that means that the component object holds a reference to the bound object until the component object itself is garbage-collected. 当 Component 与 Module、目标类（需要被注入依赖）使用 Scope 注解绑定时，意味着 Component 对象持有绑定的依赖实例的一个引用直到 Component 对象本身被回收。也就是作用域的原理，其实是让生成的依赖实例的生命周期与 Component 绑定，Scope 注解并不能保证生命周期，要想保证赖实例的生命周期，需要确保 Component 的生命周期。 下面以@AScope为例，看 Scope 注解背后的代码： 先定义AScope @Scope @Retention(RUNTIME) @Target(FIELD, FUNCTION, CLASS) annotation class AScope 使用Module方式 在AModule中： @Module class AModule { @AScope @Provides fun provideB(): B = B() } 在AComponent中 @Component(modules = [AModule::class]) @AScope interface AComponent { fun injectA(a: A) } 这样生成的 B实例就与 AComponent 绑定了。下面看编译时生成的代码： public final class DaggerAComponent implements AComponent { private Provider&lt;B&gt; provideBProvider; private DaggerAComponent(AModule aModuleParam) { initialize(aModuleParam); } ... @SuppressWarnings(&quot;unchecked&quot;) private void initialize(final AModule aModuleParam) { this.provideOtherProvider = DoubleCheck.provider(AModule_ProvideBFactory.create(aModuleParam)); } @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { // provideOtherProvider 不再由Factory创建，而是DobuleCheck A_MembersInjector.injectB(instance, provideBProvider.get()); return instance; } ... } 从上面 DaggerAComponent的代码可以看出使用了 AScope 作用域后，provideBProvider由AModule_ProvideCarFactory.create()变为了DoubleCheck.provider(AModule_ProvideBFactory.create())。而 DoubleCheck 包装的意义在于持有了 B的实例，而且只会生成一次实例，也就是说：没有用 MyScope 作用域之前，DaggerAComponent 每次注入依赖都会新建一个 B实例，而用 AScope 作用之后，每次注入依赖都只会返回第一次生成的实例。通过生成的代码可以发现这和Lazy的方式很相似。 注解到目标类方式 class A { @AScope @Inject lateinit var b: B } @AScope class B @Inject constructor() @AScope @Component(modules = [AModule::class]) interface AComponent { fun injectA(a: A) } @Module class AModule { } 使用这种方式生成的代码： public final class DaggerAComponent implements AComponent { private Provider&lt;B&gt; bProvider; private DaggerAComponent() { initialize(); } ... @SuppressWarnings(&quot;unchecked&quot;) private void initialize() { // 此处使用的是Factory,不是AModule_ProvideBFactory this.bProvider = DoubleCheck.provider(B_Factory.create()); } @Override public void injectA(A a) { injectA2(a);} private A injectA2(A instance) { A_MembersInjector.injectB(instance, bProvider.get()); return instance; } ... } Scope 作用域的本质：Component 间接持有依赖实例的引用，把实例的作用域与 Component 绑定 Singleton 在了解作用域的原理后，再来理解 Dagger 2 提供的自带作用域就容易了。@Singleton顾名思义保证单例，那么它又是如何实现的呢，实现了单例模式那样只返回一个实例吗？ 把上面例子中@AScope换成@Singleton，发现生成的 DaggerAComponent 和其他类没有变化。也只是用DoubleCheck包装了工厂而已，并没有什么特殊实现。所以 Singleton 作用域可以保证一个 Component 中的单例，但是如果产生多个 Component 实例，那么实例的单例就无法保证了。 所以在网上一些例子中，有看到AppComponent使用 Singleton 作用域，保证绑定的依赖实例的单例。它生效的原因是AppComponent只会在 Application 中创建一次，由AppComponent的单例来保证绑定的依赖实例的单例。 **注意：Component 可以同时被多个 Scope 标记。**即 Component 可以和多个 Scope 的 Moudle 或目标类绑定。 Reusable 上文中的自定义的@AScope和@Singleton都可以使得绑定的 Component 缓存依赖的实例，但是与之绑定 Component 必须有相同的 Scope 标记。假如我只想单纯缓存依赖的实例，可以复用之前的实例，不想关心与之绑定是什么 Component，应该怎么办呢？。 这时就可以使用@Reusable作用域，**Reusable 作用域不关心绑定的 Component，Reusable 作用域只需要标记目标类或 provide 方法，不用标记 Component。**下面先看看使用 Reusable 作用域后，生成的 DaggerAComponent 的变化： public final class DaggerAComponent implements AComponent { private Provider&lt;B&gt; provideBProvider; private DaggerAComponent(AModule aModuleParam) { initialize(aModuleParam); } @SuppressWarnings(&quot;unchecked&quot;) private void initialize(final AModule aModuleParam) { this.provideBProvider = SingleCheck.provider(AModule_ProvideBFactory.create(aModuleParam)); } @Override public void injectA(A a) { injectA2(a); } private A injectA2(A instance) { A_MembersInjector.injectB(instance, provideBProvider.get()); return instance; } ... } 从上面代码可以看出使用@Reusable作用域后，利用到 Reusable 实例的 Component 会间接持有实例的引用。但是这里是用SingleCheck而不是DoubleCheck，在多线程情况下可能会生成多个实例。因为@Reusable作用域目的只是可以复用之前的实例，并不需要严格地保证实例的唯一，所以使用 SingleCheck 就足够了。 Releasable references（可释放引用） 相关内容在新版Dagger2已经废除。 Binding Instances 通过前面作用域的讲解，可以清楚 Component 可以间接持有 Module 或 Inject 目标类构造函数提供的依赖实例，除了这两种方式，Component 还可以在创建 Component 的时候绑定依赖实例，用以注入。这就是@BindsInstance注解的作用，只能在 Component.Builder 中使用。 在 Android 中使用 Dagger 2 时，activity 实例经常也需要作为依赖实例用以注入，在之前只能使用 Module： @Module class MainActivityModule { private val mainActivity: MainActivity constructor(mainActivity: MainActivity) { this.mainActivity = mainActivity } @Provides fun provideMainActivity(): MainActivity { return this.mainActivity } } 而使用@BindsInstance的话会更加简单： @Component interface MainActivityComponent { fun injectMainActivity(activity: MainActivity) @Component.Builder interface Builder { @BindsInstance fun activity(activity: Activity): Builder fun build(): MainActivityComponent } } 注意在调用build()创建 Component 之前，所有@BindsInstance方法必须先调用。上面例子中 MainActivityComponent还可以注入 Activity 类型的依赖，但是不能注入 MainActivity，因为 Dagger 2 是使用具体类型作为依据的（也就是只能使用@Inject Activity activity而不是@Inject MainActivity activity）。 如果@BindsInstance方法的参数可能为 null，需要再用@Nullable标记，同时标注 Inject 的地方也需要用@Nullable标记。这时 Builder 也可以不调用@BindsInstance方法，这样 Component 会默认设置 instance 为 null。 总结 Lazy 可以延时注入，Provider 可以创建多个实例 Qualifier 限定符用来解决同一个实例不同方法提供冲突的问题，可以依赖实例起个别名用来区分，或者自定义注解 Scope 作用域的本质是 Component 会持有与之绑定的依赖实例的引用，要想确保实例的生命周期，关键在于控制 Component 的生命周期。 推荐优先使用@BindsInstance方法，相对于写一个带有构造函数带有参数的 Module。 ","link":"https://xiaowujiang.cn/posts/b74c4b6c/"},{"title":"Dagger 2 的基本使用与原理","content":"Dagger 2 完全解析（一）,基本使用与原理 Dagger 2 完全解析（二）, 进阶使用 Dagger 2 完全解析（三）, Component 与 SubComponent Dagger 2 完全解析（四）,在Android中的使用 本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本 依赖注入 什么是依赖 依赖(Dependency) 是类与类之间的联接。依赖关系表示一个类依赖于另一个类的定义, 一般而言，依赖关系在语言中体现为局部变量、方法的形参，或者对静态方法的调用。 我们在Android开发中 经常会在build.gradle中引入第三方包的依赖包，然后就完成了对第三方的依赖。那么到底什么是依赖呢？下面我举个例子： 假如有两个类 : A和B, A中持有B的实例，则可认为 A依赖B // Class A class A( private val b: B = B()// A中定义了b,并创建了B实例 ) // Class B class B 上面这种写法是最常见的写法，但是在下面几个场景中存在一些问题： 如果要修改 B 的构造函数，例如需要使用b= B(name)的方式构造时，还要修改 A的代码； 不利于单元测试，如单元测试中使用 mock 的 B测试A 。 什么是依赖注入(Dependency Injection) 依赖注入（简称 DI）是用于实现控制反转（ IOC）最常见的方式之一，IOC是面向对象编程中的一种设计思想，用以降低代码之间耦合度。控制反转的基本思想是：借助“第三方”实现具有依赖关系的对象之间的解耦。 就拿上面的例子来说，我们在A中创建并持有B的实例，A依赖B ，并且创建的主动权在A, 实现了 Ioc 后，对象 A 依赖于IOC 容器，对象 A 被动地接受容器提供的对象 B 实例，由主动变为被动，因此称为控制反转。 注意，控制反转不等同于依赖注入，控制反转还有一种实现方式叫“依赖查找”（Denpendency Lookup） 依赖注入就是将对象实例传入到一个对象中去（Denpendency injection means giving an object its instance variables）。依赖注入是一种设计模式，降低了依赖和被依赖对象之间的耦合，方便扩展和单元测试。 依赖注入的实现方式 其实在平常编码的过程中，已经不知觉地使用了依赖注入 基于构造函数，在构造对象时注入所依赖的对象。 class A( private val b: B // 由创建A 是 传入B的实例 ) 基于 set 方法，使用 setter 方法来让外部容器调用传入所依赖的对象。 class A { private lateinit var b: B // 通过外部调用setB()实现实例注入 fun setB(b: B) { this.b = b } } 基于接口，使用接口来提供 setter 方法。 interface BInjector { fun injectB(b: B) } class A : BInjector { private var b: B? = null override fun injectB(b: B) { this.b = b } } 基于注解，Dagger 2 依赖注入框架就是使用@Inject完成注入。 class A { @Inject lateinit var b: B } Dagger 2 Dagger 2 是 Java 和Android下的一个完全静态、编译时生成代码的依赖注入框架，由 Google 维护，早期的版本 Dagger 是由 Square 创建的。 Dagger 2 是基于 Java Specification Request(JSR) 330标准。利用 JSR 注解在编译时生成代码，来注入实例完成依赖注入。 下面是 Dagger 2 的一些资源地址： Github：https://github.com/google/dagger 官方文档：https://google.github.io/dagger// API：http://google.github.io/dagger/api/latest/ Dagger 2 的基本使用 上面介绍了依赖注入和 Dagger 2，下面由简单的示例开始一步一步地解析 Dagger 2 的基本使用与原理。 引入 Dagger 2 在build.gradle中添加依赖和plugin： apply plugin: 'kotlin-kapt' dependencies { implementation 'com.google.dagger:dagger:2.23.2' kapt 'com.google.dagger:dagger-compiler:2.32.2' } 如果 Android gradle plugin 的版本低于2.2，还需要引入 android-apt 插件。 使用 @Inject 标注需要注入的依赖 @Inject package javax.inject; @Target({ METHOD, CONSTRUCTOR, FIELD }) @Retention(RUNTIME) @Documented public @interface Inject {} 继续使用上面 A 的例子： class A { @Inject lateinit var b: B } 使用javax.inject.Inject注解来标注需要 Dagger 2 注入的依赖，make module或者build后可以在build/generated/source/kapt目录下看到 Dagger 2 编译时生成的成员属性注入类。 public final class A_MembersInjector implements MembersInjector&lt;A&gt; { private final Provider&lt;B&gt; bProvider; public A_MembersInjector(Provider&lt;B&gt; bProvider) { this.bProvider = bProvider; } public static MembersInjector&lt;A&gt; create(Provider&lt;B&gt; bProvider) { return new A_MembersInjector(bProvider);} @Override public void injectMembers(A instance) { injectB(instance, bProvider.get()); } public static void injectB(A instance, B b) { instance.b = b; } } 从上面的injectMembers方法中可以看到注入依赖的代码是instance.b= bProvider.get();，所以@Inject标注的成员属性不能是private的，不然无法注入。A中@Inject注解了n不同的类型变量，那么A_MembersInjector就会持有n个Provider。 创建所依赖对象的实例 用@Inject标注构造函数时，Dagger 2 会完成实例的创建。 class B @Inject constructor() build 后可以在build/generated/source/kapt目录下看到 Dagger 2 编译时生成的工厂类。 public final class B_Factory implements Factory&lt;B&gt; { private static final B_Factory INSTANCE = new B_Factory(); @Override public B get() { return new B(); } public static B_Factory create() { return INSTANCE; } public static B newInstance() { return new B(); } } 依赖注入是依赖的对象实例–&gt;需要注入的实例属性，上面完成两步，通过 Dagger 2 生成的代码代码可以知道，生成了 A的成员属性注入类和 B的工厂类，接下来需要的就是新建工厂实例并调用成员属性注入类完成 B的实例注入。完成这个过程的桥梁就是dagger.Component。 Component 桥梁 @Component可以标注接口或抽象类 @Retention(RUNTIME) @Target(TYPE) @Documented public @interface Component { @Target(TYPE) @Documented @interface Builder {} @Target(TYPE) @Documented @interface Factory {} } Component可以完成依赖注入过程，其中最重要的是定义注入接口，调用注入接口就可以完成 A 所需依赖的注入。 @Component interface AComponent { fun injectA(a: A) } build 后会生成带有Dagger前缀的实现该接口的类：DaggerManComponent public final class DaggerAComponent implements AComponent { private DaggerAComponent() { } public static Builder builder() { return new Builder(); } public static AComponent create() { return new Builder().build(); } @Override public void injectA(A a) { injectA2(a); } private A injectA2(A instance) { A_MembersInjector.injectB(instance, new B()); return instance; } public static final class Builder { private Builder() { } public AComponent build() { return new DaggerAComponent(); } } } 从上面生成的代码可以看出来 DaggerAComponent就是连接依赖的对象A实例和需要注入的B实例属性之间的桥梁。DaggerAComponent会查找目标类对应的成员属性注入类（即A_MembersInjector），然后调用A_MembersInjector.injectB(instance, new B())就能完成依赖注入。注意，Component 中注入接口的参数必须为需要注入依赖的类型，不能是 要注入类型的父类或子类，注入接口返回值为 void，接口名可以任意。 接下来只需要在 A中调用injectA方法就能完成注入。 class A { init{ DaggerManComponent.create().injectA(this) } } Module 使用@Inject标注构造函数来提供依赖的对象实例的方法，不是万能的，在以下几种场景中无法使用： 接口没有构造函数 第三方库的类不能被标注 构造函数中的参数必须配置 为了解决上面的问题，Dagger又提供了一种新的注解方式：Module 在Module中，Module 即用@Module标注的类。所以 Module 是提供依赖的对象实例的另一种方式。 @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Module { Class&lt;?&gt;[] includes() default {}; @Beta Class&lt;?&gt;[] subcomponents() default {}; } 在Module可以用@Provides标注的方法来提供依赖实例，方法的返回值就是依赖的对象实例。 @Module class AModule { @Provides fun provideB(): B = B() } 约定俗成的是@Provides方法一般以provide为前缀，Moudle 类以Module为后缀，一个 Module 类中可以有多个@Provides方法。 接下来，关联Module与Component： @Component(modules = [AModule::class]) interface AComponent { fun injectA(a: A) } build之后，Module 和 Component 生成的类为： public final class DaggerAComponent implements AComponent { private final AModule aModule; private DaggerAComponent(AModule aModuleParam) { this.aModule = aModuleParam; } .... private A injectA2(A instance) { A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); return instance; } public static final class Builder { private AModule aModule; private Builder() { } public Builder aModule(AModule aModule) { this.aModule = Preconditions.checkNotNull(aModule); return this; } public AComponent build() { if (aModule == null) { this.aModule = new AModule(); } return new DaggerAComponent(aModule); } } } 生成的 DaggerAComponent 和之前相比主要是injectA2()方法不一样，具体体现在： 没有Module时： A_MembersInjector.injectB(instance, new B()); 有Module时： A_MembersInjector.injectB(instance, AModule_ProvideBFactory.provideB(aModule)); AModule_ProvideBFactory实现 Factory 接口。 public final class AModule_ProvideBFactory implements Factory&lt;B&gt; { private final AModule module; public AModule_ProvideBFactory(AModule module) { this.module = module; } @Override public B get() { return provideB(module); } public static AModule_ProvideBFactory create(AModule module) { return new AModule_ProvideBFactory(module); } public static B provideB(AModule instance) { return Preconditions.checkNotNull(instance.provideB(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;); } } 总结 现在再来看 Dagger 2 最核心的三个部分： 需要注入依赖的目标类，需要注入的实例属性由@Inject标注。 提供依赖对象实例的工厂，用@Inject标注构造函数或定义Module这两种方式都能提供依赖实例，Dagger 2 的注解处理器会在编译时生成相应的工厂类。Module的优先级比@Inject标注构造函数的高，意味着 Dagger 2 会先从 Module 寻找依赖实例。 把依赖实例工厂创建的实例注入到目标类中的 Component。 下面再讲述上面提到的在 Dagger 2 种几个注解的用法： @Inject 一般情况下是标注成员属性和构造函数，标注的成员属性不能是private，Dagger 2 还支持方法注入，@Inject还可以标注方法。 @Provides 只能标注方法，必须在 Module 中。 @Module 用来标注 Module 类 @Component 只能标注接口或抽象类，声明的注入接口的参数类型必须和目标类一致。 ","link":"https://xiaowujiang.cn/posts/cbb172f8/"},{"title":"Android DataBinding 从入门到进阶","content":"DataBinding 是google发布的一个数据绑定框架，用于降低布局和逻辑的耦合性，使代码逻辑更加清晰。大量减少 Activity 内的代码，数据能够单向或双向绑定到 layout 文件中，有助于防止内存泄漏，而且能自动进行空检测以避免空指针异常。 环境配置 详情内容请参考：https://developer.android.com/topic/libraries/data-binding/start 启用 DataBinding 的方法是在对应 Model 的 build.gradle 文件里加入以下代码，同步后就能引入对 DataBinding 的支持 android { ... dataBinding { enabled = true } } 如果Android Studio的版本小于3.2的需要在gradle.properties中添加： android.databinding.enableV2=true tips: 1. 推荐使用最新的Android Studio版本和AndroidX库。 ​ 2.build.gradle中添加'apply plugin : 'kotlin-kapt'。 基础入门 改变布局文件 layout 启用 DataBinding 后，打开原有的布局文件，选中根布局的 根布局，按住 Alt + 回车键，点击 “Convert to data binding layout”，就可以生成 DataBinding 需要的布局规则。 转换后的内容为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; 和原始布局的区别在于多出了一个 layout 标签将原布局包裹了起来； data 标签用于声明要用到的变量以及变量类型，它搭建了 View 和 Model 之间的通道。 创建Model package com.github.ixiaow.databindingsample.model data class User(val name:String, val password: String) Model 与 布局文件关联 在 data 标签里声明要使用到的变量名、类的全路径 &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.github.ixiaow.databindingsample.model.User&quot;/&gt; &lt;/data&gt; 在 相应部分使用User &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;data&gt; ... &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView ... android:text=&quot;@{user.name}&quot;/&gt; &lt;TextView ... android:text=&quot;@{user.password}&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; 给Model赋值 写好布局文件后，在 Android Studio中执行make project或者make app, 完成后，在Activity中: class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val dataBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) // 给user初始化值 dataBinding.user = User(&quot;zhangsan&quot;, &quot;12345&quot;) } } 运行App后就可以看到结果啦。 补充知识 import 我们可以像使用java或者kotlin文件一样，导入需要的类名路径即可，比如说： 如果 User 类型要多处用到，也可以直接将之 import 进来，这样就不用每次都指明整个包名路径了，而 java.lang.* 包中的类会被自动导入，所以可以直接使用： &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.databindingsample.model.User&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot;/&gt; &lt;/data&gt; 导入java或kotlin文件中的系统类，比如 import 集合 list &lt;data&gt; &lt;import type=&quot;java.util.List&quot;/&gt; &lt;import type=&quot;com.github.ixiaow.sample.model.User&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot;/&gt; &lt;variable name=&quot;users&quot; type=&quot;List&lt;User&gt;&quot;/&gt; &lt;/data&gt; ❤️ &lt;需要被替换成&amp;lt; 如果存在 import 的类名相同的情况，可以使用 alias 指定别名 &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.sample.model1.User&quot; /&gt; &lt;import alias=&quot;TempUser&quot; type=&quot;com.github.ixiaow.sample.model2.User&quot; /&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot; /&gt; &lt;variable name=&quot;tempUserInfo&quot; type=&quot;TempUser&quot; /&gt; &lt;/data&gt; 预览添加默认值 由于 @{user.name}在布局文件中并没有明确的值，所以在预览视图中什么都不会显示，不便于观察文本的大小和字体颜色等属性，此时可以为之设定默认值（文本内容或者是字体大小等属性都适用），默认值将只在预览视图中显示，且默认值不能包含引号 android:text=&quot;@{userInfo.name,default=defaultValue}&quot; 此外，也可以通过 ActivityMainBinding 直接获取到指定 ID 的控件: dataBinding.mUserName.text = &quot;lisi&quot; 自定义生成的绑定类的类名 每个数据绑定布局文件都会生成一个绑定类，ViewDataBinding 的实例名是根据布局文件名来生成，采用驼峰命名法来命名，并省略布局文件名包含的下划线。控件的获取方式类似，但首字母小写。 通过如下方式自定义 ViewDataBinding 的实例名 &lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt; 在 Fragment 和 RecyclerView 中使用 在 Fragment 中的使用 class BlankFragment : Fragment() { override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { val blankFragmentBinding: BlankFragmentBinding = DataBindingUtil.inflate(inflater, R.layout.blank_fragment, container, false) return blankFragmentBinding.root } } 在RecyclerView中使用 具体使用请参考：DataBinding 应用于RecyclerView override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerViewHolder { val itemMvvmBinding = DataBindingUtil.inflate&lt;ViewDataBinding&gt;( LayoutInflater.from(parent.context), R.layout.item_mvvm, parent, false ) itemMvvmBinding.getRoot().setOnClickListener(this) return RecyclerViewHolder(itemMvvmBinding) } override fun onBindViewHolder(holder: RecyclerViewHolder, position: Int) { val itemMvvmBinding = holder.getBinding() val userBean = data.get(position) itemMvvmBinding.setUser(userBean) //将position保存在itemView的Tag中，以便点击时进行获取 itemMvvmBinding.getRoot().setTag(position) itemMvvmBinding.btnUpdate.setOnClickListener(OnBtnClickListener(1, userBean)) itemMvvmBinding.btnDelete.setOnClickListener(OnBtnClickListener(2, position)) // 立刻执行绑定 itemMvvmBinding.executePendingBindings() } 以上实现数据绑定的方式，每当绑定的变量发生变化的时候，都需要重新向 ViewDataBinding 传递新的变量值才能刷新 UI 。接下来看如何实现自动刷新 UI 单向数据绑定 实现数据变化自动驱动 UI 刷新的方式有三种：BaseObservable、ObservableField、ObservableCollection BaseObservable 一个简单的ViewModel 类被更新后，并不会让 UI 自动更新。而数据绑定后，我们自然会希望数据变更后 UI 会即时刷新，Observable 就是为此而生的概念。 BaseObservable 提供了 notifyChange() 和 notifyPropertyChanged() 两个方法。 notifyChange() 它会刷新所有的值。 notifyPropertyChanged() 它只会根据对应的BR的flag更新，该 BR 的生成通过注释 @Bindable 生成，可以通过 BR notify 特定属性关联的视图。 由于kotlin的属性默认是public修饰，所以可以直接在属性上@Bindable, 如何设置了修饰符且不为public的话，则可使用@get BIndable（表示在get()方法上标记@Bindable） import androidx.databinding.BaseObservable import androidx.databinding.Bindable import com.github.ixiaow.sample.BR class UserInfo : BaseObservable() { // 对name进行@Bindable标志，然后会生成BR.name @Bindable var name: String = &quot;&quot; set(value) { field = value // 当name,发生改变时只会刷新与name相关控件的值，不会刷新其他的值 notifyPropertyChanged(BR.name) } @get: Bindable var password: String = &quot;&quot; set(value) { field = value // 当password 发生改变时，也会刷新其他属性相关的控件的值 notifyChange() } } 布局文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;com.github.ixiaow.sample.model.UserInfo&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView app:layout_constraintVertical_chainStyle=&quot;spread&quot; android:id=&quot;@+id/mUserName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{userInfo.name}&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{userInfo.password}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mUserName&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; OnPropertyChangedCallback 实现了 Observable 接口的类允许注册一个监听器OnPropertyChangedCallback，当可观察对象的属性更改时就会通知这个监听器。 当中 propertyId 就用于标识特定的字段 user.addOnPropertyChangedCallback(object : Observable.OnPropertyChangedCallback(){ override fun onPropertyChanged(sender: Observable, propertyId: Int) { } }) ObservableField 继承于 Observable 类相对来说限制有点高，且也需要进行notify 操作，因此为了简单起见可以选择使用 ObservableField。 可以理解为官方对 BaseObservable 中字段的注解和刷新等操作的封装，官方原生提供了对基本数据类型的封装，例如 ObservableBoolean、ObservableByte、ObservableChar、ObservableShort、ObservableInt、ObservableLong、ObservableFloat、ObservableDouble 以及 ObservableParcelable ，也可通过 ObservableField 泛型来申明其他类型。 class ObservableUser { val name = ObservableField&lt;String&gt;() val password = ObservableField&lt;String&gt;() } 对 ObservableUser属性值的改变都会立即触发 UI 刷新，概念上与Observable 区别不大，具体效果可看下面提供的源代码，这里不再赘述 ObservableCollection dataBinding 也提供了包装类用于替代原生的 List 和 Map，分别是 ObservableList 和 ObservableMap,当其包含的数据发生变化时，绑定的视图也会随之进行刷新 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;androidx.databinding.ObservableList&quot;/&gt; &lt;import type=&quot;androidx.databinding.ObservableMap&quot;/&gt; &lt;import type=&quot;com.github.ixiaow.sample.model.User&quot;/&gt; &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt; &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt; &lt;variable name=&quot;list&quot; type=&quot;ObservableList&lt;User&gt;&quot;/&gt; &lt;variable name=&quot;map&quot; type=&quot;ObservableMap&lt;String, User&gt;&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView app:layout_constraintVertical_chainStyle=&quot;spread&quot; android:id=&quot;@+id/mUserName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{list[index].name}&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{map[key].password}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mUserName&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val dataBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) dataBinding.map = ObservableArrayMap&lt;String, User&gt;().apply { &quot;android&quot; to User(&quot;android&quot;, &quot;12367&quot;) &quot;java&quot; to User(&quot;java&quot;, &quot;12534&quot;) &quot;c&quot; to User(&quot;c&quot;, &quot;12344&quot;) &quot;c++&quot; to User(&quot;c++&quot;, &quot;14423&quot;) &quot;c#&quot; to User(&quot;c#&quot;, &quot;12334&quot;) } dataBinding.key = &quot;c&quot; dataBinding.list = ObservableArrayList&lt;User&gt;().apply { add(User(&quot;android&quot;, &quot;123&quot;)) add(User(&quot;java&quot;, &quot;1234&quot;)) add(User(&quot;c&quot;, &quot;1235&quot;)) add(User(&quot;c++&quot;, &quot;123447&quot;)) } dataBinding.index = 3 } } 双向数据绑定 双向绑定的意思即为当数据改变时同时使视图刷新，而视图改变时也可以同时改变数据 看以下例子，当 EditText的输入内容改变时，会同时同步到变量 user,绑定变量的方式比单向绑定多了一个等号：android:text=&quot;@={user.name}&quot; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;com.github.ixiaow.sample.model.ObservableUser&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;EditText app:layout_constraintVertical_chainStyle=&quot;spread&quot; android:id=&quot;@+id/mUserName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@={userInfo.name, default=`name`}&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;EditText android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@={userInfo.password, default=`1234`}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mUserName&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val dataBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) val observableUser = ObservableUser() observableUser.name.set(&quot;我是name&quot;) observableUser.password.set(&quot;我是password&quot;) dataBinding.userInfo = observableUser } } 事件绑定 严格意义上来说，事件绑定也是一种变量绑定，只不过设置的变量是回调接口而已。 事件绑定可用于以下多种回调事件： android:onClick android:onLongClick android:afterTextChanged android:onTextChanged ... 新建一个 UserPresenter 类来声明 onClick() 和 afterTextChanged() 事件相应的回调方法 class UserPresenter { fun onUserNameClick(user: ObservableUser) { } fun afterTextChanged(s: Editable) { } fun saveUser(view: View, user: ObservableUser){ } } &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.sample.UserPresenter&quot;/&gt; &lt;variable name=&quot;presenter&quot; type=&quot;UserPresenter&quot;/&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;com.github.ixiaow.sample.model.ObservableUser&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;EditText app:layout_constraintVertical_chainStyle=&quot;spread&quot; android:id=&quot;@+id/mUserName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{()-&gt; presenter.onUserNameClick(userInfo)}&quot; android:text=&quot;@={userInfo.name, default=`name`}&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;EditText android:id=&quot;@+id/mPassword&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:afterTextChanged=&quot;@{presenter::afterTextChanged}&quot; android:text=&quot;@={userInfo.password, default=`1234`}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mUserName&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;EditText android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{(theView)-&gt;presenter.saveUser(theView, userInfo)}&quot; android:text=&quot;@={userInfo.password, default=`1234`}&quot; app:layout_constraintTop_toBottomOf=&quot;@id/mPassword&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; 方法引用的方式与调用函数的方式类似， 可以选择保持事件回调方法的签名一致：@{presenter.afterTextChanged}，此时方法名可以不一样，但方法参数和返回值必须和原始的回调函数保持一致。 可以引用不遵循默认签名的函数：@{()-&gt;presenter.onUserNameClick(userInfo)}，这里用到了 Lambda 表达式，这样就可以不遵循默认的方法签名，将userInfo对象直接传回点击方法中。此外，也可以使用方法引用 :: 的形式来进行事件绑定 使用类方法 首先定义一个静态方法 object StringUtils { fun toUpperCase( str:String):String { return str.toUpperCase(); } } 在 data 标签中导入该工具类 &lt;import type=&quot;com.github.ixiaow.sample.StringUtils&quot; /&gt; 然后就可以像对待一般的函数一样来调用了 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{()-&gt;userPresenter.onUserNameClick(userInfo)}&quot; android:text=&quot;@{StringUtils.toUpperCase(userInfo.name)}&quot; /&gt; 运算符 基础运算符 DataBinding 支持在布局文件中使用以下运算符、表达式和关键字 算术 + - / * % 字符串合并+ 逻辑&amp;&amp; || 二元&amp; | ^ 一元 + - ! ~ 移位&gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较== &gt; &lt; &gt;= &lt;= Instanceof Grouping () character, String, numeric, null Cast 方法调用 Field 访问 Array访问 [] 三元?: 目前不支持以下操作 this super new 显示泛型调用 此外，DataBinding 还支持以下几种形式的调用: Null Coalescing 空合并运算符 ?? 会取第一个不为 null 的值作为返回值 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{user.name ?? user.password}&quot; /&gt; 等价于 android:text=&quot;@{user.name != null ? user.name : user.password}&quot; 属性控制 可以通过变量值来控制 View 的属性 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;可见性变化&quot; android:visibility=&quot;@{user.male ? View.VISIBLE : View.GONE}&quot; /&gt; 避免空指针异常 DataBinding 也会自动帮助我们避免空指针异常 例如，如果 &quot;@{userInfo.password}&quot; 中 userInfo 为 null 的话，userInfo.password 会被赋值为默认值 null，而不会抛出空指针异常 include 和 viewStub include 对于 include 的布局文件，一样是支持通过 dataBinding 来进行数据绑定，此时一样需要在待 include 的布局中依然使用 layout 标签，声明需要使用到的变量 view_include.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.databindingsample.model.User&quot; /&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;User&quot; /&gt; &lt;/data&gt; &lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#acc&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:padding=&quot;20dp&quot; android:text=&quot;@{userInfo.name}&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; &lt;/layout&gt; 在主布局文件中将相应的变量传递给 include 布局，从而使两个布局文件之间共享同一个变量 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.databindingsample.model.User&quot; /&gt; &lt;variable name=&quot;userInfo&quot; type=&quot;User&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.Main6Activity&quot;&gt; &lt;include layout=&quot;@layout/view_include&quot; bind:userInfo=&quot;@{userInfo}&quot; /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; viewStub dataBinding 一样支持 ViewStub 布局 在布局文件中引用 viewStub 布局 &lt;ViewStub android:id=&quot;@+id/view_stub&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout=&quot;@layout/view_stub&quot;/&gt; 获取到 ViewStub 对象，由此就可以来控制 ViewStub 的可见性 ActivityMain6Binding activityMain6Binding = DataBindingUtil.setContentView(this, R.layout.activity_main6); View view = activityMain6Binding.viewStub.getViewStub().inflate(); 如果需要为 ViewStub 绑定变量值，则 ViewStub 文件一样要使用 layout 标签进行布局，主布局文件使用自定义的 bind 命名空间将变量传递给 ViewStub &lt;ViewStub android:id=&quot;@+id/view_stub&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout=&quot;@layout/view_stub&quot; bind:userInfo=&quot;@{userInfo}&quot; /&gt; 如果在 xml 中没有使用 bind:userInfo=&quot;@{userInf}&quot;对 ViewStub 进行数据绑定，则可以等到当 ViewStub Inflate 时再绑定变量，此时需要为 ViewStub 设置 setOnInflateListener回调函数，在回调函数中进行数据绑定 activityMain6Binding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() { @Override public void onInflate(ViewStub stub, View inflated) { //如果在 xml 中没有使用 bind:userInfo=&quot;@{userInf}&quot; 对 viewStub 进行数据绑定 //那么可以在此处进行手动绑定 ViewStubBinding viewStubBinding = DataBindingUtil.bind(inflated); viewStubBinding.setUserInfo(user); Log.e(TAG, &quot;onInflate&quot;); } }); BindingAdapter dataBinding 提供了 BindingAdapter 这个注解用于支持自定义属性，或者是修改原有属性。注解值可以是已有的 xml 属性，例如 android:src、android:text等，也可以自定义属性然后在 xml 中使用 例如，对于一个 ImageView ，我们希望在某个变量值发生变化时，可以动态改变显示的图片，此时就可以通过 BindingAdapter 来实现 需要先定义一个静态方法，为之添加 BindingAdapter 注解，注解值是为 ImageView 控件自定义的属性名，而该静态方法的两个参数可以这样来理解：当 ImageView 控件的 url 属性值发生变化时，dataBinding 就会将 ImageView 实例以及新的 url 值传递给 loadImage() 方法，从而可以在此动态改变 ImageView 的相关属性 @BindingAdapter({&quot;url&quot;}) public static void loadImage(ImageView view, String url) { Log.d(TAG, &quot;loadImage url : &quot; + url); } 在 xml 文件中关联变量值，当中，bind 这个名称可以自定义 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.github.ixiaow.databindingsample.model.Image&quot; /&gt; &lt;variable name=&quot;image&quot; type=&quot;Image&quot; /&gt; &lt;/data&gt; &lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/ic_launcher_background&quot; bind:url=&quot;@{image.url}&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; &lt;/layout&gt; BindingAdapter 更为强大的一点是可以覆盖 Android 原先的控件属性。例如，可以设定每一个 Button 的文本都要加上后缀：“-Button” @BindingAdapter(&quot;android:text&quot;) public static void setText(Button view, String text) { view.setText(text + &quot;-Button&quot;); } &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{()-&gt;handler.onClick(image)}&quot; android:text='@{&quot;改变图片Url&quot;}'/&gt; 这样，整个工程中使用到了 &quot;android:text&quot; 这个属性的控件，其显示的文本就会多出一个后缀 BindingConversion dataBinding 还支持对数据进行转换，或者进行类型转换 与 BindingAdapter 类似，以下方法会将布局文件中所有以@{String}方式引用到的String类型变量加上后缀-conversionString @BindingConversion public static String conversionString(String text) { return text + &quot;-conversionString&quot;; } xml 文件 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text='@{&quot;xxx&quot;}' android:textAllCaps=&quot;false&quot;/&gt; 可以看到，对于 Button 来说，BindingAdapter 和 BindingConversion 同时生效了，而 BindingConversion 的优先级要高些, 此外，BindingConversion 也可以用于转换属性值的类型 看以下布局，此处在向 background 和 textColor 两个属性赋值时，直接就使用了字符串，按正常情况来说这自然是会报错的，但有了 BindingConversion 后就可以自动将字符串类型的值转为需要的 Drawable 和 Color 了 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background='@{&quot;红色&quot;}' android:padding=&quot;20dp&quot; android:text=&quot;红色背景蓝色字&quot; android:textColor='@{&quot;蓝色&quot;}'/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;20dp&quot; android:background='@{&quot;蓝色&quot;}' android:padding=&quot;20dp&quot; android:text=&quot;蓝色背景红色字&quot; android:textColor='@{&quot;红色&quot;}'/&gt; @BindingConversion public static Drawable convertStringToDrawable(String str) { if (str.equals(&quot;红色&quot;)) { return new ColorDrawable(Color.parseColor(&quot;#FF4081&quot;)); } if (str.equals(&quot;蓝色&quot;)) { return new ColorDrawable(Color.parseColor(&quot;#3F51B5&quot;)); } return new ColorDrawable(Color.parseColor(&quot;#344567&quot;)); } @BindingConversion public static int convertStringToColor(String str) { if (str.equals(&quot;红色&quot;)) { return Color.parseColor(&quot;#FF4081&quot;); } if (str.equals(&quot;蓝色&quot;)) { return Color.parseColor(&quot;#3F51B5&quot;); } return Color.parseColor(&quot;#344567&quot;); } Array、List、Set、Map ... dataBinding 也支持在布局文件中使用 数组、Lsit、Set 和 Map，且在布局文件中都可以通过 list[index] 的形式来获取元素 而为了和 variable 标签的尖括号区分开，在声明 Lsit&lt; String &gt; 之类的数据类型时，需要使用尖括号的转义字符 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;import type=&quot;java.util.List&quot; /&gt; &lt;import type=&quot;java.util.Map&quot; /&gt; &lt;import type=&quot;java.util.Set&quot; /&gt; &lt;import type=&quot;android.util.SparseArray&quot; /&gt; &lt;variable name=&quot;array&quot; type=&quot;String[]&quot; /&gt; &lt;variable name=&quot;list&quot; type=&quot;List&lt;String&gt;&quot; /&gt; &lt;variable name=&quot;map&quot; type=&quot;Map&lt;String, String&gt;&quot; /&gt; &lt;variable name=&quot;set&quot; type=&quot;Set&lt;String&gt;&quot; /&gt; &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&lt;String&gt;&quot; /&gt; &lt;variable name=&quot;index&quot; type=&quot;int&quot; /&gt; &lt;variable name=&quot;key&quot; type=&quot;String&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView ··· android:text=&quot;@{array[1]}&quot; /&gt; &lt;TextView ··· android:text=&quot;@{sparse[index]}&quot; /&gt; &lt;TextView ··· android:text=&quot;@{list[index]}&quot; /&gt; &lt;TextView ··· android:text=&quot;@{map[key]}&quot; /&gt; &lt;TextView ··· android:text='@{map[&quot;leavesC&quot;]}' /&gt; &lt;TextView ··· android:text='@{set.contains(&quot;xxx&quot;)?&quot;xxx&quot;:key}' /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 资源引用 dataBinding 支持对尺寸和字符串这类资源的访问 dimens.xml &lt;dimen name=&quot;paddingBig&quot;&gt;190dp&lt;/dimen&gt; &lt;dimen name=&quot;paddingSmall&quot;&gt;150dp&lt;/dimen&gt; string.xml &lt;string name=&quot;format&quot;&gt;%s is %s&lt;/string&gt; layout.xml &lt;data&gt; &lt;variable name=&quot;flag&quot; type=&quot;boolean&quot; /&gt; &lt;/data&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;@{flag ? @dimen/paddingBig:@dimen/paddingSmall}&quot; android:text='@{@string/format(&quot;leavesC&quot;, &quot;Ye&quot;)}' android:textAllCaps=&quot;false&quot; /&gt; ","link":"https://xiaowujiang.cn/posts/3c6ea6b6/"},{"title":"360加固Gradle插件实现","content":"最近码了一个基于360加固的流程实现的Gradle插件，在自动编译打包后进行360加固流程操作。只需要配置一些参数后，就可以实现自动打包编译和加固。 项目地址:https://github.com/ixiaow/android-gradle-plugin 使用步骤 1. 添加依赖 在根build.gradle中添加： allprojects { repositories { maven { url &quot;https://jitpack.io&quot; } } } dependencies { ... classpath 'com.github.ixiaow:android-gradle-plugin:$version' } (请替换 $version为最新的版本号:) 在app的模块build.gradle中添加： apply plugin: 'com.github.ixiaow.jiagu' 2. 参数配置 使用这款插件需要在app的build.gradle中添加一些配置信息，如下： jiagu { home '../360jiagu' // 360加固软件的根目录 buildTypes 'release', 'debug' // 需要加固的编译类型 configs '-crashlog' // 选择360的可选配置服务 username 'user' // 360加固用户名 password 'password' // 360加固密码 charsetName 'GBK' // 360加固控制台输出字符编码 // apk签名文件， 如果在Android中配置了签名文件，此项可以不用配置，插件会自动读取名为'release'的签名文件 signingConfig { key_alias : KEY_ALIAS, key_password : KEY_PASSWORD, key_store_password: KEY_STORE_PASSWORD, key_store_file : KEY_STORE_FILE } } 3. 开始加固 确认上述参数无误后，就可以在控制台中切换到当前项目根目录执行 # 各个系统的控制台gradle命令可能不一样： ./gradlew 或 gradlew ./gradlew clean jiaGuApk 文档 android-gradle-plugin 360加固助手 360加固助手 ","link":"https://xiaowujiang.cn/posts/6c01e784/"},{"title":"Android通过Intent简单实现分享功能","content":"现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过Intent方式打开在系统中安装的具有分享功能的App的分享页面。 方法如下： public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){ Intent intent = new Intent(); intent.setAction(Intent.ACTION_SEND); intnet.setType(&quot;text/plain&quot;); PackageManager packageManager = context.getPackageManager(); List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0); return resloveInfos; } 如果只需要QQ和微信分享，可以进行如下操作： public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){ Intent intent = new Intent(); intent.setAction(Intent.ACTION_SEND); intnet.setType(&quot;text/plain&quot;); PackageManager packageManager = context.getPackageManager(); List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0); List&lt;ResolveInfo&gt; shareItems = new ArrayList(); for(ResolveInfo info: resolveInfos) { String name = info.activityInfo.packageName; if (TextUtils.equals(packageName, &quot;com.tencent.mm&quot;) || TextUtils.equals(packageName, &quot;com.tencent.mobileqq&quot;)) { shareItems.add(resolveInfo); } } return shareItems; } 通过ResolveInfo获取图标ICON和Label: Drawable drawable = resloveInfo.loadIcon(packageManager); CharSequence label = resolveInfo.loadLabel(packageManager); 通过Intent发起分享： public static void share(Context context, ResolveInfo info, String shareContent){ Intent itnent = new Intent(); intnet.setAction(Intent.ACTION_SEND); String pkg = resolveInfo.activityInfo.packageName; String cls = resolveInfo.activityInfo.name; intent.setComponent(new Component(pkg, cls)); intent.putExtra(Intent.EXTRA_TEXT, shareContent); context.startActivity(intent); } ","link":"https://xiaowujiang.cn/posts/73a6d0c4/"},{"title":"Dart 语言简述","content":"最近开始接触Flutter相关的项目，通过源码、例子和一些资料的阅读，发现如果掌握了Dart的一些语法和一些基础对于Flutter的学习有着事半功倍的效果。下面是我在查阅一些资料和实际的开发中的一些总结。希望对今后的学习有所帮助。 Dart 诞生于 2011.10.10 日， 谷歌 Dart 语言项目的领导人 Lars Bak 在丹麦举行的Goto 会议上 布， Dart 种“结构化的 Web 程”语言， Dart 编程语言在所有现代浏览器和环境中提供高性能。 Dart语言的特性： Dart 是AOT（Ahead Of Time）编译的，编译成快速、可预测本地的代码。 Dart也可以JIT（Just In Time）编译，开发周期异常快，包括Flutter流行的亚秒级有状态热重载。 Dart可以更轻松地创建以60fps运行的流畅动画和状态，Dart可以在没有锁的情况下进行对象分配和垃圾回收。 Dart使Flutter不需要单独的声明式布局语言，或单独的可视化界面构建器，因为Dart的声明式编程布局易于阅读和可视化。 Dart重要概念： 一切皆对象，无论是变量、数字、函数等都是对象，所有的对像都继自Object， 这点类似于 Java 语言。 程序中指定数据类型使得程序合理地分配内存空间，并帮助编绎器进行语法检查，由于Dart 言是弱数据类型， 所以类型不是必须的 。 Dart 代码在运行前解析 指定数据类型和编译时的常量， 可以提高运行速度。 Dart 程序有统 的程序人口： main （） 这一点与 Java C 和 C＋＋ 语言很像。 Dart 没有 public protected private 这些修饰符的概念，私有特性通过变量或函数加上下划线来表示。 Dart 工具可以检查出警告信息(warning) 和 错误信息(errors)， 警告信息只是表明代码可能不工作，但是不会妨碍程序运行，错误信息可以是编译时的错误，也可能是运行时的错误， 编译时的错误将阻止程序运行，运行时的错误将会以异常（exception ）的方式呈现。 Dart 支持 anync/await 异步处理。 关键字（ 56 个）如下： 带有上标 1 的关键字是 内置关键字。避免把内置关键字当做标识符使用。 也不要把内置关键字 用作类名字和类型名字。 带有上标 2 的关键字，是在 Dart 1.0 发布以后又新加的，用于支持异步相关的特性。 变量与基本类型 变量的声明 在Dart里，变量的声明有三种方式： 用var关键字 用var声明变量时，如果未指定初始值，可以变成任意类型。如果指定了类型，则类型会被锁定。如： void main() { var v; // 初始值未指定类型 v = '2'; // 可以变为任意类型 v = 3; print('v: $v'); var v1 = '111'; // 初始化时已经指定类型 var v1 = 222; // 此时无法赋值成功，编译时报错 } 用dynamic关键字 dynamic声明的变量，表示动态任意类型，编译时不检查类型。如： void main() { dynamic d1 = '111'; d1 = 222; d1 = 333.0; print(&quot;d1: $d1&quot;); // dynamic修饰的变量，在编译时不做检查 d1.test(); // 这行还代码，在编译时是不会检查错误信息的，运行时会报错 } 用Object Object声明的变量，表示任意动态类型，编译时检查类型。如： void main() { Object o1 = &quot;sss&quot;; o1 = 222; o1.test(); // 编译时会做检查，报错 } 变量的默认值 没有初始化的变量会自动获取一个默认值null 一切皆为对象，对象的默认值为null final 和 const ​ final 或 const 修饰的变量为常量或固定值。 共同点： 声明的类型可以省略 初始化后不能再赋值 不能和var同时使用 不同点： 类级别常量，使用 static const const 可以使用其它const常量的值来初始化其值 使用const赋值声明，const可省略 可以更改非final、非const变量的值，即使曾经具有const值 const 导致的不可变性是可传递的 相同的const常量不会在内存中重复创建 const需要编译时常量 基本类型 Dart语言常用的基本数据类型包括： Number，String，Boolean，List和Map Number类型 Number 类型包括 int 整形，double浮点类型，他们都是num类型的子类 String类型 Dart 字符串是 utf-16 编码的字符序列，可以使用单引号或者双引号来创建字符 可以使用三个单引号或者双引号创建多行字符串对象 可以使用r前缀创建原始字符串，即输出原始字符，字符串里的转义等符号不会生效 可以在字符串中使用表达式：&quot;${expression}&quot;，如果表达式是一个标识符，可以省略{}，如果表达式的结果为一个对象，则 Dart会调用对象的toString方法 Boolean类型 Dart是强bool类型检查，只有bool类型的值是true才被认为是true， 如果未赋初值，则为null List类型 在Dart语言中，具有一系列相同类型的数据称为List对象。Dart中List可以直接打印出出各个元素，而java中则是地址。 Map类型 与java类似。 Set set1.difference(set2): 返回 set1 集合里有但 set2 里没有的元素集合 set1.intersection(set2)：返回set1和set2的交集 set1.union(set2)：返回set1和set2的并集 set1.retainAll()：set1只保留某些元素(要保留的元素要在原set中存在） Runs 用在符串中表示Unicode字符 使用String.fromCharCodes显示字符图形 如果非4个数值，需要把编码值放到大括号中 函数 Dart是一个面向对象的语言,所以函数也是对象，函数属于Function对象。函数可以像参数一样传递给其他函数。 函数定义 定义函数时可以省略类型(不建议) void func(a, b){} // 参数a,b都省略了类型 支持缩写语法=&gt; void main() =&gt; runApp(MyApp()); // 当函数体只有一条语句时可以使用此种写法 可在函数内定义函数 可以在函数里定义函数，如： int func(int a, int b) { int sum(int a, int b, int c) { return a + b + c; } return sum(a, b, 1); } dart 函数支持闭包 Function addFunction(int a) { return (y) =&gt; a + y; } void main() { var addFunc = addFunction(12); print(addFunc(22)); } 函数返回值 所有的函数都有返回值 如果没有指定函数返回值，则默认的返回值是null 没有返回值的函数,系统会在最后添加隐式的return语句 可选参数 可选命名参数 使用{param1, param2,...}的形式来指定命名参数。 main() { func(a:1); func(b:1); func(a:1, b:1); } int func({int a, int b}) { return a + b; } 可选位置参数 将参数使用中括号[]括起来,用来表明是可选位置参数，必填参数要放在可选参数前面。 String getUserInfo(String name, String sex, [String from]) {} 其中name和sex是必须传入的参数,from参数可以不传 参数默认值 如果参数指定了默认值,当不传入值时，函数就会使用这个默认值。通常默认值参数为null。 String getUserInfo(String name, String sex, [String from = '中国']) {} 可选命名参数默认值(默认值必须是编译时常量)，可以使用等号= 或冒号:，Dart SDK 1.21 之前只能用冒号，冒号的支持以后会移除，所以建议使用等号。 可选位置参数默认值(默认值必须是编译时常量)，只能使用等号=。 可使用list或map作为默认值，但必须是const。 int fun([List list = const [1, 2, 3]]) {} 匿名函数 可赋值给变量，通过变量调用 main() { var func = (int a, int b) =&gt; a + b; func(1, 2); } 可在其他函数中直接调用或传递给其他函数 函数别名 函数别名使用typedef表示，如： typedef Fun1(int a, int b); typedef Fun2&lt;T, K&gt;(T a, K b); typedef给函数起一个别名，使用比较方便。例如定义一个方法的回调，直接使用别名定义。 没返回值，则只要参数匹配就行了，如果定义了返回值，则返回值不一样会报错。 main函数 Flutter应用程序必须要有一个main函数作为程序的入口函数。 运算符 Dart所有的运算符如下表所示， 与java不同的有8个，如下： ?.，条件成员访问 和 . 类似，但是左边的操作对象不能为 null，例如 foo?.bar 如果 foo 为 null 则返回 null，否则返回 bar 成员。 ~/，除后取整。 as，类型转换。 is，如果对象是指定类型返回true。 is!，如果对象是指定类型返回false。 ??，双问号左边为true返回左边结果，否则返回右边结果。 ..，级联语法。严格来说， 两个点的级联语法不是一个操作符。 只是一个 Dart 特殊语法。 ??:，如果左边是 null，则右边赋值给左边；如果不是 null，则左边的值保持不变。 描述 操作符 后缀操作 expr++ expr-- () [] . ?. 前缀操作 -expr !expr ~expr ++expr --expr 乘除 * / % ~/ 加减 + - 位移 &lt;&lt; &gt;&gt; 按位与 &amp; 按位异或 ^ 按位或 | 类型操作 &gt;= &gt; &lt;= &lt; as is is! 相等 == != 逻辑与 &amp;&amp; 逻辑或 || 是否为空 ?? 三目运算 expr1 ? expr2 : expr3 级联 .. 赋值 = *= /= ~/= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |= ??= 流程控制语句 Dart中控制流程语句和Java类似。List和Set等实现了Iterable接口的类支持for-in遍历元素。 if else for forEach for-in while do-while break continue switch case assert try-catch throw 异常处理 异常是表示发生意外错误，如果没有捕获异常，引发异常的隔离程序将被挂起，并且程序终止。 Dart代码可抛出并捕获异常，但Dart的所有异常都是未检查异常，方法不声明他们可能抛出的异常,也不需要捕获任何异常。 Dart 代码可以抛出任何非 null 对象为异常，不仅仅是实现了 Exception 或者 Error 的对象。 可以使用on 或者 catch 来声明捕获语句，也可以 同时使用。使用 on 来指定异常类型，使用 catch 来 捕获异常对象。 抛出异常 // 抛出Exception对象 throw FormatException('抛出一个ｆormatException') // 抛出Error对象 throw OutMemoryError(); //或自定义异常 throw '数据非法' 捕获异常 catch() 可以指定一个或两个参数来捕获异常，第一个是抛出的异常，第二个是堆栈跟踪，如： try { ... } on Error catch (e) { // 捕获异常详细信息 } catch (e, s) { // 堆栈跟踪信息 } rethrow 把捕获的异常重新抛出 Finally 面向对象 Dart作为高级语言支持面向对象的很多特性并且支持基于mixin的继承方式。基于mixin的继承方式是值：一个类可以继承多个父类，相当于其他语言里的多继承，所有的类都有同一个基类Object。 实例化成员变量 类定义中所有的变量都会隐式的定义Setter方法，针对非空的变量会额外增加getter方法 构造函数 dart的构造函数有多种形式，如下： 常规构造函数 class User { String name; int age; User(String name, int age) { this.name = name; this.age = age; } // 或 User(this.name, this.age); } 命名的构造函数 class User { String name; int age; User.fromJson(Map json) { name = json['name']; age = json['age']; } } 使用命名构造函数可以为一个类实现多个构造函数， 或者使用命名构造函数来更清晰的表明你的意图。 重定向构造函数 class User { String name; int age; User(this.name, this.age); User.create(String name): this(name,12); } 一个重定向构造函数是没有代码的，在构造函数声明后，使用 冒号调用其他构造函数。 构造函数初始化列表 class User { // final 修饰的成员变量，只能通过构造方法进行赋值 final String name; final int age; // 初始化列表 User(name, age) : name = name, age = age; } 在构造函数体执行之前可以初始化实例参数。 使用逗号分隔初始化表达式。初始化列表非常适合用来设置 final 变量的值。 调用超类构造函数 在构造方法处使用super关键字，如： class User extends Person { // final 修饰的成员变量，只能通过构造方法进行赋值 final String name; final int age; // 初始化列表 User(this.name, this.age):super(name,age); } 常量构造函数 class User { // 定义const构造函数要确保所有的成员变量都是final修饰 final String name; final int age; static final User user = const User('111', 12); // const 关键字放在构造函数名前，且不能有函数体 const User(this.name, this.age); } 工厂构造函数(单例) class User { String name; //工厂构造函数无法访问this，所以这里要用static static User _user; //工厂方法构造函数，关键字factory factory User([String name]) { return User._user ??= User._(name); } //定义一个命名构造函数用来生产实例 User._(this.name); } 读取和写入对象（Getter、Setter） get()和set()方法是专门用于读取和写入对象的属性的方法。 每一个类的实例，系统都隐式地包含有get()和set()方法。 final 修饰的变量没有setter方法。 可以使用get 和 set 关键字定义getter和setter。 class User { String name; User(this.name); String get username =&gt; 'getter ${this.name}'; set username(String name) =&gt; this.name = name; } 重载操作 采用operator修饰，如： class Vector { final int x; final int y; const Vector(this.x, this.y); Vector operator +(Vector v) { return Vector(x + v.x, y + v.y); } } 抽象类 抽象类采用abstract关键字修饰class。f 不能被实例化，除非定义一个工厂构造函数。 抽象类通常用来定义接口， 以及部分实现。 抽象类通常具有抽象方法，抽象方法不需要关键字，以分号结束即可。 接口方式使用时，需要重写抽象类的成员变量和方法，包括私有的。 一个类可以implement一个普通类。Dart任何一个类都是接口。 一个类可以implement多个接口。 可调用类 类实现 call() 方法可以让类像函数一样能够被调用。 class ClassFunction { call(String a, String b, String c) =&gt; '$a, $b, $c'; } main() { var cf = ClassFunction(); var out = cf('a1', 'b1', 'c1'); print('out: $out'); print(cf.runtimeType); print(out.runtimeType); print(cf is Function); } 枚举类 与java一致，采用enum修饰。 enum Type { A, B, C } Mixins Mixins(混入功能)相当于多继承，使用with关键字来实现Mixins的功能 class S { a() =&gt; print('S.a'); } class A { a() =&gt; print('A.a'); b() =&gt; print('A.b'); } class T = A with S; 子类没有重写超类A方法的前提下，如果2个或多个超类拥有相同签名的A方法，那么子类会以继承的最后一个超类中的A方法为准。 如果子类自己重写了A方法则以本身的A方法为准。 泛型 Dart1.21开始可以使用泛型函数。泛型函数可以在以下几个地方使用类型参数： 函数的返回值类型。 参数的类型。 局部变量的类型。 main() { K addCache&lt;K, V&gt;(K key, V value) { K temp = key; print('${key}: ${value}'); return temp; } var key = addCache('key', 'value'); print(key); } 要在使用构造函数时指定一个或多个类型，可将类型放在类名称后面的尖括号&lt;...&gt;中: main() { var p = Phone&lt;String&gt;('123456'); print(p.mobileNumber); } class Phone&lt;T&gt; { final T mobileNumber; Phone(this.mobileNumber); } 实现泛型类型时，您可能希望限制其参数的类型，可以在&lt;&gt;里面使用extends。 main() { var man = Man(); var m = User&lt;Man&gt;(man); m.man.doMassage(); } class User&lt;T extends Man&gt; { final T man; User(this.man); } class Man { void doMassage() {} } 与java一致， 唯一区别：Java泛型是编译时的，在运行时泛型信息会被擦除，Dart的泛型类型是固化的，在运行时也可以判断具体类型。 var names = List&lt;String&gt;(); print(names is List&lt;String&gt;);//true print(names.runtimeType); // List&lt;String&gt; 库的使用 引用库 通过import语句在一个库中引入另一个库文件： 在import语句后面需要接上库文件的路径 对dart语言提供的库文件使用dart:xx格式 第三方的库文件使用package:xx格式 import 'dart:io'; import 'package:mylib/mylib.dart'; import 'package :utils/utils.dart' ; 指定一个库的前缀 当引用的库拥有相互冲突的名字，可以为其中一个或几个指定不一样的前缀。 import 'package:libl/ libl.dart '; import 'package:lib2 / lib2.dart ' as lib2 ; 引用库的一部分 如果只需要使用库的一部分内容，可以有选择性地引用，有如下关键字： show 关键字： 只引用一点 hide 关键字： 除此之外都引用 ／／ 导入 foo import 'package:libl/libl.dart' show foo; ／／ 除了 foo 导入其他所有内容 import 'package:lib2 / lib2.dart' hide foo; 库的延迟载入 使用deferred as导入 使用标识符调用loadLibrary() 加载库 import 'dart:io' deferred as io; lazyLoad() async { //使用 await 关键字暂停代码执行一直到库加载完成。 await io.loadLibrary(); } main() { lazyLoad(); } 优点： 可提高程序启动速度。 用在不常使用的功能。 用在载入时间过长的包。 执行 A/B 测试，例如 尝试各种算法的 不同实现。 异步使用 Dart支持异步操作，一般使用async函数和await表达式实现异步操作，Dart库提供asynchronous功能,该功能提供接口来消耗时间的操作，比如文件读写,网络请求。该功能返回Future或Stream对象。 可以通过如下的方式来获取asynchronous功能返回的Future对象值: 使用async函数和await表达式 使用Future功能提供的API 可以通过如下方式来获取asynchronous功能返回的Stream对象的值: 使用async和一个异步的循环(await for) 使用Stream的相关API async / await await关键字必须在async函数内部使用，await表达式可以使用多次 void main(){ getName1(); getName2(); getName3(); } Future getName1() async { await getStr1(); await getStr2(); print('getName1’); } getStr1() { print('getStr1’); } getStr2() { print('getStr2’); } getName2() { print('getName2’); } getName3() { print('getName3’); } /// 输出结果： getStr1 getName2 getName3 getStr2 getName1 then,catchError,whenComplete 如果需要监听“完毕”这个状态，那么用whenComplete，需要监听“成功”这个状态，用then，需要监听“失败”这个状态，用catchError。 如果重写了test方法，test返回true就可以在catchError的onError方法里捕获到异常，如果test返回false，就把该异常继续抛出而不会在catchError方法里被捕获，如果不写test默认实现一个返回true的test方法 void main() { Future(() =&gt; futureTask()) //异步任务的函数 .then((m) =&gt; &quot;result:$m&quot;) //任务执行完后的子任务 .then((m) =&gt; m.length) //其中m为上个任务执行完后的返回的结果 .then((m) =&gt; printLength(m)) .catchError(print) // 拦截错误，如果实现了test方法，只有return true时才会拦截，否则不会 .whenComplete(() =&gt; whenTaskCompelete()); //所有任务完成后的回调函数 } whenTaskCompelete() { print('task complete'); } futureTask() async { return 'future'; } printLength(dynamic name) { if (name is! String || name.length &lt; 3 || name.length &gt; 15) { throw '长度错误'; } } Event-Looper 一个消息循环的职责就是不断从消息队列中取出消息并处理他们直到消息队列为空。 消息队列中的消息可能来自用户输入，文件I/O消息，定时器等。例如上图的消息队列就包含了定时器消息和用户输入消息。 Dart中的Main Isolate只有一个Event Looper，但是存在两个Event Queue: Event Queue以及Microtask Queue。 Event Queue和Microtask Queue 优先全部执行完Microtask Queue中的Event。 直到Microtask Queue为空时，才会执行Event Queue中的Event。 当Event Looper正在处理Microtask Queue中的Event时候，Event Queue中的Event就停止了处理了，此时App不能绘制任何图形，不能处理任何鼠标点击，不能处理文件IO等等。 绘制图形，处理鼠标点击，处理文件IO等都是在Event Queue里完成的。 任务调度 使用Future类，可以将任务加入到Event Queue的队尾 使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾 优先全部执行完Microtask Queue中的Event，直到Microtask Queue为空时，才会执行Event Queue中的Event。 Future 使用 Future（）将任务加入event队列。 Future中的then并没有创建新的Event丢到Event Queue中，而只是一个普通的Function Call，在FutureTask执行完后，立即开始执行。 如果在then()调用之前Future就已经执行完毕了，那么任务会被加入到microtask队列中，并且该任务会执行then()中注册的回调函数。 使用Future.value构造函数的时候，就会上一条一样，创建Task丢到microtask Queue中执行then传入的函数。 Future.sync构造函数执行了它传入的函数之后，也会立即创建Task丢到microtask Queue中执行。 当任务需要延迟执行时，可以使用new Future.delay()来将任务延迟执行。 void main(){ testFuture(); } void testFuture() { Future f = new Future(() =&gt; print('f1')); Future f1 = new Future(() =&gt; null); //Future f1 = new Future.delayed(Duration(seconds: 1) ,() =&gt; null); Future f2 = new Future(() =&gt; null); Future f3 = new Future(() =&gt; null); f3.then((_) =&gt; print('f2')); f2.then((_) { print('f3'); new Future(() =&gt; print('f4')); f1.then((_) { print('f5'); }); }); f1.then((m) { print('f6'); }); print('f7'); } scheduleMicrotask() 如果可以，尽量将任务放入event队列中。 使用Future的then方法或whenComplete方法来指定任务顺序。 为了保持你app的可响应性，尽量不要将大计算量的任务放入这两个队列。 大计算量的任务放入额外的isolate中。 import 'dart:async'; void main(){ testScheduleMicrotask(); } void testScheduleMicrotask(){ scheduleMicrotask(() =&gt; print('s1')); new Future.delayed(new Duration(seconds: 1), () =&gt; print('s2')); new Future(() =&gt; print('s3')).then((_) { print('s4'); scheduleMicrotask(() =&gt; print('s5')); }).then((_) =&gt; print('s6')); new Future(() =&gt; print('s7')); scheduleMicrotask(() =&gt; print('s8')); print('s9'); } 隔离（isolate） 所有Dart代码都在隔离区内运行，而不是线程。每个隔离区都有自己的内存堆，确保不会从任何其他隔离区访问隔离区的状态。 Dart没有共享内存的并发，没有竞争的可能性所以不需要锁，也就不用担心死锁的问题。 isolate之间没有共享内存，所以他们之间的通信唯一方式只能是通过Port进行，而且Dart中的消息传递总是异步的。 isolate神似Thread，但实际上两者有本质的区别。操作系统内的线程之间是可以有共享内存的而isolate没有，这是最为关键的区别。 元数据 使用元数据给代码添加更多的信息。元数据是以＠开始的修饰符，在＠后面接着编译时的常量或者一个常量构造函数。 @deprecated 被弃用 @override 重写 @proxy 代理 元数据可以修饰 library、class、typedef、type parameter、constructor、factory、function、field、parameter、variable declaration。 注释 单行注释以//开头。Dart编译器会忽略//和行尾之间的所有内容。 // 这是单行注释 多行注释以/开头，以/结尾。介于/*和 */两者之间的内容会被编译器忽略（除非该注释是一个文档注释)。 /* * 这是多行注释 * 这是多行注释 */ 多行注释可以嵌套 文档注释以///或者/**开头。可以通过dartdoc命令导出文档。 /// 这是文档注释 /** * 这是文档注释 */ ","link":"https://xiaowujiang.cn/posts/b8c700d2/"},{"title":"Git切换分支保存修改的代码","content":"在使用git同步代码的过程中，也许会碰到一个项目有好几个分支的情况，就拿我最近的项目来说，我创建了两个分支：master和dev。 经常是在dev分支上开发好了，然后切换到master分支上进行merge, 但是有时候在dev分支上开发了一半，忽然又需要去master上改个需求或者bug，这时候该当如何呢？ 在这个场景下，我查找到了两种方式： 及时commit代码 在dev分支上把已经完成的部分commit后，不push，然后切换到master分支，改完后再commit 使用 git stash 有时候，在dev分支上写的代码，没有编译通过，就需要切换到master分支， 在这种情况下（代码还没有经过测试通过，还无法commit）可以使用git stash。 保存dev当前的修改 在命令行输入： git stash //会生成一个hash值作为版本标志 或者 git stash save &quot;修改的信息&quot; //会将`修改的信息`作为版本标志 这样你的代码就回到了上一个commit了。接下来就可以切换到master分支了。 返回到dev分支 当修改完master分支后，可以通过 git stash pop //将栈中的最后一个取出来 或者 git stash list //可以看到所有的版本信息 然后选择列表项，执行 git stash apply stash@{0} //git stash apply stash@{0}的作用是可以指定栈中的一个版本 ","link":"https://xiaowujiang.cn/posts/ec91b04f/"}]}