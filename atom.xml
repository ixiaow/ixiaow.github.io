<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jxiaow.gitee.io</id>
    <title>Xiaowu</title>
    <updated>2020-12-18T09:47:54.116Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jxiaow.gitee.io"/>
    <link rel="self" href="https://jxiaow.gitee.io/atom.xml"/>
    <subtitle>心若没有栖息的地方，到哪里都是在流浪</subtitle>
    <logo>https://jxiaow.gitee.io/images/avatar.png</logo>
    <icon>https://jxiaow.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Xiaowu</rights>
    <entry>
        <title type="html"><![CDATA[高级UI]]></title>
        <id>https://jxiaow.gitee.io/posts/b1e45c68/</id>
        <link href="https://jxiaow.gitee.io/posts/b1e45c68/">
        </link>
        <updated>2020-12-17T09:33:22.000Z</updated>
        <summary type="html"><![CDATA[<p>最近正在整理以前总结的关于 <strong>Android高级UI</strong> 相关的知识，本篇文章只是一个目录，用于进行文章归档。</p>
<h2 id="ui-思维导图">UI 思维导图</h2>
]]></summary>
        <content type="html"><![CDATA[<p>最近正在整理以前总结的关于 <strong>Android高级UI</strong> 相关的知识，本篇文章只是一个目录，用于进行文章归档。</p>
<h2 id="ui-思维导图">UI 思维导图</h2>
<!--more-->
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/18/a2ef4c3408499946f29c077badbe5130-Android%20UI%20-08a2ed.png" alt="Android UI " loading="lazy"></figure>
<h2 id="ui-测量布局绘制流程">UI 测量布局绘制流程</h2>
<p><a href="https://jxiaow.gitee.io/posts/69abe299/">整体绘制流程</a> <a href="https://jxiaow.gitee.io/posts/cd03afe4/">布局绘制入口</a> <a href="https://jxiaow.gitee.io/posts/a920adc7">测量流程</a>  <a href="https://jxiaow.gitee.io/posts/6f6ae2ee">布局流程</a>  <a href="https://jxiaow.gitee.io/posts/94ccb851">绘制流程 </a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Paint高级应用---Shader]]></title>
        <id>https://jxiaow.gitee.io/posts/36c3e87b/</id>
        <link href="https://jxiaow.gitee.io/posts/36c3e87b/">
        </link>
        <updated>2020-12-15T01:40:13.000Z</updated>
        <summary type="html"><![CDATA[<p>Paint的高级用法主要有：<strong>渲染着色</strong>、<strong>滤镜</strong> 和 <strong>Xfermode</strong>。</p>
<p><code>Canvas</code>的<code>drawXXX</code>方法画具体的形状，<code>Paint</code>的<code>Shader</code>定义图像的着色和外观。</p>
<p>目前 <code>Shader</code>的子类有 <strong>LinearGradient(线性渲染)</strong>、<strong>SweepGradient(渐变渲染/梯度渲染)</strong>、<br>
<strong>RadialGradient(环形渲染)</strong>、**BitmapShader(位图渲染) **   和 <strong>ComposeShader(组合渲染)</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Paint的高级用法主要有：<strong>渲染着色</strong>、<strong>滤镜</strong> 和 <strong>Xfermode</strong>。</p>
<p><code>Canvas</code>的<code>drawXXX</code>方法画具体的形状，<code>Paint</code>的<code>Shader</code>定义图像的着色和外观。</p>
<p>目前 <code>Shader</code>的子类有 <strong>LinearGradient(线性渲染)</strong>、<strong>SweepGradient(渐变渲染/梯度渲染)</strong>、<br>
<strong>RadialGradient(环形渲染)</strong>、**BitmapShader(位图渲染) **   和 <strong>ComposeShader(组合渲染)</strong>。</p>
<!--more-->
<h2 id="tilemode-拉伸形式">TileMode （拉伸形式）</h2>
<p>TileMode 拉伸方式，在Shader的创建中会用到。<strong>只在图片和显示区域大小不符的情况进行扩充渲染</strong>，<code>TileMode</code>源码定义如下：</p>
<pre><code class="language-java">public enum TileMode {
   /**
    * replicate the edge color if the shader draws outside of its
    * original bounds
    */
    CLAMP   (0),
   /**
    * repeat the shader's image horizontally and vertically
    */
    REPEAT  (1),
   /**
    * repeat the shader's image horizontally and vertically, alternating
    * mirror images so that adjacent images always seam
    */
    MIRROR  (2);
}
</code></pre>
<p>从源码定义上可以看到<code>TileMode</code>是一个枚举类，定义了3种类型：<code>CLAMP</code>、<code>REPEAT</code>和 <code>MIRROR</code>。</p>
<h3 id="clamp">CLAMP</h3>
<p><code>CLAMP</code> 拉伸最后一个像素铺满容器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/c7780467b65c9784507b7d78720d19d3-avatar-0ace00.jpg" alt="avatar" loading="lazy"> <img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/c4921c5f1dc208da89f709bedbc7114d-image-20201210160303691-4c6ae5.png" alt="image-20201210160303691" loading="lazy"></p>
<p>代码如下：</p>
<pre><code class="language-kotlin">// 获取Bitmap
private val bitmap: Bitmap = BitmapFactory.decodeResource(resources, R.drawable.avatar)
private val paint = Paint()
 
init {
    // 初始化BitmapShader,并将 x,y的拉伸模式设置为CLAMP
    paint.shader = BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
}
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.drawRect(100f,0f,bitmap.width.toFloat() * 2,bitmap.height * 2f,paint)
}
</code></pre>
<h3 id="mirror">MIRROR</h3>
<p>横向和纵向不足处不断翻转镜像平铺。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/49950ca69ea172128172bf76c1309974-image-20201210161154210-bbc751.png" alt="image-20201210161154210" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-kotlin">// 获取Bitmap
private val bitmap: Bitmap = BitmapFactory.decodeResource(resources, R.drawable.avatar)
private val paint = Paint()
 
init {
    // 初始化BitmapShader,并将 x,y的拉伸模式设置为MIRROR
    paint.shader = BitmapShader(bitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR)
}
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.drawRect(100f,0f,bitmap.width.toFloat() * 2,bitmap.height * 2f,paint)
}
</code></pre>
<h3 id="repeat">REPEAT</h3>
<p>横向和纵向不足时重复放置，类似于电脑壁纸。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/83261140255f9d0895b5ac2be7108ffd-image-20201210161732543-f37dc2.png" alt="image-20201210161732543" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-kotlin">// 获取Bitmap
private val bitmap: Bitmap = BitmapFactory.decodeResource(resources, R.drawable.avatar)
private val paint = Paint()
 
init {
    // 初始化BitmapShader,并将 x,y的拉伸模式设置为REPEAT
    paint.shader = BitmapShader(bitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)
}
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.drawRect(100f,0f,bitmap.width * 2f,bitmap.height * 1.5f,paint)
}
</code></pre>
<h2 id="线性渲染-lineargradient">线性渲染 LinearGradient</h2>
<p><code>LinearGradient</code>用来实现线性渐变效果。</p>
<pre><code class="language-java">public class LinearGradient extends Shader {}
</code></pre>
<p>渐变效果：</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/b21809293ec73ddd2f9f6f6fd60be59e-image-20201210174046124-491aec.png" alt="image-20201210174046124" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val linearGradient = LinearGradient(0f, 0f, 500f, 300f, Color.RED, Color.BLUE, Shader.TileMode.CLAMP)
    paint.shader = linearGradient
    canvas.drawRect(0f, 0f, 800f, 800f, paint)
}
</code></pre>
<p>使用效果：</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/0b9f21e195bc13c54cc2c5a5943b4382-image-20201210162543735-7d47de.png" alt="image-20201210162543735" loading="lazy"></figure>
<pre><code class="language-kotlin">// 0x22ffffff, -0x1, 0x22ffffff
class LinearGradientText @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : AppCompatTextView(context, attrs, defStyleAttr) {
    // 线性渐变
    private var linearGradient: LinearGradient? = null
    // 平移matrix
    private val translateMatrix: Matrix = Matrix()
    // 平移变量默认值
    private var defaultX: Float = 20f
    // 平移量间隔值
    private var translateX: Float = 0f
 
    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        // 获取文本值
        val text = text.toString()
        // 获取文本的测量宽度
        val measureTextWidth = paint.measureText(text)
        val gradientSize = measureTextWidth / text.length * 3
        linearGradient = LinearGradient(
            -gradientSize, 0f, 0f, 0f,
            intArrayOf(0x22ffffff, -0x1, 0x22ffffff), null, Shader.TileMode.CLAMP
        )
        paint.shader = linearGradient
    }
 
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        translateX += defaultX
        val measureTextWidth = paint.measureText(text.toString())
        val count = if (lineCount &gt; 1) lineCount - 1 else 1
        if (translateX &gt; measureTextWidth / count || translateX &lt; 1) {
            defaultX = -defaultX
        }
        translateMatrix.setTranslate(translateX, 0f)
        linearGradient?.setLocalMatrix(translateMatrix)
        postInvalidateDelayed(50)
    }
}
</code></pre>
<h2 id="位图渲染-bitmapshader">位图渲染 BitmapShader</h2>
<p><code>BitmapShader</code> 位图图像渲染，用<code>Bitmap</code>对绘制的图形进行渲染着色，简单来说是用图片对图形进行贴图。</p>
<p>在<strong>TileMode</strong>中已有基本使用，具体请看 <a href="#CLAMP">CLAMP</a>。</p>
<p>以下使用代码公共部分：</p>
<pre><code class="language-kotlin">class GradientView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {
 
    private val bitmap: Bitmap = BitmapFactory.decodeResource(resources, R.drawable.avatar)
    private var bWidth: Int = 0
    private var bHeight: Int = 0
    private val paint = Paint()
    private var bitmapShader: BitmapShader? = null
    private val shapeMatrix = Matrix()
    private val rectF = RectF()
 
    init {
        // 获取资源图片
        bWidth = bitmap.width
        bHeight = bitmap.height
        /**
         * TileMode.CLAMP 拉伸最后一个像素去铺满剩下的地方
         * TileMode.MIRROR 通过镜像翻转铺满剩下的地方。
         * TileMode.REPEAT 重复图片平铺整个画面（电脑设置壁纸）
         * 在图片和显示区域大小不符的情况进行扩充渲染
         */
        bitmapShader = BitmapShader(bitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)
        paint.shader = bitmapShader
    }
 
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
}
</code></pre>
<ul>
<li>圆形头像</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/18499d4ef9f62abaacf05392847fde4d-image-20201210164831234-e00d13.png" alt="image-20201210164831234" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    // 坐标轴移动1/4的原因是，坐标轴移动1/4的位置为原点，然后将图片缩放后，图片的顶点与原点重合
    // 进行画园时刚好位于正中心，切换切割的图片也是图片的y中心部分
    canvas.translate(width / 4f, height / 4f)
    paint.shader = bitmapShader
    paint.isAntiAlias = true
    // 图片缩放
    val scale = max(bWidth, bHeight) / min(bWidth, bHeight) * 1.0f
    shapeMatrix.setScale(scale, scale)
    shader.setLocalMatrix(shapeMatrix)
    canvas.drawCircle(bHeight / 2f, bHeight / 2f, bHeight / 2f, paint)
}
</code></pre>
<ul>
<li>椭圆头像</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/4edc446d253def1781495fe8c9c67c87-image-20201210171000171-61fc7c.png" alt="image-20201210171000171" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    // 坐标轴移动1/4的原因是，坐标轴移动1/4的位置为原点，然后将图片缩放后，图片的顶点与原点重合
    // 进行画园时刚好位于正中心，切换切割的图片也是图片的y中心部分
    canvas.translate(width / 4f, height / 4f)
    paint.shader = bitmapShader
    paint.isAntiAlias = true
    // 图片缩放
    val scale = max(bWidth, bHeight) / min(bWidth, bHeight) * 1.0f
    shapeMatrix.setScale(scale, scale)
    shader.setLocalMatrix(shapeMatrix)
    rectF.set(0f, 0f, bWidth + 100f, bHeight.toFloat())
    canvas.drawOval(rectF, paint)
}
</code></pre>
<ul>
<li>矩形头像</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/b83368302c591bd70b22d537a616144e-image-20201210171452728-8823d8.png" alt="image-20201210171452728" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
       canvas.translate(width/4, height/4)
    paint.shader = bitmapShader
    // 抗锯齿
    paint.isAntiAlis = true
    val scale = max(bWidth, bHeight) / min(bWidth, bHeight)
    shapeMatrix.setScale(scale,scale)
    paint.shader.setLocalMatrix(shapeMatrix)
    rectF.set(0f, 0f, bWidth.toFloat(), bHeight.toFloat())
    canvas.drawRect(rectF,paint)
}
</code></pre>
<ul>
<li>ShapeDrawable实现头像</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/18499d4ef9f62abaacf05392847fde4d-image-20201210164831234-e00d13.png" alt="image-20201210164831234" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.translate(width / 4f, height / 4f)
    paint.shader = bitmapShader
    paint.isAntiAlias = true
    // 图片缩放
    val scale = max(bWidth, bHeight) / min(bWidth, bHeight)
    shapeMatrix.setScale(scale, scale)
    paint.shader.setLocalMatrix(shapeMatrix)
    rectF.set(0f, 0f, bWidth.toFloat(), bHeight.toFloat())
    val shapeDrawable = ShapeDrawable(OvalShape())
    shapeDrawable.paint.shader = bitmapShader
    shapeDrawable.bounds = rectF.toRect()
    shapeDrawable.draw(canvas)
}
</code></pre>
<h2 id="环形渲染-radialgradient">环形渲染 RadialGradient</h2>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/23c886987bc816cb4b8128b52169155e-image-20201210180214610-e2b7f3.png" alt="image-20201210180214610" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val radialGradient = RadialGradient(
        400f, 400f, 300f,
        intArrayOf(
            Color.RED,
            Color.GREEN,
            Color.BLUE,
            Color.YELLOW
        ), null, Shader.TileMode.REPEAT
    )
    paint.shader = radialGradient
    canvas.drawCircle(400f,400f,400f, paint)
}
</code></pre>
<h2 id="渐变渲染-sweepgradient">渐变渲染 SweepGradient</h2>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/11/37ceff71f9bc763ddc547dea5ef61570-image-20201211093531255-d05eaa.png" alt="image-20201211093531255" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val sweepGradient = SweepGradient(
        300f,300f,
        intArrayOf(
            Color.RED,
            Color.GREEN,
            Color.BLUE,
            Color.YELLOW
    ), null)
    paint.shader = sweepGradient
    canvas.drawCircle(300f,300f,300f,paint)
}
</code></pre>
<h2 id="组合着色-composeshader">组合着色 ComposeShader</h2>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/11/741ceb198042d9e6d563121c62daf599-image-20201211093902530-e90cc5.png" alt="image-20201211093902530" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val linearGradient = LinearGradient(0f, 0f, 300f, 300f, Color.RED, Color.WHITE,Shader.TileMode.CLAMP)
    val sweepGradient = SweepGradient(
        200f, 200f, intArrayOf(
            Color.RED,
            Color.GREEN,
            Color.BLUE,
            Color.YELLOW
        ), null
    )
    val composeShader = ComposeShader(linearGradient,sweepGradient,PorterDuff.Mode.MULTIPLY)
    paint.shader = composeShader
    canvas.drawRect(100f,100f,500f,500f,paint)
}
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/11/a6490c5461077c4705972003b829ea1c-image-20201211094327261-dfbcdc.png" alt="image-20201211094327261" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val bitmap = BitmapFactory.decodeResource(resources, R.drawable.heart)
    canvas.translate(measuredWidth/4f, measuredHeight/4f)
    val heartBitmapShader = BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
 
    val linearGradient = LinearGradient(
        0f,
        0f,
        bitmap.width.toFloat(),
        bitmap.height.toFloat(),
        Color.RED,
        Color.GREEN,
        Shader.TileMode.CLAMP
    )
    val composeShader =
    ComposeShader(heartBitmapShader, linearGradient, PorterDuff.Mode.MULTIPLY)
    paint.isAntiAlias = true
    paint.shader = composeShader
    canvas.drawRect(0f, 0f, bitmap.width.toFloat(), bitmap.height.toFloat(), paint)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图形绘制-Paint基本使用]]></title>
        <id>https://jxiaow.gitee.io/posts/46f22235/</id>
        <link href="https://jxiaow.gitee.io/posts/46f22235/">
        </link>
        <updated>2020-12-10T05:35:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="canvas和paint的关系">Canvas和Paint的关系</h2>
<p>在对UI绘制流程的分析中，可以知道<code>performCanvas()</code>方法最终会调用到<code>View#onDraw()</code>方法，并且会传递<code>Canvas</code>，那么<code>Canvas</code>到底有什么用呢？</p>
<p><code>Canvas</code>在UI绘制中扮演的是<code>会话角色</code>，我们通常情况下都能够知道使用Canvas去 画圆型，矩形图片等，但是最终其真正的绘制并不是在我们的android 层面进行的。</p>
<p>通过源码分析，<code>Canvas</code> 继承了<code>BaseCanvas</code></p>
<pre><code class="language-java">public class Canvas extends BaseCanvas {}
</code></pre>
<p>在<code>BaseCanvas</code>中，我们可以发现有大量以<code>nDraw</code>开头的方法，比如<code>drawCircle</code>。</p>
<pre><code class="language-java">public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint) {
    throwIfHasHwBitmapInSwMode(paint);
    nDrawCircle(mNativeCanvasWrapper, cx, cy, radius, paint.getNativeInstance());
}
</code></pre>
<pre><code class="language-java">private static native void nDrawCircle(long nativeCanvas, float cx, float cy, float radius, long nativePaint);
</code></pre>
<p>通过上述代码块我们可以知道，Canvas并不是具体的执行者，而是一个传达着， 在Canvas当中我们会将所有的参数信息设置好，然后交由底层去绘制。</p>
<p>我们通过观察Canvas中的绘制方法，可以发现每一个绘制方法中都有一个<code>Paint</code>类型的参数，那么Paint的职责到底是什么呢？打开Paint的源码，可以看到:</p>
<pre><code class="language-java">/**
* The Paint class holds the style and color information about how to draw
* geometries, text and bitmaps.
*/
public class Paint {}
</code></pre>
<p>注释中描述了Paint 在绘制过程中保存了色彩信息和样式信息。</p>
<h2 id="paint基础">Paint基础</h2>
<p>Paint方法主要可以抽象成2大类：</p>
<h3 id="设置和获取图像绘制-路径相关数据">设置和获取图像绘制、路径相关数据</h3>
<h4 id="设置画笔样式">设置画笔样式</h4>
<pre><code class="language-kotlin">// 设置画笔填充样式
paint.style = Paint.Style.STROKE
</code></pre>
<blockquote>
<p>Paint.Style.FILL :填充内部<br>
Paint.Style.FILL_AND_STROKE ：填充内部和描边<br>
Paint.Style.STROKE ：仅描边<br>
注意 STROKE、FILL_AND_STROKE与FILL模式相比 外轮廓的位置会扩大。</p>
</blockquote>
<h4 id="设置画笔宽度">设置画笔宽度</h4>
<pre><code class="language-kotlin">// 设置画笔宽度
paint.strokeWidth = 200.0f
</code></pre>
<h4 id="抗锯齿功能">抗锯齿功能</h4>
<ul>
<li>设置抗锯齿</li>
</ul>
<pre><code class="language-kotlin">// 开启抗锯齿
paint.isAntiAlias = true
</code></pre>
<ul>
<li>获取是否开启抗锯齿</li>
</ul>
<pre><code class="language-kotlin">val isAntiAlias = paint.isAntiAlias
</code></pre>
<blockquote>
<p>开启抗锯齿功能会消耗较大资源，绘制图形速度会变慢，但开启后绘制图像会平滑一些。</p>
</blockquote>
<h4 id="设置线冒样式">设置线冒样式</h4>
<pre><code class="language-kotlin">// 设置圆形线冒
paint.strokeCap = Paint.Cap.ROUND
</code></pre>
<blockquote>
<p>Cap.ROUND(圆形线冒)、 Cap.SQUARE(方形线冒) 、Paint.Cap.BUTT(无线冒)</p>
</blockquote>
<p>效果图：<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/964578978be8541993263fbf3950f8b1-image-20201210094248494-65db78.png" alt="image-20201210094248494" loading="lazy"></p>
<p>代码如下：</p>
<pre><code class="language-kotlin">val paint = Paint()
fun init() {
    // 设置画笔填充样式
    paint.style = Paint.Style.STROKE
    // 开启抗锯齿
    paint.isAntiAlias = true
    // 设置画笔颜色
    paint.color = Color.RED
    // 设置画笔宽度
    paint.strokeWidth = 200.0f
    // 设置圆形线冒
    paint.strokeCap = Paint.Cap.ROUND
}
 
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.drawLine(200f, 300f, 400f, 300f, paint)
}
</code></pre>
<h4 id="设置连接处线段">设置连接处线段</h4>
<pre><code class="language-kotlin">// 设置线段链接处的样式
paint.strokeJoin = Paint.Join.MITER
</code></pre>
<blockquote>
<p>Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线)</p>
</blockquote>
<p>效果图：<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/8559d0ecf86dabc0e14da1eca468675c-image-20201210094852252-2c05c2.png" alt="image-20201210094852252" loading="lazy"></p>
<p>代码如下：</p>
<pre><code class="language-kotlin">// 创建画笔
private val paint: Paint = Paint()
// 创建矩形区域
private val rect: Rect = Rect()
 
 
init {
    // 设置画笔填充样式
    paint.style = Paint.Style.STROKE
    // 开启抗锯齿
    paint.isAntiAlias = true
    // 设置画笔颜色
    paint.color = Color.RED
    // 设置画笔宽度
    paint.strokeWidth = 200.0f
    // 设置线段链接处于样式
    paint.strokeJoin = Paint.Join.ROUND
}
 
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    rect.set(200, 300, 400, 400)
    canvas.drawRect(rect, paint)
}
</code></pre>
<h4 id="设置画笔倾斜度">设置画笔倾斜度</h4>
<pre><code class="language-kotlin">// 设置画笔倾斜度
paint.strokeMiter = 0.8f
</code></pre>
<h4 id="清空画笔复位">清空画笔复位</h4>
<pre><code class="language-kotlin">// 画笔复位
paint.reset()
</code></pre>
<h4 id="设置外来画笔">设置外来画笔</h4>
<pre><code class="language-kotlin">// 设置一个新的画笔
paint.set(Paint())
</code></pre>
<h4 id="获取与设置alpha值颜色和argb">获取与设置alpha值，颜色和ARGB</h4>
<pre><code class="language-kotlin">// 透明度 0 -100
// r、g、b 0-255
paint.setARGB(80,110,234, 125)
 
 
// 设置透明度 0（完全透明） - 100 （不透明）
paint.alpha = 100
// 获取透明度
val alpha = paint.alpha
 
 
// 设置颜色
paint.color = Color.BLUE
// 获取颜色
val color = paint.color
</code></pre>
<h4 id="图像抖动处理">图像抖动处理</h4>
<ul>
<li>开启图像抖动</li>
</ul>
<pre><code class="language-kotlin">// 开启图像抖动
paint.isDither = true
</code></pre>
<ul>
<li>获取图像抖动是否开启</li>
</ul>
<pre><code class="language-kotlin">// 开启图像抖动
val isDither = paint.isDither
</code></pre>
<blockquote>
<p>会使绘制出来的图像颜色更加平滑、饱满和图像更加清晰</p>
</blockquote>
<h4 id="设置绘制路径效果">设置绘制路径效果</h4>
<pre><code class="language-kotlin">// 设置虚线
// intervals： 控制实线和实线之后空白线的宽度（数组长度必须为偶数）
// phase： 将View向”左“偏移phase
paint.pathEffect = DashPathEffect(intervals = floatArrayOf(20f,10f,50f,100f), phase = 15f)
</code></pre>
<blockquote>
<p>CornerPathEffect  ——圆形拐角效果<br>
paint.setPathEffect(new CornerPathEffect(100))<br>
利用半径R=50的圆来代替原来两条直线间的夹角<br>
DashPathEffect  ——虚线效果    画同一条线段,偏移值为15<br>
paint.setPathEffect(new DashPathEffect(new float[]{20,10,50,100},15))<br>
intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[]中这些基本线段循环组成的。比如，我们定义new float[] {20,10}； 那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10；<br>
phase：开始绘制的偏移值</p>
</blockquote>
<h4 id="设置图形重叠时的处理方式">设置图形重叠时的处理方式</h4>
<pre><code class="language-kotlin">paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.MULTIPLY)
</code></pre>
<p>通过设置xfermode 可以设置许多不同的效果，如 制作橡皮擦， 具体介绍请看 Paint的高级用法</p>
<h4 id="设置maskfilter">设置MaskFilter</h4>
<pre><code class="language-kotlin">paint.maskFilter = MaskFilter()
</code></pre>
<p>可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等 。</p>
<pre><code class="language-java">/**
* Create a blur maskfilter.
*
* @param radius 阴影的半径
 * @param style  NORMOL -- 整个图像都被模糊掉
 *               SOLID -- 图像边界外产生一层与Paint颜色一致阴影效果，不影响图像的本身
 *               OUTER -- 图像边界外产生一层阴影，并且将图像变成透明效果
 *               INNER -- 在图像内部边沿产生模糊效果
* @return
*/
paint.setMaskFilter(new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL));
</code></pre>
<pre><code class="language-java">/**
* Create an emboss maskfilter
*
 * @param direction  指定光源的位置，长度为xxx的数组标量[x,y,z]
 * @param ambient    环境光的因子 （0~1），越接近0，环境光越暗
 * @param specular   镜面反射系数 越接近0，镜面反射越强
* @param blurRadius 模糊半径 值越大，模糊效果越明显
*/
paint.setMaskFilter(new EmbossMaskFilter(new float[]{1,1,1},0.2f,60,80));
</code></pre>
<h4 id="设置颜色过滤器">设置颜色过滤器</h4>
<pre><code class="language-kotlin">paint.colorFilter = ColorFilter()
</code></pre>
<p>可以在绘制颜色时实现不用颜色的变换效果，可以用来设置图像的黑白效果。</p>
<h4 id="设置图像效果">设置图像效果</h4>
<pre><code class="language-kotlin">paint.shader = Shader()
</code></pre>
<p>使用Shader可以绘制出各种渐变效果。Shader有一些子类，如：LinearGradient。</p>
<h4 id="在图像下设置阴影层">在图像下设置阴影层</h4>
<pre><code class="language-kotlin">// radius 为阴影的角度
// dx和dy为阴影在x轴和y轴上的距离
// color为阴影的颜色
paint.setShadowLayer(float radius ,float dx,float dy,int color)
</code></pre>
<h3 id="设置获取文字相关的">设置获取文字相关的</h3>
<h4 id="获取字符的行间距">获取字符的行间距</h4>
<pre><code class="language-kotlin">val spacing = paint.fontSpacing
</code></pre>
<h4 id="设置和获取字符的间距">设置和获取字符的间距</h4>
<pre><code class="language-kotlin">// 获取字符的间距 api &gt;= 21
val letterSpacing = paint.letterSpacing
// 设置字符的间距 api &gt;= 21
paint.letterSpacing = 20f
</code></pre>
<h4 id="是否有下划线和设置下划线">是否有下划线和设置下划线</h4>
<pre><code class="language-kotlin">// 获取是否有下划线
val isUnderlineText = paint.isUnderlineText
// 设置下划线
paint.isUnderlineText = true
</code></pre>
<h4 id="获取与设置是否有文本删除线">获取与设置是否有文本删除线</h4>
<pre><code class="language-kotlin">// 设置文本删除线
paint.isStrikeThruText = true
// 获取文本删除线
val isStrikeThruText = paint.isStrikeThruText
</code></pre>
<h4 id="获取与设置文字大小">获取与设置文字大小</h4>
<pre><code class="language-kotlin">// 获取文字大小
val textSize = paint.textSize
// 设置文字大小
paint.textSize = 14f
</code></pre>
<p><strong>注意：</strong> <code>Paint.setTextSize</code> 单位是<code>px</code>，<code>TextView.setTextSize</code>单位是<code>sp</code>。</p>
<h4 id="获取与设置字体类型">获取与设置字体类型</h4>
<pre><code class="language-kotlin">// 设置字体样式
paint.typeface = Typeface.DEFAULT
val typeface = paint.typeface
</code></pre>
<blockquote>
<p>默认有四种字体样式：     BOLD(加粗、BOLD_ITALIC(加粗并倾斜)、ITALIC(倾斜)、NORMAL(正常)<br>
也可通过Typeface类来自定义个性化字体。</p>
</blockquote>
<h4 id="获取与设置文字倾斜">获取与设置文字倾斜</h4>
<pre><code class="language-kotlin">// 设置文字倾斜度
paint.textSkewX = -0.25f
val textSkewX = paint.textSkewX
</code></pre>
<blockquote>
<p>参数没有具体范围, 官方推荐值为-0.25，值为负则右倾，为正则左倾，默认值为0。</p>
</blockquote>
<h4 id="获取与设置文本对齐方式">获取与设置文本对齐方式</h4>
<pre><code class="language-kotlin">// 设置文本的对齐方式
paint.textAlign = Paint.Align.CENTER
val textAlign = paint.textAlign
</code></pre>
<blockquote>
<p>取值为 CENTER、LEFT、RIGHT，即文字绘制是左边对齐、右边还是局中。</p>
</blockquote>
<h4 id="亚像素">亚像素</h4>
<pre><code class="language-kotlin">// 设置亚像素
paint.isSubpixelText = true
</code></pre>
<blockquote>
<p>固定的几个范围：320<em>480，480</em>800，720<em>1280，1080</em>1920等，那么如何在同样的分辨率的显示器中增强显示清晰度呢？<br>
亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。 所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。</p>
</blockquote>
<h4 id="文本折断">文本折断</h4>
<pre><code class="language-kotlin">paint.breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)
</code></pre>
<p>如文本阅读器的翻页效果，我们需要在翻页的时候动态折断或生成一行字符串。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android通过Intent简单实现分享功能]]></title>
        <id>https://jxiaow.gitee.io/posts/73a6d0c4/</id>
        <link href="https://jxiaow.gitee.io/posts/73a6d0c4/">
        </link>
        <updated>2020-12-04T16:03:24.000Z</updated>
        <summary type="html"><![CDATA[<p>现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过<code>Intent</code>方式打开在系统中安装的具有分享功能的App的分享页面。</p>
]]></summary>
        <content type="html"><![CDATA[<p>现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过<code>Intent</code>方式打开在系统中安装的具有分享功能的App的分享页面。</p>
<!-- more -->
<p>方法如下：</p>
<pre><code class="language-java">public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_SEND);
    intnet.setType(&quot;text/plain&quot;);
    PackageManager packageManager = context.getPackageManager();
    List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0);
    return resloveInfos;
}
</code></pre>
<p>如果只需要QQ和微信分享，可以进行如下操作：</p>
<pre><code class="language-java">public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_SEND);
    intnet.setType(&quot;text/plain&quot;);
    PackageManager packageManager = context.getPackageManager();
    List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0);
    List&lt;ResolveInfo&gt; shareItems = new ArrayList();    
    for(ResolveInfo info: resolveInfos) {
        String name = info.activityInfo.packageName;
        if (TextUtils.equals(packageName, &quot;com.tencent.mm&quot;)
                    || TextUtils.equals(packageName, &quot;com.tencent.mobileqq&quot;)) {
                shareItems.add(resolveInfo);
        }
    }
    return shareItems;
}
</code></pre>
<p>通过<code>ResolveInfo</code>获取图标<code>ICON</code>和<code>Label</code>:</p>
<pre><code class="language-java">Drawable drawable = resloveInfo.loadIcon(packageManager);
CharSequence label = resolveInfo.loadLabel(packageManager);
</code></pre>
<p>通过<code>Intent</code>发起分享：</p>
<pre><code class="language-java">public static void share(Context context, 
            ResolveInfo info, String shareContent){
    Intent itnent = new Intent();
    intnet.setAction(Intent.ACTION_SEND);
    String pkg = resolveInfo.activityInfo.packageName;
    String cls = resolveInfo.activityInfo.name;
    intent.setComponent(new Component(pkg, cls));
    intent.putExtra(Intent.EXTRA_TEXT, shareContent);
    context.startActivity(intent);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora + PicGo-Core + Github 实现图片上传到Github]]></title>
        <id>https://jxiaow.gitee.io/posts/cde2810e/</id>
        <link href="https://jxiaow.gitee.io/posts/cde2810e/">
        </link>
        <updated>2020-11-07T08:10:37.000Z</updated>
        <summary type="html"><![CDATA[<p>为了解决<code>为知笔记</code>使用<code>Typora</code>编辑<code>markdown</code>文件图片丢失的问题，我采用了<code>PicGo-Core +Github</code>实现了自定图床的功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>为了解决<code>为知笔记</code>使用<code>Typora</code>编辑<code>markdown</code>文件图片丢失的问题，我采用了<code>PicGo-Core +Github</code>实现了自定图床的功能。</p>
<!--more-->
<h2 id="下载picgo-core">下载PicGo-Core</h2>
<p>由于我的电脑有<code>nodejs</code>环境，所以我使用的是<code>npm</code>命令安装<code>picgo</code>, 命令如下：</p>
<pre><code class="language-shell">npm install picgo -g
</code></pre>
<p>安装完成后，检查命令行输出, 记录下红色框内的路径。<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105201730919.png" alt="image-20201105201730919" loading="lazy"></p>
<p>输入命令查看版本，如果有输出则添加成功。</p>
<pre><code class="language-shell">picgo -v
</code></pre>
<h2 id="安装github-plus">安装github-plus</h2>
<p>官方提供的github上传图库不好用，安装一款新的上传插件<code>github-plus</code>, 命令行执行：</p>
<pre><code class="language-shell">picgo install github-plus
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105223054898.png" alt="image-20201105223054898" loading="lazy"></figure>
<p>安装成功后会有提示。</p>
<h2 id="typora图像设置">Typora图像设置</h2>
<p>在<code>Typora</code>中配置图像上传信息。</p>
<h3 id="设置picgo的配置信息">设置PicGo的配置信息</h3>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105223720354.png" alt="" loading="lazy"></figure>
<p>如上图所示，分为2个步骤：</p>
<ol>
<li><strong>上传服务</strong>选择<code>PicGo-Core(command line)</code></li>
<li>打开配置文件，在打开的配置文件，添加相关信息。</li>
</ol>
<pre><code class="language-json">{
 &quot;picBed&quot;: {
   &quot;uploader&quot;: &quot;githubPlus&quot;,
   &quot;current&quot;: &quot;githubPlus&quot;,
   &quot;githubPlus&quot;: {
     &quot;branch&quot;: &quot;master&quot;,// 仓库分支
     &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest&quot;, // 访问的自定义url
     &quot;origin&quot;: &quot;github&quot;, // 存放的图片类型
     &quot;repo&quot;: &quot;jxiaow/cdn-images&quot;, // 存放图片的仓库
     &quot;path&quot;: &quot;blog-images&quot;,// 存放图片的仓库目录下的文件夹
     &quot;token&quot;: &quot;&quot; // 访问github的仓库的token, 不知道怎么设置的自行百度
   }
 },
 &quot;picgoPlugins&quot;: {
   &quot;picgo-plugin-github-plus&quot;: true // 启用github-plus插件
 },
 &quot;picgo-plugin-github-plus&quot;: {
   &quot;lastSync&quot;: &quot;2020-11-05 07:54:47&quot;
 }
}
</code></pre>
<h3 id="测试配置">测试配置</h3>
<p>根据上述配置完毕后我们需要进行测试链接是否成功，在测试之前还要进行如图所示的修改：<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105224420441.png" alt="image-20201105224420441" loading="lazy"></p>
<ol>
<li><strong>上传服务</strong>修改为<code>Custom Command</code></li>
<li>自定义命令 ： <code>picgo upload</code></li>
<li>点击验证图片上传选项</li>
<li>如果显示验证成功，则表示配置完成。<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105225415181.png" alt="image-20201105225415181" loading="lazy"></li>
</ol>
<h2 id="图片上传">图片上传</h2>
<p>将图片拖入Typora中，然后在图片单击右键，图片上传即可。</p>
<h2 id="安装文件重命名插件-picgo-plugin-rename-file">安装文件重命名插件 <a href="https://github.com/liuwave/picgo-plugin-rename-file">picgo-plugin-rename-file</a></h2>
<p><code>picgo-plugin-rename-file</code> 插件可以帮我们安装一定的规则将文件进行重命名，具体设置请看github。</p>
<p>输入一下命令安装:</p>
<pre><code class="language-shell">picgo install rename-file
</code></pre>
<p>安装完成后，打开<code>picgo</code>的配置文件<code>C:\Users\xxx\.picgo\config.json</code>末尾最后一个大括号前添加一下信息即可。</p>
<pre><code class="language-json">,
&quot;picgo-plugin-rename-file&quot;: {
    &quot;format&quot;: &quot;{y}/{m}/{d}/{hash}-{origin}-{rand:6}&quot;
}
</code></pre>
<h2 id="添加水印">添加水印</h2>
<p><em><strong>注意：此插件目前会导致文件上传重命名插件不生效</strong></em><br>
插件地址: <a href="https://github.com/Dec-F/picgo-plugin-watermark">picgo-plugin-watermark</a> ，<code>watermark</code>插件可以帮我们在上传图片的时候添加水印。</p>
<p>安装命令：</p>
<pre><code class="language-shell">picgo install watermark
</code></pre>
<p>安装成功后，<code>C:\Users\xxx\.picgo\config.json</code>末尾最后一个大括号前添加一下信息即可。</p>
<pre><code class="language-json">,
&quot;picgo-plugin-watermark&quot;: { // 以下配置信息参考插件地址说明
    &quot;text&quot;: &quot;jxiaow&quot;, // 水印名称
    &quot;fontSize&quot;: 18, // 水印字体大小
    &quot;position&quot;:&quot;rm&quot; // 水印位置
},
</code></pre>
<p><strong>注意：</strong> 由于这个插件安装过程中需要下载字体，会导致下载特别慢，尽可能使用代理。</p>
<p><strong>website:</strong> <a href="https://xiaowujiang.cn">xiaowujiang.cn</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[360加固Gradle插件实现]]></title>
        <id>https://jxiaow.gitee.io/posts/6c01e784/</id>
        <link href="https://jxiaow.gitee.io/posts/6c01e784/">
        </link>
        <updated>2020-09-07T16:14:31.000Z</updated>
        <content type="html"><![CDATA[<p>最近码了一个基于360加固的流程实现的Gradle插件，在自动编译打包后进行360加固流程操作。只需要配置一些参数后，就可以实现自动打包编译和加固。</p>
<p>项目地址:https://github.com/jxiaow/android-gradle-plugin</p>
<h3 id="使用步骤">使用步骤</h3>
<h4 id="1-添加依赖">1. 添加依赖</h4>
<ul>
<li>在根<code>build.gradle</code>中添加：</li>
</ul>
<pre><code class="language-groovy">allprojects {
    repositories {
        maven { url &quot;https://jitpack.io&quot; }
    }
}

dependencies {
    ...
    classpath 'com.github.jxiaow:android-gradle-plugin:$version'
}
</code></pre>
<p>(请替换 <code>$version</code>为最新的版本号:<a href="https://jitpack.io/#jxiaow/android-gradle-plugin"><img src="https://jitpack.io/v/jxiaow/android-gradle-plugin.svg" alt="" loading="lazy"></a>)</p>
<ul>
<li>在<code>app</code>的模块<code>build.gradle</code>中添加：</li>
</ul>
<pre><code class="language-groovy">apply plugin: 'com.github.jxiaow.jiagu'
</code></pre>
<h4 id="2-参数配置">2. 参数配置</h4>
<p>使用这款插件需要在<code>app</code>的<code>build.gradle</code>中添加一些配置信息，如下：</p>
<pre><code class="language-groovy">jiagu {
    home '../360jiagu' // 360加固软件的根目录
    buildTypes 'release', 'debug' // 需要加固的编译类型
    configs '-crashlog' // 选择360的可选配置服务
    username 'user' // 360加固用户名
    password 'password' // 360加固密码
    charsetName 'GBK' // 360加固控制台输出字符编码
    // apk签名文件， 如果在Android中配置了签名文件，此项可以不用配置，插件会自动读取名为'release'的签名文件
    signingConfig { 
        key_alias         : KEY_ALIAS, 
        key_password      : KEY_PASSWORD,
        key_store_password: KEY_STORE_PASSWORD,
        key_store_file    : KEY_STORE_FILE
    }
}
</code></pre>
<h4 id="3-开始加固">3. 开始加固</h4>
<p>确认上述参数无误后，就可以在控制台中切换到当前项目根目录执行</p>
<pre><code class="language-shell"># 各个系统的控制台gradle命令可能不一样： ./gradlew 或 gradlew 
./gradlew clean jiaGuApk 
</code></pre>
<h3 id="文档">文档</h3>
<p><a href="https://jxiaow.github.io/android-gradle-plugin/plugin/com.github.jxiaow.jiagu/index.html">android-gradle-plugin</a></p>
<h3 id="360加固助手">360加固助手</h3>
<p><a href="https://jiagu.360.cn/#/global/download">360加固助手</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Http框架封装]]></title>
        <id>https://jxiaow.gitee.io/posts/84a009ed/</id>
        <link href="https://jxiaow.gitee.io/posts/84a009ed/">
        </link>
        <updated>2020-04-26T02:03:07.000Z</updated>
        <summary type="html"><![CDATA[<p>用过了现有的一些<code>http</code>请求框架，决定自己也来简单的封装一个。本文只是基于一些http请求框架二次封装的，高手勿喷。<a href="https://github.com/ixiaow/ppjoke/tree/master/network/src/main/java/com/mooc/network">源码</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>用过了现有的一些<code>http</code>请求框架，决定自己也来简单的封装一个。本文只是基于一些http请求框架二次封装的，高手勿喷。<a href="https://github.com/ixiaow/ppjoke/tree/master/network/src/main/java/com/mooc/network">源码</a></p>
<!-- more -->
<h2 id="http的请求和响应">http的请求和响应</h2>
<p>一个http的请求通常包含请求头、请求体、响应头和响应体，考虑到这些因素，<code>HttpConfig</code>和 <code>ApiResponse</code>就诞生了: <a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/HttpConfig.java">HttpConfig</a></p>
<h3 id="httpconfig">HttpConfig</h3>
<p>http参数配置类，应该包含如下属性:</p>
<ul>
<li>baseUrl/url</li>
</ul>
<p>如果使用restful形式，baseUrl是不能为空并且url为业务path, 如果是非restful,url必须为请求全路径</p>
<ul>
<li>GET/POST</li>
</ul>
<p>有了url，接下来需要有请求的方法类型，由于我这边只用到了<code>GET</code>和<code>POST</code>,所以只对此做了封装。</p>
<p><strong>特别说明：</strong> POST 有三种提交方式（form表单、json形式和 复杂形式）</p>
<pre><code class="language-java">FORM_DATA(&quot;application/x-www-form-urlencoded;charset=utf-8&quot;),
JSON_DATA(&quot;application/json;charset=utf-8&quot;),
MULTI_PART_DATA(&quot;multipart/form-data;charset=utf-8&quot;);
</code></pre>
<ul>
<li>headers</li>
</ul>
<p>http的请求头封装，采用<code>(Map&lt;String,String&gt;)</code>集合</p>
<ul>
<li>params</li>
</ul>
<p>http的请求参数，采用<code>(Map&lt;String,Object&gt;)</code>如果请求方法是<code>GET</code>形式，那么采用拼接字符串的形式将参数拼接到url中; 如果请求方法是<code>POST</code>形式，则需要根据提交参数的方式不同，会有不同的请求体。</p>
<ul>
<li>cacheStrategy</li>
</ul>
<p>考虑到App的使用交互和服务器减压，我们要考虑有一些请求可以做一些缓存，那么常用的缓存策略有<code>CACHE_ONLY</code>、<code>CACHE_FIRST</code>、<code>NET_ONLY</code>和<code>NET_CACHE</code></p>
<ul>
<li>type</li>
</ul>
<p>type是响应数据的type,这个主要用在Http请求结果返回后将json转为bean对象的映射类型，需要考虑泛型和非泛型（Class和ParamizableType）</p>
<ul>
<li>tag</li>
</ul>
<p>给每一个请求链接打一个标签，可用于一些其它的操作，如根据tag取消请求</p>
<ul>
<li>isAsync</li>
</ul>
<p>当前请求是同步执行还是异步执行的标志，异步执行会在子线程中进行http请求，同步执行在当前线程中执行http请求。</p>
<h4 id="apiresponset">ApiResponse<T></h4>
<p>使用<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/ApiResponse.java">ApiResponse</a>的原因是为了规范请求结果返回的表现形式，他有一个<code>T</code>类型的数据。</p>
<ul>
<li>code</li>
</ul>
<p>状态码,与http请求响应状态码一致，200~300 请求成功，304 使用缓存</p>
<ul>
<li>message</li>
</ul>
<p>请求响应的错误信息</p>
<ul>
<li>data</li>
</ul>
<p>响应的数据，泛型T, 根据<code>httpConfig</code>中的type,映射 json--&gt; bean</p>
<h2 id="http引擎">Http引擎</h2>
<p><a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/IHttpEngine.java">IHttpEngine</a>是一个接口，使用者可以根据实际的情况做具体的实现。</p>
<pre><code class="language-java">public interface IHttpEngine {

    // 开始执行 http请求
    &lt;T&gt; execute(HttpConfig config, MultableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData);
    // 根据tag取消
    void cancel(Object tag);
}
</code></pre>
<p>由于http请求有同步和异步两种情况并且又牵扯到了缓存策略问题（如果先进行缓存返回在执行网络请求并返回数据），在异步回调的情况下这些问题可以通过回调解决，但是在同步情况下，这些问题并不能很好的处理，曾经有使用过将当前请求<code>clone</code>,然后再次调用请求服务器的方法，但是在使用过<code>jetpack</code>的<code>LiveData</code>框架后这些问题都可以解决了。</p>
<h2 id="okhttpengine">OkhttpEngine</h2>
<p>Android开发目前来说大多数项目使用的都是<code>Okhttp</code>来做请求，本次我使用的默认引擎也是使用它来作为默认的实现。<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/okhttp/OkHttpEngine.java">OkHttpEngine</a></p>
<h3 id="okhttp简单配置">okhttp简单配置</h3>
<p>对okhttp进行一些简单的配置就可以进行网络请求了，如下：</p>
<ul>
<li>创建okHttpClient</li>
</ul>
<pre><code class="language-java"> private static final OkHttpClient OK_HTTP_CLIENT;

 // 添加日志拦截器
 HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
 loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);

 OK_HTTP_CLIENT = new OkHttpClient.Builder()
               .connectTimeout(15, TimeUnit.SECONDS)
               .readTimeout(15, TimeUnit.SECONDS)
               .writeTimeout(15, TimeUnit.SECONDS)
               .addInterceptor(loggingInterceptor)
               .build();
</code></pre>
<ul>
<li>添加证书管理</li>
</ul>
<pre><code class="language-java">TrustManager[] trustManagers = new TrustManager[]{
    new X509TrustManager() {
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }
     }
};

SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;);
sslContext.init(null, trustManagers, new SecureRandom());
HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -&gt; true);
</code></pre>
<h3 id="实现http请求">实现Http请求</h3>
<p>IHttpEngine中的<code>execute</code>方法是具体的http请求方法，所有实现<code>IHttpEngine</code>的方法都需要实现此方法。</p>
<pre><code class="language-java">@NonNull
@Override
public &lt;T&gt; void execute(@NonNull Config config, 
                        @NonNull MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
    Request request = generateRequest(config);
    Call call = OK_HTTP_CLIENT.newCall(request);
    if (!config.isAsync) {
        execute(call, config, liveData);
    } else {
        enqueue(call, config, liveData);
    }
}
</code></pre>
<p><code>execute</code>方法中大致需要做以下事：</p>
<ul>
<li>创建request--&gt; genearteRequest</li>
<li>发送http请求 ---&gt; execute/enqueue</li>
</ul>
<h4 id="创建httprequest">创建httpRequest</h4>
<p><code>generateRequest()</code>根据<code>HttpConfig</code>中的请求方式来创建不同的http请求。</p>
<pre><code class="language-java">/**
 * 根据配置信息生成request
 *
 * @param config 配置信息
 * @return request
 */
 @NonNull
 private Request generateRequest(@NonNull Config config) {
    switch (config.method) {
       case Config.GET:
           return generateGetRequest(config);
       case Config.POST:
           return generatePostRequest(config);

       default:
           throw new IllegalStateException(&quot;this request method invalidate: &quot; + config.method);
    }
}
</code></pre>
<h5 id="get请求的创建方式">GET请求的创建方式</h5>
<p><code>genearteGetReques()</code>方法，利用okhttp的Request类创建request实例，并利用<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/UrlCreator.java">UrlCreator</a>将参数拼接到url中。Url拼接时需要注意使用<code>UrlEncoder</code>编码，不然可能会造成服务器和客户端解析数据不一致的情况。</p>
<pre><code class="language-java">/**
 * 生成get方式的请求
 *
 * @param config 请求配置
 * @return 返回get方式的request
 */
@NonNull
private Request generateGetRequest(@NonNull Config config) {
   Request.Builder builder = new Request.Builder().get();
   builder.tag(config.tag);
   addHeader(builder, config);
   String url = UrlCreator.generateUrlForParams(config.url(), config.getParams());
   return builder.url(url).build();
}
</code></pre>
<h5 id="post请求的创建方式">POST请求的创建方式</h5>
<p>POST请求方式提交内容时相对于GET方式要复杂许多，他需要根据提交方式的不同添加不同的<code>header</code>和内容<code>body</code>, 在<code>generatePostRequest()</code>方法中先利用okhttp的request类创建request实例，根据调用者在<code>HttpConfig</code>中设置<code>formData</code>来创建不同形式的<code>body</code>。</p>
<pre><code class="language-java">/**
 * 生成post请求
 *
 * @param config http请求配置信息
 * @return 请求request
 */
@NonNull
private Request generatePostRequest(@NonNull Config config) {
   Request.Builder builder = new Request.Builder().url(config.url());
   builder.tag(config.tag);
   addHeader(builder, config);

   // 根据提交方式添加header信息
   Pair&lt;String, String&gt; header = config.formData.getHeader();
   builder.addHeader(header.first, header.second);

   // 创建body
   RequestBody body = generatePostRequestBody(config);
   return builder.post(body).build();
}
</code></pre>
<p>判断<code>formData</code>类型，创建不同的<code>request body</code>。</p>
<pre><code class="language-java">/**
 * 获取post提交体
 *
 * @param config 请求配置信息
 * @return RequestBody
 */
@NonNull
private RequestBody generatePostRequestBody(@NonNull Config config) {
   FormData formData = config.formData;
   switch (formData) {
       case FORM_DATA:
           return getFormDataRequestBody(config);
       case JSON_DATA:
           return getJsonDataRequestBody(config);
       case MULTI_PART_DATA:
           return getMultiDataRequestBody(config);
       default:
           throw new IllegalArgumentException(&quot;post formData is invalidate: &quot; + formData);
   }
}
</code></pre>
<h6 id="创建formdata表单">创建FormData(表单)</h6>
<p>form表单形式比较简单，只需要创建一个okhttp的FormBody并将param添加，需要注意的是添加param时调用的是<code>addEncoded</code>方法。</p>
<pre><code class="language-java">/**
 * 生成form data形式的post数据
 *
 * @param config 请求配置
 * @return FromBody
 */
 @NonNull
 private RequestBody getFormDataRequestBody(@NonNull Config config) {
     FormBody.Builder builder = new FormBody.Builder(StandardCharsets.UTF_8);
     Map&lt;String, Object&gt; params = config.getParams();
     for (Map.Entry&lt;String, Object&gt; entry : params.entrySet()) {
          builder.addEncoded(entry.getKey(), String.valueOf(entry.getValue()));
     }
     return builder.build();
 }
</code></pre>
<h6 id="json形式">json形式</h6>
<p>利用okHttp中的<code>RequestBody.create()</code>方法创建一个json形式的body,需要传递json和json形式的header。</p>
<pre><code class="language-java">/**
 * 生成json形式的post数据
 *
 * @param config 请求配置
 * @return RequestBody
 */
 @NonNull
 private RequestBody getJsonDataRequestBody(@NonNull Config config) {
   if (config.getParams().isEmpty()) {
        throw new IllegalArgumentException(&quot;json data is null&quot;);
   }
   Object json = config.getParams().get(Config.JSON_KEY);
   return RequestBody.create(String.valueOf(json), MediaType.parse(config.formData.getValue()));
 }
</code></pre>
<h6 id="复杂形式的body">复杂形式的body</h6>
<p>复杂形式的body，主要是用在文件上传这一块儿。它需要判断当前param是普通key-value、单文件和多文件。</p>
<p>利用okhttp的MultiparBody创建body对象并根据内容类型调用的不同的body,然后调用<code>addFormDataPart</code>添加到MultipartBody中。</p>
<pre><code class="language-java">/**
 * 获取复杂的post提交体
 *
 * @param config 请求配置信息
 * @return MultipartBody
 */
@NonNull
@SuppressWarnings(&quot;unchecked&quot;)
private RequestBody getMultiDataRequestBody(@NonNull Config config) {

    MultipartBody.Builder builder = new MultipartBody.Builder();
    builder.setType(MultipartBody.FORM);

    for (Map.Entry&lt;String, Object&gt; entry : config.getParams().entrySet()) {
        String key = entry.getKey();
        Object value = entry.getValue();

        if (value instanceof File) {
            File file = (File) value;
            RequestBody requestBody = MultipartBody.create(file, getFileMediaType(file));
            builder.addFormDataPart(key, file.getName(), requestBody);
        } else if (value instanceof List) {
            List&lt;File&gt; files = (List&lt;File&gt;) value;
            for (int i = 0; i &lt; files.size(); i++) {
                File file = files.get(i);
                RequestBody requestBody = MultipartBody.create(file, getFileMediaType(file));
                builder.addFormDataPart(key + i, file.getName(), requestBody);
            }
        } else {
            builder.addFormDataPart(key, String.valueOf(value));
        }
    }
    return builder.build();
}
</code></pre>
<p>添加文件时需要有文件的类型，文件类型的获取方式是通过<code>UrlConnection</code>的getFileNameMap方法获取。</p>
<pre><code class="language-java">/**
 * 获取文件的type类型
 *
 * @param file 文件
 * @return MediaType
 */
@Nullable
private MediaType getFileMediaType(@NonNull File file) {
    FileNameMap fileNameMap = URLConnection.getFileNameMap();
    String contentTypeFor = fileNameMap.getContentTypeFor(file.getAbsolutePath());
    if (contentTypeFor == null) {
        contentTypeFor = &quot;application/octet-stream&quot;;
    }
    return MediaType.parse(contentTypeFor);
</code></pre>
<p>通过以上的几种方式就可以创建一个http请求了，接下来需要发送请求了，发送请求需要通过httpConfig中的<code>isAsync</code>来判断是开启一个子线程还是在当前线程中执行操作（同步与异步）。</p>
<h4 id="发送http请求">发送http请求</h4>
<p>发送http请求会有同步请求(execute)和异步请求(enqueue), 同步请求是在当前线程中发送http请求，异步请求采用okhttp线程池发送请求。处理请求时在合适的地方需要判断该请求是否被取消。</p>
<pre><code class="language-java"> if (call.isCanceled()) {
    return;
 }
</code></pre>
<h5 id="同步请求execute">同步请求(execute)</h5>
<p>在发送http请求时会根据缓存策略进行响应的处理，而同步请求没有办法做到<code>return</code>后可以继续进行网络请求，所以引入了<code>LiveData</code>来发送数据。</p>
<p>目前缓存策略有四种，我们需要根据判断来进行不同的操作，关于缓存的创建和获取后续会有说明，这块儿只有根据缓存策略处理数据。</p>
<pre><code class="language-java">/**
 * 同步执行的方法
 */
@SuppressWarnings(&quot;unchecked&quot;)
private &lt;T&gt; void execute(Call call, Config config, MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
    ApiResponse&lt;T&gt; apiResponse;
    Logs.d(&quot;execute before cache: &quot; + Thread.currentThread().getName());
    // 只访问本地数据
    if (config.cacheStrategy == Config.CACHE_ONLY) {
        apiResponse = readCache(call.request().url().toString());
        liveData.postValue(apiResponse);
        return;
    }

    // 先访问本地数据，然后再发起网络请求
    if (config.cacheStrategy == Config.CACHE_FIRST) {
        apiResponse = readCache(call.request().url().toString());
        liveData.postValue(apiResponse);
    }

    Logs.d(&quot;execute current thread: &quot; + Thread.currentThread().getName());
    // ..... 此处开始进行http网络请求


    if (call.isCanceled()) {
        return;
    }
    // liveData发送数据
    liveData.postValue(apiResponse);
    if (config.cacheStrategy != Config.NET_ONLY) {
        saveCache(call.request().url().toString(), apiResponse);
    }
}
</code></pre>
<p>使用okhttp的<code>execute</code>方法发送http请求,并利用<code>ConvertFactory</code>进行数据解析，ConvertFactory后续会介绍。</p>
<pre><code class="language-java"> try {
      Response response = call.execute();
      IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
      apiResponse = convert.convert(response, config.type);
 } catch (IOException e) {
      e.printStackTrace();
      apiResponse = new ApiResponse&lt;&gt;();
      apiResponse.status = 500;
      apiResponse.message = e.getMessage();
 }
</code></pre>
<h5 id="异步请求enqueue">异步请求(enqueue)</h5>
<p>异步请求与同步请求一样也需要进行缓存策略进行缓存处理，这块儿的处理逻辑一致，所以下面的代码块将这部分省略。使用okhttp的<code>enqueue</code>方法发送http请求,在<code>onResponse</code>中并利用<code>ConvertFactory</code>进行数据的解析，在<code>onFailure</code>中自定义错误信息的返回。</p>
<pre><code class="language-java">private &lt;T&gt; void enqueue(Call call, Config config, MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
        //... 缓存策略判断数据处理返回
        ...
        // 开始请求服务器
        call.enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                if (call.isCanceled()) {
                    return;
                }
                ApiResponse&lt;T&gt; apiResponse = new ApiResponse&lt;&gt;();
                apiResponse.status = 500;
                apiResponse.message = e.getMessage();
                liveData.postValue(apiResponse);
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                if (call.isCanceled()) {
                    return;
                }
                IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
                ApiResponse&lt;T&gt; apiResponse = convert.convert(response, config.type);
                liveData.postValue(apiResponse);
                if (config.cacheStrategy != Config.NET_ONLY) {
                    saveCache(call.request().url().toString(), apiResponse);
                }
            }
        });
    }
</code></pre>
<h3 id="取消请求">取消请求</h3>
<p><code>cancle()</code>方法中，利用Okhttp来取消请求，主要是比对tag, 如下：</p>
<pre><code class="language-java">@Override
public void cancel(@NonNull Object tag) {
    if (OK_HTTP_CLIENT == null) {
        return;
    }

    //查找当前需要取消的tag是否在未执行的请求中
    for (Call call : OK_HTTP_CLIENT.dispatcher().queuedCalls()) {
        if (tag.equals(call.request().tag())) {
            call.cancel();
        }
    }

    //查找当前需要请求的tag是否在正在执行的请求中
    for (Call call : OK_HTTP_CLIENT.dispatcher().runningCalls()) {
        if (tag.equals(call.request().tag())) {
            call.cancel();
        }
    }
}
</code></pre>
<h2 id="响应数据转换">响应数据转换</h2>
<p>从服务器返回数据后，需要将数据格式进行转换成数据模型bean，由于数据返回的形式有多种，所以解析方式也会有多种，所以这块儿可以考虑使用数据解析工厂类去做数据解析，不同的解析数据做不同的逻辑实现，达到解偶。</p>
<p>定义一个<code>Convert</code>类，利用泛型的方式进行参数传递。</p>
<pre><code class="language-java">public interface IConvert&lt;T, R&gt; {
    // 数据的返回形式必须是ApiResponse, type即为泛型T的类型
    @NonNull
    ApiResponse&lt;R&gt; convert(@NonNull T t, @NonNull Type type);
}
</code></pre>
<p>这边提供了一种简单的convert调用方式，后面可以要考虑进行扩展选择：</p>
<pre><code class="language-java"> IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
 apiResponse = convert.convert(response, config.type);
</code></pre>
<p><code>ConverFactory</code>为<code>IConvert</code>的实现类。</p>
<pre><code class="language-java">public class ConvertFactory&lt;R&gt; implements IConvert&lt;Response, R&gt; {
    private static ConvertFactory convertFactory;


    public static ConvertFactory create() {
        if (convertFactory == null) {
            convertFactory = new ConvertFactory();
        }
        return convertFactory;
    }

    ...........
}
</code></pre>
<h2 id="本地缓存">本地缓存</h2>
<p>数据缓存采用的是<code>Room</code>数据库进行数据的存储，room是jetpack中的一种组件。它的创建方式也很简单。</p>
<h3 id="创建数据库表">创建数据库表</h3>
<pre><code class="language-java">// Entity 表示该对象是一张数据库表
@Entity(tableName = &quot;cache&quot;)
public class Cache {
    // primarykey表示表的主键
    @PrimaryKey
    @NonNull
    public String key;
    // ColumnInfo表示该字段在表中显示的字段名
    @ColumnInfo(name = &quot;_data&quot;)
    public byte[] data;
}
</code></pre>
<h3 id="创建数据库">创建数据库</h3>
<pre><code class="language-java">// entities 表示 需要在该数据库中创建的表，可以创建多张
// version 数据库的版本号
// exportSchema 导出表创建的语句
@Database(entities = Cache.class, version = 1, exportSchema = true)
public abstract class CacheDatabase extends RoomDatabase {
    private static final CacheDatabase cacheDatabase;

    static {
        Application application = AppGlobals.getApplication();
        cacheDatabase = Room.databaseBuilder(application, CacheDatabase.class, &quot;net_cache.db&quot;)
                .allowMainThreadQueries()
                .build();
    }

    // 数据库与Dao关联
    public abstract CacheDao getCacheDao();

    public static CacheDatabase get() {
        return cacheDatabase;
    }
} 
</code></pre>
<h3 id="创建数据库表操作类dao">创建数据库表操作类Dao</h3>
<pre><code class="language-java">// Dao 用来表示当前类是数据库表的操作类
@Dao
public interface CacheDao {
    // Insert 表示增加一条记录到数据库表中
    // onConflict 表示如果添加数据时出现冲突的解决策略
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void save(@NonNull Cache cache);

    // Delete 表示删除一条记录
    @Delete
    int delete(@NonNull Cache cache);

    // Update 表示更新一条记录
    // onConflict 表示如果更新数据时出现冲突的解决策略
    @Update(onConflict = OnConflictStrategy.REPLACE)
    int update(@NonNull Cache cache);

    // Query 查找一条记录
    @Query(&quot;SELECT * FROM cache WHERE `key`=:key&quot;)
    Cache query(@NonNull String key);
}
</code></pre>
<h2 id="type类型">Type类型</h2>
<p>由于java中的泛型在编译完毕后会擦除该类型，所以我们无法在同步执行或者多级泛型嵌套的情况下拿到泛型的实际类型。目前的解决方式有两种。</p>
<h3 id="调用者传入实际类型">调用者传入实际类型</h3>
<p>提供可以传入实际类型的方法，调用处将明确类型传递。</p>
<h3 id="利用子类实现的方式获取实际类型">利用子类实现的方式获取实际类型</h3>
<p>Java代码在编译成字节码class文件时会保留子类的泛型信息。所以大部分的json数据解析都是采用的此方法，如：Gson中的TypeToken 以及fasjson中的TypeReference。</p>
<pre><code class="language-java">public abstract class TypeToken&lt;T&gt; {
    // 泛型T的实际类型
    protected Type type;

    public TypeToken() {
        Type superClass = getClass().getGenericSuperclass();
        // 获取泛型的实际类型
        Type oriType = ((ParameterizedType) superClass).getActualTypeArguments()[0];

        if (oriType instanceof Class) {
            type = oriType;
        } else {
            //修复在安卓环境中问题
            type = putCacheTypeIfAbsent(oriType);
        }
    }
}
</code></pre>
<p>由于本次封装的返回的数据类型是<code>ApiResponse&lt;T&gt;</code>所以需要对泛型进行二次解析，所以新建了一个ApiResponseToken。</p>
<pre><code class="language-java">public abstract class ApiResponseToken&lt;T&gt; extends TypeToken&lt;T&gt; {

    public ApiResponseToken() {
        Type superClass = getClass().getGenericSuperclass();

        Type oriType = ((ParameterizedType) superClass).getActualTypeArguments()[0];

        if (oriType instanceof Class) {
            type = oriType;
        } else {
            // 解决ApiResponse&lt;T&gt;这种情况
            if (oriType instanceof ParameterizedType) {
                oriType = ((ParameterizedType) oriType).getActualTypeArguments()[0];
            }
            type = putCacheTypeIfAbsent(oriType);
        }
    }
}
</code></pre>
<p>由于本次框架的数据返回使用了<code>LiveData&lt;T&gt;</code>的形式，并通过订阅的方式实现数据返回，所以又添加了一个类型，用于自行获取type。</p>
<pre><code class="language-java">public abstract class HttpObserver&lt;T&gt; extends ApiResponseToken&lt;T&gt; 
        implements Observer&lt;T&gt; {
}
</code></pre>
<p>在使用LiveData的observe方法订阅时，在创建一个HttpObserserver实例，在构造方法中就可以解析出T的类型，就不需要我们手动传入T的真实类型了。</p>
<pre><code class="language-java"> /**
 * 开始订阅请求网络数据
 */
public &lt;T&gt; void observe(LifecycleOwner owner,
                        HttpObserver&lt;ApiResponse&lt;T&gt;&gt; observer) {
    // 由于HttpObserver是继承ApiResponseToken的，
    // 所以可以快速的获取到泛型T的实际类型
    Type type = observer.getType();
    mConfig.type = type;
    Logs.e(&quot;type: &quot; + type);
}
</code></pre>
<p>使用方式：</p>
<pre><code class="language-java">.observe(owner, 
        // 通过new HtppObserver的方式就可以拿到具体的泛型值
         new HttpObserver&lt;ApiResponse&lt;JSONObject&gt;&gt;() {
             @Override
             public void onChanged(ApiResponse&lt;JSONObject&gt; apiResponse) {
                  .....
              }
        }
);
</code></pre>
<h2 id="http请求入口类">Http请求入口类</h2>
<p>LiveHttp的封装，LiveHttp主要提供了以下功能：</p>
<ul>
<li>
<p>持有一个默认的http引擎</p>
</li>
<li>
<p>可支持设置baseUrl和设置引擎的入口</p>
</li>
<li>
<p>设置HttpConfig中的参数</p>
</li>
<li>
<p>执行Http请求入口</p>
</li>
<li>
<p>提供取消http请求的入口</p>
</li>
<li>
<p>支持链式调用</p>
</li>
</ul>
<p>以上几点都很简单，主要是来说一下执行http请求入口：</p>
<pre><code class="language-java">/**
 * 开始订阅请求网络数据
 */
public &lt;T&gt; void observe(LifecycleOwner owner,
                        HttpObserver&lt;ApiResponse&lt;T&gt;&gt; observer) {
    // 获取泛型实际类型
    Type type = observer.getType();
    mConfig.type = type;
    Logs.d(&quot;type: &quot; + type);

    if (TextUtils.isEmpty(mConfig.url())) {
        throw new IllegalArgumentException(&quot;请求路径不能为空&quot;);
    }

    MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData = new MutableLiveData&lt;&gt;();
    // liveData的订阅必须是要在主线程中
    TaskExecutor.get().postToMain(() -&gt; liveData.observe(owner, observer));
    sHttpEngine.execute(mConfig, liveData);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PicGo搭建github图床]]></title>
        <id>https://jxiaow.gitee.io/posts/2513fba4/</id>
        <link href="https://jxiaow.gitee.io/posts/2513fba4/">
        </link>
        <updated>2020-04-13T09:35:45.000Z</updated>
        <summary type="html"><![CDATA[<p>使用图床可以节省本地服务器空间，加快图片打开速度，对于写博客或者一些网站使用很有必要，本次介绍的是PicGo的使用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用图床可以节省本地服务器空间，加快图片打开速度，对于写博客或者一些网站使用很有必要，本次介绍的是PicGo的使用。</p>
<!-- more -->
<ol>
<li>
<p>下载<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>并安装；</p>
</li>
<li>
<p>生成<a href="https://github.com/">Github</a>token</p>
</li>
</ol>
<p>步骤如下：</p>
<ul>
<li>
<p>点击个人中心，选择<code>Settings</code>,打开个人设置页面；</p>
</li>
<li>
<p>在个人设置页面选择<code>Developer Settings</code></p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-52-50-github-developer-settings.png" alt="github-developer-settings.png" loading="lazy"></figure>
<ul>
<li>进入<code>Developer settings</code>页后，点击<code>Personal access tokens</code>打开新的页面后,并点击右边的<code>Generate new token</code> 生成<code>token</code></li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-54-02-image-20200413170324831.png" alt="image-20200413170324831.png" loading="lazy"></figure>
<ul>
<li>在生成<code>token</code>页面，勾选<code>repo</code></li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-54-38-image-20200413170138935.png" alt="image-20200413170138935.png" loading="lazy"></figure>
<ol start="3">
<li>创建公共仓库，用来存放相关资源图片</li>
</ol>
<p>​    在github上创建一个仓库，用来存放一些资源</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-55-22-image-20200413172848852.png" alt="image-20200413172848852.png" loading="lazy"></figure>
<ol start="4">
<li>在PicGo中配置github图床相关信息</li>
</ol>
<ul>
<li>
<p>打开PicGo 后，先安装一个插件<code>github-plus</code>，该插件是用来将图片上传到<code>gitee</code>或<code>github</code>上，比自带的<code>github</code>图床方便(自带的没有办法删除远程记录)</p>
</li>
<li>
<p>安装完成后，插件配置：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-55-54-picgo-logo.png" alt="picgo-logo.png" loading="lazy"></figure>
<p>① 处是需要存放图片的仓库，格式为 <code>github用户名/ 仓库名</code>;</p>
<p>② 处是存放图片路径的仓库下的分支，默认<code>master</code>分支；</p>
<p>③ token 为第二步骤上生成的<strong>github token</strong>；</p>
<p>④ 远程仓库存放图片的的路径，可自定义，可不填；</p>
<p>⑤ 自定义的图片路径，由于我使用了<code>jsDelivr</code>来实现github的<code>cdn缓存</code>，所以设置了此路径，如果不需要可不填；</p>
<p><strong>jsDelivr路径规则：</strong> <code>https://cdn.jsdelivr.net/gh/用户名/仓库名@版本号</code>，我这边版本号设置的是<code>latest</code>表示获取最新资源。</p>
<p>⑥ origin 表示 仓库可以是gitee或<code>github</code>,根据前面的步骤，此处只能是github；</p>
<p>⑦ 将其设置为默认图床</p>
</li>
</ul>
<p>** 注意事项**</p>
<ul>
<li>
<p>如果仓库需要设置自定义域名，需要将我们的资源提交到一个<code>gh-pages</code>分区</p>
</li>
<li>
<p>如果你的自定义域名配置dns区分了境外和国内，那么就需要注意，访问该仓库可能会出现404的情况</p>
<p>解决办法：</p>
<ul>
<li>创建一条新的cname解析，添加一个二级域名即可</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dagger2在Android中的使用]]></title>
        <id>https://jxiaow.gitee.io/posts/e781e647/</id>
        <link href="https://jxiaow.gitee.io/posts/e781e647/">
        </link>
        <updated>2019-12-06T16:24:44.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="/posts/cbb172f8">Dagger 2 完全解析（一）,基本使用与原理</a><br>
<a href="/posts/b74c4b6c">Dagger 2 完全解析（二）, 进阶使用</a><br>
<a href="/posts/e30bee8a">Dagger 2 完全解析（三）,  Component 与 SubComponent</a><br>
<a href="/posts/e781e647">Dagger 2 完全解析（四）,在Android中的使用</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="/posts/cbb172f8">Dagger 2 完全解析（一）,基本使用与原理</a><br>
<a href="/posts/b74c4b6c">Dagger 2 完全解析（二）, 进阶使用</a><br>
<a href="/posts/e30bee8a">Dagger 2 完全解析（三）,  Component 与 SubComponent</a><br>
<a href="/posts/e781e647">Dagger 2 完全解析（四）,在Android中的使用</a></p>
<!-- more -->
<blockquote>
<p>本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本</p>
</blockquote>
<p>在Android项目中使用Dagger2时，像 <code>Activity</code>和<code>Fragment</code>这种类型的初始化操作都是有Android系统提供的，如果要往其注入对象，不免会有这样的写法：</p>
<pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {

    @Inject
    lateinit var activity: MainActivity

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        DaggerMainActivityComponent.builder()
            .mainActivityModule(MainActivityModule(this))
            .appComponent(
                (application as MyApplication)
                    .daggerAppComponent
            ).build()
            .inject(this)
    }
}
</code></pre>
<p>上述写法，会有以下几个我们几乎无法避免的问题：</p>
<ol>
<li>
<p>上述Dagger部分的代码存在<strong>模板代码</strong>，在每个Activity中都会这么写到，即便抽取到BaseActivity中，也有一些特殊部分需要在每个Activity中单独处理，随着业务的增加后期维护不易；</p>
</li>
<li>
<p>从上面的代码可以看出，<code>MainActivityModule</code>中持有了<code>MainActivity</code>实例，并且需要在<code>MainActivity</code>传入参数，它打破了依赖注入的核心原则：<strong>类不应该知道它是如何注入的。</strong></p>
</li>
</ol>
<p>因此为了解决上面的问题，谷歌官方推出了<code>dagger.android</code>。</p>
<p>下面是基本的使用方式，包括如何注入<code>Activity</code>和<code>Fragment</code>,本篇只讲如何使用，后续再分析其原理。</p>
<h2 id="引入daggerandroid依赖">引入<code>Dagger.android</code>依赖</h2>
<p>在<code>build.gradle</code>中添加：</p>
<pre><code class="language-groovy">implementation 'com.google.dagger:dagger-android:2.23.2'
implementation 'com.google.dagger:dagger-android-support:2.23.2'
kapt 'com.google.dagger:dagger-android-processor:2.23.2'
</code></pre>
<h2 id="注入activity">注入Activity</h2>
<p>以<code>MainActivity</code>为例</p>
<h3 id="dagger2中的写法">Dagger2中的写法</h3>
<pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {
    // 这里只是做了一个例子
    @Inject
    lateinit var activity: MainActivity

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        DaggerMainActivityComponent.builder()
            .mainActivityModule(MainActivityModule(this))
            .appComponent(
                (application as MyApplication)
                    .daggerAppComponent
            ).build()
            .inject(this)
    }
}

@ActivityScope
@Component(modules = [MainActivityModule::class], dependencies = [AppComponent::class])
interface MainActivityComponent {
    fun inject(activity: MainActivity)
}

@Module
class MainActivityModule(private val activity: MainActivity) {
    @Provides
    fun provideMainActivity(): MainActivity = activity
}

@Scope
annotation class ActivityScope
</code></pre>
<h3 id="dagger2-android中的写法">Dagger2-Android中的写法</h3>
<h4 id="修改mainactivitycomponent">修改<code>MainActivityComponent</code></h4>
<pre><code class="language-kotlin">@ActivityScope
@Subcomponent
interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt; {
    // 声明MainActivity创建的工厂接口
    @dagger.Subcomponent.Factory
    interface Factory : AndroidInjector.Factory&lt;MainActivity&gt;
}
</code></pre>
<h4 id="修改mainactivitymodule">修改<code>MainActivityModule</code></h4>
<pre><code class="language-kotlin">@Module(subcomponents = [MainActivityComponent::class])
abstract class MainActivityModule {
    // module中提供绑定工厂方法
    @Binds
    @IntoMap
    @ClassKey(MainActivity::class)
    abstract fun bind(
        factory: MainActivityComponent.Factory
    ): AndroidInjector.Factory&lt;*&gt;
}
</code></pre>
<h4 id="修改oncreate中的dagger注入">修改<code>onCreate()</code>中的Dagger注入</h4>
<pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
   // 在super.onCreate前添加
   AndroidInjection.inject(this)
   super.onCreate(savedInstanceState)
   setContentView(R.layout.activity_main)
}
</code></pre>
<h4 id="修改myapplication">修改<code>MyApplication</code></h4>
<p>通过<code>dagger.android</code>注入时，Application中也发生了相应的变化</p>
<pre><code class="language-kotlin">class MyApplication : Application(), HasAndroidInjector {

    @Inject
    lateinit var dispatchingAndroidInjector: DqispatchingAndroidInjector&lt;Any&gt;

    override fun onCreate() {
        super.onCreate()
        DaggerAppComponent.factory().create(this).inject(this)
    }

    override fun androidInjector(): AndroidInjector&lt;Any&gt; {
        return dispatchingAndroidInjector
    }
}

@dagger.Component(
    modules = [AndroidInjectionModule::class,// 引入框架提供的InjectionModule
        AndroidSupportInjectionModule::class,// 如果使用了support相关的类，也需要引入
        MainActivityModule::class // 这是我们自定义的Module
    ]
)
interface AppComponent : AndroidInjector&lt;MyApplication&gt; {
    @dagger.Component.Factory
    interface Factory : AndroidInjector.Factory&lt;MyApplication&gt;
}
</code></pre>
<p>我们需要将我们在<code>MainActivity</code>中的<code>MainActivityModule</code>加入到<code>Application</code>中的<code>AppComponent</code>的<code>module</code>,然后<code>Make Project</code>或<code>Make App</code>或<code>build project</code>，如果未报错即成功。</p>
<h3 id="简洁写法">简洁写法</h3>
<p>如果相应的<code>ActivityComponent</code>中只有以下操作时：</p>
<pre><code class="language-kotlin">@ActivityScope
@Subcomponent
interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt; {
    // 声明MainActivity创建的工厂接口
    @dagger.Subcomponent.Factory
    interface Factory : AndroidInjector.Factory&lt;MainActivity&gt;
}
</code></pre>
<p>我们可以新建一个module类， 将满足以上条件的Component 集中到一起，并删除对应的Component，如：</p>
<pre><code class="language-kotlin">@Module
abstract class ActivityBindingModule {
    @ActivityScoped
    @ContributesAndroidInjector(modules = [MainActivityModule.class])
    abstract fun mainActivity() : MainActivity

    @ActivityScoped
    @ContributesAndroidInjector(modules = [AddEditTaskModule.class])
    abstract fun addEditTaskActivity(): AddEditTaskActivity 
}
</code></pre>
<p>删除 原有module中的<code>bind*</code>方法</p>
<pre><code class="language-java">@Module
public class MainActivityModule{

}
</code></pre>
<h2 id="注入fragment">注入Fragment</h2>
<p>注入<code>Fragment</code>与注入<code>Activity</code>类似，唯一不同的地方在于我们需要在<code>onAttach</code>方法中执行<code>AndroidSupportInject.inject(this)</code></p>
<pre><code class="language-kotlin">class BlankFragment : Fragment() {

    override fun onAttach(context: Context?) {
        AndroidSupportInjection.inject(this)
        super.onAttach(context)
    }
}

@dagger.Module
abstract class FragmentBindModule {
    @ContributesAndroidInjector
    abstract fun blankFragment(): BlankFragment
}


@dagger.Component(
    modules = [AndroidInjectionModule::class,
        AndroidSupportInjectionModule::class,
        ActivityBinder::class,
        FragmentBindModule::class
    ]
)
interface AppComponent : AndroidInjector&lt;MyApplication&gt; {

    @dagger.Component.Factory
    interface Factory : AndroidInjector.Factory&lt;MyApplication&gt;
}
</code></pre>
<p>对于<code>FragmentBindModule</code>不仅可以放入到<code>AppComponent</code>中，也可以放入到<code>MainActivityComponent</code>,或者<code>FragmentComponent</code>如：</p>
<pre><code class="language-kotlin">@dagger.Subcomponent(modules = [FragmentBindModule::class])
interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt;{

    @dagger.Subcomponent.Factory
    interface Factory: AndroidInjector.Factory&lt;MainActivity&gt;
}


@dagger.Module(subcomponents = [
    MainActivityComponent::class // 将fragment放入到了activity对应的Component
])
abstract class MainActivityModule{

    @Binds
    @IntoMap
    @ClassKey(MainActivity::class)
    abstract fun bind(factory:MainActivityComponent.Factory):AndroidInjector.Factory&lt;*&gt;
}
</code></pre>
<h2 id="一些问题">一些问题</h2>
<h3 id="model-注解的是抽象类时-provides-标注的必须是静态方法">@Model  注解的是抽象类时  @provides 标注的必须是静态方法</h3>
<blockquote>
<p>A @Module may not contain both non-static @Provides methods and abstract @Binds or @Multibinds declarations</p>
</blockquote>
<p>这个错误提示是将<code>Module</code>定义成了抽象类，这在<code>java</code>中只需要将<code>@Provide</code>标注的方法设置为静态方法即可，但是在<code>Kotlin</code>中是行不通的，因为在<code>kotlin</code>中静态方法是写在<code>companion object</code>代码块内，所以解决方法有两种：</p>
<ul>
<li>
<p>用<code>Module</code>标注<code>companion object</code></p>
<pre><code class="language-kotlin">@dagger.Module
abstract class MainActivityModule() {
    @dagger.Module
    companion object {
        @JvmStatic
        @Provides
        fun provideFragment() = BlankFragment()
    }

    @Binds
    abstract fun context(activity: MainActivity): Context
}
</code></pre>
</li>
<li>
<p>使用多个<code>Module</code>将抽象方法和<code>@provide</code>标注的方法分开，如：</p>
<pre><code class="language-kotlin">@Module
abstract class MainActivityBindsModule {
    @Binds
    abstract fun context(activity: MainActivity): Context
}

@Module(includes = arrayOf(MainActivityBindsModule ::class))
class MainActivityProvidesModule {
      @Provides
      fun provideFragment() = BlankFragment()
}
</code></pre>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>通过前面的例子我们亦可以看出：</p>
<ol>
<li>Dagger2-android 使用的是Dagger2中的<strong>继承关系</strong>；</li>
<li>使用它，我们就可以不用写那么多的模版代码，相对于<code>Dagger2</code>方便了许多；</li>
<li>Dagger2-Android 比Dagger2更强大，我们使用<code>@Binds</code>绑定抽象方法来注入一些提供初始化的类等。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dagger 2 Component 与 SubComponent]]></title>
        <id>https://jxiaow.gitee.io/posts/e30bee8a/</id>
        <link href="https://jxiaow.gitee.io/posts/e30bee8a/">
        </link>
        <updated>2019-12-05T16:23:48.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="/posts/cbb172f8">Dagger 2 完全解析（一）,基本使用与原理</a><br>
<a href="/posts/b74c4b6c">Dagger 2 完全解析（二）, 进阶使用</a><br>
<a href="/posts/e30bee8a">Dagger 2 完全解析（三）,  Component 与 SubComponent</a><br>
<a href="/posts/e781e647">Dagger 2 完全解析（四）,在Android中的使用</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="/posts/cbb172f8">Dagger 2 完全解析（一）,基本使用与原理</a><br>
<a href="/posts/b74c4b6c">Dagger 2 完全解析（二）, 进阶使用</a><br>
<a href="/posts/e30bee8a">Dagger 2 完全解析（三）,  Component 与 SubComponent</a><br>
<a href="/posts/e781e647">Dagger 2 完全解析（四）,在Android中的使用</a></p>
<!-- more -->
<blockquote>
<p>本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本</p>
</blockquote>
<p>理解前面两篇文章后，可以使用 <code>Dagger 2</code>框架完成一个对象的依赖注入。但是在实战中会存在多个需要注入依赖的对象，也就是说会有多个 <code>Component</code>，它们之间会有相同的依赖，那么该如何处理它们之间的关系呢？</p>
<p>我们先来看一个简单的例子：</p>
<p>假如有三个类：<code>A</code>、<code>B</code>和<code>C</code>, <code>A</code>和<code>B</code>都各自持有<code>C</code>的实例，并且通过<code>Dagger2</code>进行注入</p>
<pre><code class="language-kotlin">class A {
    @Inject
    lateinit var c: C
}

class B {
    @Inject
    lateinit var c: C
}

class C @Inject constructor()
</code></pre>
<p>Component:</p>
<pre><code class="language-kotlin">@Component
interface AComponent {
    fun injectA(a: A)
}

@Component
interface BComponent {
    fun injectA(b: B)
}
</code></pre>
<p>如果要让<code>A</code>、<code>B</code>持有的实例<code>C</code>相同的话，我们该如何处理？</p>
<p>很多人第一时间会想到下面这种设计：</p>
<pre><code class="language-kotlin">@Singleton
@Component(modules = [CModule::class])
interface AComponent {
    fun injectA(a: A)
}

@Singleton
@Component(modules = [CModule::class])
interface BComponent {
    fun injectA(b: B)
}

@Module
class CModule {

    companion object {
        private var c: C? = null
    }

    @Singleton
    @Provides
    fun provideC(): C {
        if (c == null) {
            c = C()
        }
        return c!!
    }
}
</code></pre>
<p>把 Component 需要的依赖都在<code>modules</code>属性中声明，但是这样有两个问题：</p>
<p>（1）有时依赖实例需要共享，例如上面场景中，<code>A</code>和<code>C</code>都持有<code>C</code>的实例，并且根据<code>Module</code>里的实现，会存在谁先创建<code>C</code>实例的问题。</p>
<p>（2）Scope 作用域容易失效，例如 <code>CModule</code> 的<code>provideCar()</code>使用 <code>@Singleton</code> 作用域，<code>AComponent</code>和<code>BComponent</code>也要用 <code>Singleton</code> 标注，但它们都会持有一个<code>C</code>实例。</p>
<p>假如<code>A</code>先创建了<code>C</code>那么，<code>BComponent</code>需要依赖 <code>AComponent</code>提供的 <code>C</code>实例，这就是 <code>Component</code> 组织关系中的一种。</p>
<h2 id="component-的组织关系">Component 的组织关系</h2>
<p>Component 管理着依赖实例，根据依赖实例之间的关系就能确定 Component 的关系。这些关系可以用<code>object graph</code>描述，我称之为依赖关系图。在 Dagger 2 中 Component 的组织关系分为两种：</p>
<ul>
<li>依赖关系，一个 Component 依赖其他 Compoent<code>公开</code>的依赖实例，用 Component 中的<code>dependencies</code>声明。</li>
<li>继承关系，一个 Component 继承（也可以叫扩展）某 Component 提供更多的依赖，SubComponent 就是继承关系的体现。</li>
</ul>
<p>所以前文中<code>AComponent</code>和<code>BComponent</code>是依赖关系。</p>
<h3 id="依赖关系">依赖关系</h3>
<p>具体的实现代码：</p>
<pre><code class="language-kotlin">@Component(modules = [CModule::class])
interface AComponent {
    fun injectA(a: A)

    fun c(): C
}

@Component(dependencies = [AComponent::class])
interface BComponent {
    fun injectA(b: B)
}

@Module
class CModule {
    @Provides
    fun provideC(): C = C()
}
</code></pre>
<p><strong>注</strong>：<strong>因为 BComponent和 AComponent是依赖关系，如果<code>AComponent</code>声明了作用域的话，那么<code>BComponent</code>也必须声明（反之可以），而且它们的 Scope 不能相同，并且两个都有作用域的情况下 @Singleton 修饰的 Component （BComponent）不能依赖其他的 Component。</strong></p>
<pre><code class="language-java">public final class DaggerBComponent implements BComponent {
  private final AComponent aComponent;

  private DaggerBComponent(AComponent aComponentParam) {
    this.aComponent = aComponentParam;
  }
 ....

  @Override
  public void injectA(B b) {
    injectB(b);}

  private B injectB(B instance) {
      // 注入时，使用了aComponent.c()
    B_MembersInjector.injectC(instance, Preconditions.checkNotNull(aComponent.c(), &quot;Cannot return null from a non-@Nullable component method&quot;));
    return instance;
  }
...
}
</code></pre>
<p>编译时生成的代码 DaggerBComponent 中会调用<code>aComponent.c()</code>，如果 AComponent 没有向外提供C 实例的接口的话，DaggerBComponent 就会注入失败。</p>
<p>依赖注入：</p>
<pre><code>val aComponent = DaggerAComponent.builder().build()
DaggerBComponent.builder().aComponent(aComponent).build().inject(b)
</code></pre>
<p>依赖关系就跟生活中的朋友关系相当，注意事项如下：</p>
<ol>
<li>被依赖的 Component 需要把暴露的依赖实例用显式的接口声明。</li>
<li>依赖关系中的 Component 的 Scope 不能相同，因为它们的生命周期不同。</li>
</ol>
<h3 id="继承关系">继承关系</h3>
<p>继承关系跟面向对象中的继承的概念有点像，<code>SubComponent</code>称为<code>子 Component</code>，类似于平常说的子类。下面先看看下面这个场景：</p>
<pre><code class="language-kotlin">class Parent {
    @Inject
    lateinit var car: Car
}

class Child {
    @Inject
    lateinit var car: Car
    @Inject
    lateinit var bike: Bike
}

class Car @Inject constructor()
class Bike @Inject constructor()
</code></pre>
<p>Child 可以开Parent的车 car，也可以骑自己的自行车 bike。依赖关系图：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-48-48-1561371949435.png" alt="1561371949435.png" loading="lazy"></figure>
<p>上图中 ChildComponent 在 ParentComponent之中，ChildComponent子承父业，可以访问 ParentComponent 的依赖，而 ParentComponent只知道 ChildComponent 是它的子类，可以访问 SubComponent.Builder，却无法访问 SubComponent 中的依赖。</p>
<pre><code class="language-kotlin">@Component(modules = [CarModule::class])
interface ParentComponent {
    fun inject(parent: Parent)
}

@Subcomponent(modules = [BikeModule::class])
interface ChildComponent {
    fun inject(child: Child)

    // SubComponent 必须显式地声明 Subcomponent.Builder，parentComponent 需要用 Builder 来创建 ChildComponent
    @Subcomponent.Builder
    interface Builder {
        fun build(): ChildComponent
    }
}
</code></pre>
<p><code>@SubComponent</code>的写法与<code>@Component</code>一样，只能标注接口或抽象类，与依赖关系一样，SubComponent 与 parent Component 的 Scope 不能相同，只是 SubComponent 表明它是继承扩展某 Component 的。怎么表明一个 SubComponent 是属于哪个 parent Component 的呢？只需要在 parent Component 依赖的 Module 中的<code>subcomponents</code>加上 SubComponent 的 class，然后就可以在 parent Component 中请求 SubComponent.Builder。</p>
<pre><code class="language-kotlin">@Component(modules = [CarModule::class])
interface ParentComponent {
    ...
    // 用来创建childComponent
    fun childComponent(): ChildComponent.Builder
}

@Subcomponent(modules = [BikeModule::class])
interface ChildComponent {
    ...
    // SubComponent 必须显式地声明 Subcomponent.Builder，parentComponent 需要用 Builder 来创建 ChildComponent
    @Subcomponent.Builder
    interface Builder {
        fun build(): ChildComponent
    }
}
// 在CarModule上添加subComponents
@Module(subcomponents = [ChildComponent::class])
class CarModule {
    @Provides
    fun provideCar() = Car()
}

@Module
class BikeModule {
    @Provides
    fun provideBike() = Bike()
}
</code></pre>
<p>上面的代码经过<code>make project</code>后，dagger2生成的代码：</p>
<pre><code class="language-java">public final class DaggerParentComponent implements ParentComponent {
  ...
  @Override
  public ChildComponent.Builder childComponent() {
    return new ChildComponentBuilder();}
  ...
  private final class ChildComponentBuilder implements ChildComponent.Builder {
    @Override
    public ChildComponent build() {
      return new ChildComponentImpl(new BikeModule());
    }
  }

  private final class ChildComponentImpl implements ChildComponent {
    private final BikeModule bikeModule;

    private ChildComponentImpl(BikeModule bikeModuleParam) {
      this.bikeModule = bikeModuleParam;
    }
   ...
    private Child injectChild(Child instance) {
      // 注入car时，调用的parentComponent的carModule提供
      Child_MembersInjector.injectCar(instance, CarModule_ProvideCarFactory.provideCar(DaggerParentComponent.this.carModule));
      Child_MembersInjector.injectBike(instance, BikeModule_ProvideBikeFactory.provideBike(bikeModule));
      return instance;
    }
  }
}
</code></pre>
<p>SubComponent 编译时不会生成 DaggerChildComponent，需要通过 parentComponent 的获取 SubComponent.Builder 方法获取 ChildComponent 实例。</p>
<pre><code class="language-kotlin">val parentComponent = DaggerParentComponent.builder().build()
parentComponent.childComponent().build().inject(child)
</code></pre>
<p><strong>继承关系和依赖关系最大的区别就是：继承关系中不用显式地提供依赖实例的接口，SubComponent 继承 parent Component 的所有依赖。</strong></p>
<h3 id="依赖关系-vs-继承关系">依赖关系 vs 继承关系</h3>
<p>相同点：</p>
<ul>
<li>两者都能复用其他 Component 的依赖</li>
<li>有依赖关系和继承关系的 Component 不能有相同的 Scope</li>
</ul>
<p>区别：</p>
<ul>
<li>依赖关系中被依赖的 Component 必须显式地提供公开依赖实例的接口，而 SubComponent 默认继承 parent Component 的依赖。</li>
<li>依赖关系会生成两个独立的 DaggerXXComponent 类，而 SubComponent 不会生成 独立的 DaggerXXComponent 类。</li>
</ul>
<p>在 Android 开发中，Activity 是 App 运行中组件，Fragment 又是 Activity 一部分，这种组件化思想适合继承关系，所以在 Android 中一般使用 SubComponent。</p>
<h2 id="subcomponent-的其他问题">SubComponent 的其他问题</h2>
<h3 id="抽象工厂方法定义继承关系">抽象工厂方法定义继承关系</h3>
<p>除了使用 Module 的<code>subcomponents</code>属性定义继承关系，还可以在 parent Component 中声明返回 SubComponent 的抽象工厂方法来定义：</p>
<pre><code class="language-kotlin">@Component(modules = [CarModule::class])
interface ParentComponent {
    ...
    // 用来创建childComponent
    //// 这个抽象工厂方法表明 ChildComponent 继承 ParentComponent
    fun childComponent(): ChildComponent
}

@Subcomponent(modules = [BikeModule::class])
interface ChildComponent {
    ...
}

@Module
class CarModule {
    @Provides
    fun provideCar() = Car()
}

@Module
class BikeModule {
    @Provides
    fun provideBike() = Bike()
}
</code></pre>
<p>这种定义方式不能很明显地表明继承关系，一般推荐使用 Module 的<code>subcomponents</code>属性定义。</p>
<h3 id="重复的-module">重复的 Module</h3>
<p>当相同的 Module 注入到 parent Component 和它的 SubComponent 中时，则每个 Component 都将自动使用这个 Module 的同一实例。也就是如果在 SubComponent.Builder 中调用相同的 Module 或者在返回 SubComponent 的抽象工厂方法中以重复 Module 作为参数时，会出现错误。（前者在编译时不能检测出，是运行时错误）</p>
<pre><code class="language-java">@Component(modules = {RepeatedModule.class, ...})
interface ComponentOne {
  ComponentTwo componentTwo(RepeatedModule repeatedModule); // 编译时报错
  ComponentThree.Builder componentThreeBuilder();
}

@Subcomponent(modules = {RepeatedModule.class, ...})
interface ComponentTwo { ... }

@Subcomponent(modules = {RepeatedModule.class, ...})
interface ComponentThree {
  @Subcomponent.Builder
  interface Builder {
    Builder repeatedModule(RepeatedModule repeatedModule);
    ComponentThree build();
  }
}

DaggerComponentOne.create().componentThreeBuilder()
    .repeatedModule(new RepeatedModule()) // 运行时报错 UnsupportedOperationException!
    .build();
</code></pre>
<h2 id="总结">总结</h2>
<p>Component 之间共用相同依赖，可以有两种组织关系：依赖关系与继承关系。至于如何选择试具体情况而定，但在 Android 开发中，一般使用继承关系，以 AppComponent 作为 root Component，AppComponent 一般还会使用 @Singleton 作用域，而 ActivityComponent 为 SubComponent。</p>
]]></content>
    </entry>
</feed>