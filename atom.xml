<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jxiaow.gitee.io</id>
    <title>Xiaowu</title>
    <updated>2020-12-15T02:38:23.751Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jxiaow.gitee.io"/>
    <link rel="self" href="https://jxiaow.gitee.io/atom.xml"/>
    <subtitle>心若没有栖息的地方，到哪里都是在流浪</subtitle>
    <logo>https://jxiaow.gitee.io/images/avatar.png</logo>
    <icon>https://jxiaow.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Xiaowu</rights>
    <entry>
        <title type="html"><![CDATA[Paint高级应用---Shader]]></title>
        <id>https://jxiaow.gitee.io/posts/36c3e87b/</id>
        <link href="https://jxiaow.gitee.io/posts/36c3e87b/">
        </link>
        <updated>2020-12-15T01:40:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="paint高级应用篇-shader">Paint高级应用篇---Shader</h1>
<p>Paint的高级用法主要有：<strong>渲染着色</strong>、**滤镜 ** 和 <strong>Xfermode</strong>。</p>
<p><code>Canvas</code>的<code>drawXXX</code>方法画具体的形状，<code>Paint</code>的<code>Shader</code>定义图像的着色和外观。</p>
<p>目前 <code>Shader</code>的子类有 <strong>LinearGradient(线性渲染)</strong>、<strong>SweepGradient(渐变渲染/梯度渲染)</strong>、<br>
<strong>RadialGradient(环形渲染)</strong>、**BitmapShader(位图渲染) **   和 <strong>ComposeShader(组合渲染)</strong>。</p>
<h2 id="tilemode-拉伸形式">TileMode （拉伸形式）</h2>
<p>TileMode 拉伸方式，在Shader的创建中会用到。<strong>只在图片和显示区域大小不符的情况进行扩充渲染</strong>，<code>TileMode</code>源码定义如下：</p>
<pre><code class="language-java">public enum TileMode {
   /**
    * replicate the edge color if the shader draws outside of its
    * original bounds
    */
    CLAMP   (0),
   /**
    * repeat the shader's image horizontally and vertically
    */
    REPEAT  (1),
   /**
    * repeat the shader's image horizontally and vertically, alternating
    * mirror images so that adjacent images always seam
    */
    MIRROR  (2);
}
</code></pre>
<p>从源码定义上可以看到<code>TileMode</code>是一个枚举类，定义了3种类型：<code>CLAMP</code>、<code>REPEAT</code>和 <code>MIRROR</code>。</p>
<h3 id="clamp">CLAMP</h3>
<p><code>CLAMP</code> 拉伸最后一个像素铺满容器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/c7780467b65c9784507b7d78720d19d3-avatar-0ace00.jpg" alt="avatar" loading="lazy"> <img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/c4921c5f1dc208da89f709bedbc7114d-image-20201210160303691-4c6ae5.png" alt="image-20201210160303691" loading="lazy"></p>
<p>代码如下：</p>
<pre><code class="language-kotlin">// 获取Bitmap
private val bitmap: Bitmap = BitmapFactory.decodeResource(resources, R.drawable.avatar)
private val paint = Paint()
 
init {
    // 初始化BitmapShader,并将 x,y的拉伸模式设置为CLAMP
    paint.shader = BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
}
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.drawRect(100f,0f,bitmap.width.toFloat() * 2,bitmap.height * 2f,paint)
}
</code></pre>
<h3 id="mirror">MIRROR</h3>
<p>横向和纵向不足处不断翻转镜像平铺。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/49950ca69ea172128172bf76c1309974-image-20201210161154210-bbc751.png" alt="image-20201210161154210" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-kotlin">// 获取Bitmap
private val bitmap: Bitmap = BitmapFactory.decodeResource(resources, R.drawable.avatar)
private val paint = Paint()
 
init {
    // 初始化BitmapShader,并将 x,y的拉伸模式设置为MIRROR
    paint.shader = BitmapShader(bitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR)
}
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.drawRect(100f,0f,bitmap.width.toFloat() * 2,bitmap.height * 2f,paint)
}
</code></pre>
<h3 id="repeat">REPEAT</h3>
<p>横向和纵向不足时重复放置，类似于电脑壁纸。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/83261140255f9d0895b5ac2be7108ffd-image-20201210161732543-f37dc2.png" alt="image-20201210161732543" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-kotlin">// 获取Bitmap
private val bitmap: Bitmap = BitmapFactory.decodeResource(resources, R.drawable.avatar)
private val paint = Paint()
 
init {
    // 初始化BitmapShader,并将 x,y的拉伸模式设置为REPEAT
    paint.shader = BitmapShader(bitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)
}
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.drawRect(100f,0f,bitmap.width * 2f,bitmap.height * 1.5f,paint)
}
</code></pre>
<h2 id="线性渲染-lineargradient">线性渲染 LinearGradient</h2>
<p><code>LinearGradient</code>用来实现线性渐变效果。</p>
<pre><code class="language-java">public class LinearGradient extends Shader {}
</code></pre>
<p>渐变效果：</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/b21809293ec73ddd2f9f6f6fd60be59e-image-20201210174046124-491aec.png" alt="image-20201210174046124" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val linearGradient = LinearGradient(0f, 0f, 500f, 300f, Color.RED, Color.BLUE, Shader.TileMode.CLAMP)
    paint.shader = linearGradient
    canvas.drawRect(0f, 0f, 800f, 800f, paint)
}
</code></pre>
<p>使用效果：</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/0b9f21e195bc13c54cc2c5a5943b4382-image-20201210162543735-7d47de.png" alt="image-20201210162543735" loading="lazy"></figure>
<pre><code class="language-kotlin">// 0x22ffffff, -0x1, 0x22ffffff
class LinearGradientText @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : AppCompatTextView(context, attrs, defStyleAttr) {
    // 线性渐变
    private var linearGradient: LinearGradient? = null
    // 平移matrix
    private val translateMatrix: Matrix = Matrix()
    // 平移变量默认值
    private var defaultX: Float = 20f
    // 平移量间隔值
    private var translateX: Float = 0f
 
    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        // 获取文本值
        val text = text.toString()
        // 获取文本的测量宽度
        val measureTextWidth = paint.measureText(text)
        val gradientSize = measureTextWidth / text.length * 3
        linearGradient = LinearGradient(
            -gradientSize, 0f, 0f, 0f,
            intArrayOf(0x22ffffff, -0x1, 0x22ffffff), null, Shader.TileMode.CLAMP
        )
        paint.shader = linearGradient
    }
 
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        translateX += defaultX
        val measureTextWidth = paint.measureText(text.toString())
        val count = if (lineCount &gt; 1) lineCount - 1 else 1
        if (translateX &gt; measureTextWidth / count || translateX &lt; 1) {
            defaultX = -defaultX
        }
        translateMatrix.setTranslate(translateX, 0f)
        linearGradient?.setLocalMatrix(translateMatrix)
        postInvalidateDelayed(50)
    }
}
</code></pre>
<h2 id="位图渲染-bitmapshader">位图渲染 BitmapShader</h2>
<p><code>BitmapShader</code> 位图图像渲染，用<code>Bitmap</code>对绘制的图形进行渲染着色，简单来说是用图片对图形进行贴图。</p>
<p>在<strong>TileMode</strong>中已有基本使用，具体请看 <a href="#CLAMP">CLAMP</a>。</p>
<p>以下使用代码公共部分：</p>
<pre><code class="language-kotlin">class GradientView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {
 
    private val bitmap: Bitmap = BitmapFactory.decodeResource(resources, R.drawable.avatar)
    private var bWidth: Int = 0
    private var bHeight: Int = 0
    private val paint = Paint()
    private var bitmapShader: BitmapShader? = null
    private val shapeMatrix = Matrix()
    private val rectF = RectF()
 
    init {
        // 获取资源图片
        bWidth = bitmap.width
        bHeight = bitmap.height
        /**
         * TileMode.CLAMP 拉伸最后一个像素去铺满剩下的地方
         * TileMode.MIRROR 通过镜像翻转铺满剩下的地方。
         * TileMode.REPEAT 重复图片平铺整个画面（电脑设置壁纸）
         * 在图片和显示区域大小不符的情况进行扩充渲染
         */
        bitmapShader = BitmapShader(bitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)
        paint.shader = bitmapShader
    }
 
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
}
</code></pre>
<ul>
<li>圆形头像</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/18499d4ef9f62abaacf05392847fde4d-image-20201210164831234-e00d13.png" alt="image-20201210164831234" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    // 坐标轴移动1/4的原因是，坐标轴移动1/4的位置为原点，然后将图片缩放后，图片的顶点与原点重合
    // 进行画园时刚好位于正中心，切换切割的图片也是图片的y中心部分
    canvas.translate(width / 4f, height / 4f)
    paint.shader = bitmapShader
    paint.isAntiAlias = true
    // 图片缩放
    val scale = max(bWidth, bHeight) / min(bWidth, bHeight) * 1.0f
    shapeMatrix.setScale(scale, scale)
    shader.setLocalMatrix(shapeMatrix)
    canvas.drawCircle(bHeight / 2f, bHeight / 2f, bHeight / 2f, paint)
}
</code></pre>
<ul>
<li>椭圆头像</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/4edc446d253def1781495fe8c9c67c87-image-20201210171000171-61fc7c.png" alt="image-20201210171000171" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    // 坐标轴移动1/4的原因是，坐标轴移动1/4的位置为原点，然后将图片缩放后，图片的顶点与原点重合
    // 进行画园时刚好位于正中心，切换切割的图片也是图片的y中心部分
    canvas.translate(width / 4f, height / 4f)
    paint.shader = bitmapShader
    paint.isAntiAlias = true
    // 图片缩放
    val scale = max(bWidth, bHeight) / min(bWidth, bHeight) * 1.0f
    shapeMatrix.setScale(scale, scale)
    shader.setLocalMatrix(shapeMatrix)
    rectF.set(0f, 0f, bWidth + 100f, bHeight.toFloat())
    canvas.drawOval(rectF, paint)
}
</code></pre>
<ul>
<li>矩形头像</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/b83368302c591bd70b22d537a616144e-image-20201210171452728-8823d8.png" alt="image-20201210171452728" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
       canvas.translate(width/4, height/4)
    paint.shader = bitmapShader
    // 抗锯齿
    paint.isAntiAlis = true
    val scale = max(bWidth, bHeight) / min(bWidth, bHeight)
    shapeMatrix.setScale(scale,scale)
    paint.shader.setLocalMatrix(shapeMatrix)
    rectF.set(0f, 0f, bWidth.toFloat(), bHeight.toFloat())
    canvas.drawRect(rectF,paint)
}
</code></pre>
<ul>
<li>ShapeDrawable实现头像</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/18499d4ef9f62abaacf05392847fde4d-image-20201210164831234-e00d13.png" alt="image-20201210164831234" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.translate(width / 4f, height / 4f)
    paint.shader = bitmapShader
    paint.isAntiAlias = true
    // 图片缩放
    val scale = max(bWidth, bHeight) / min(bWidth, bHeight)
    shapeMatrix.setScale(scale, scale)
    paint.shader.setLocalMatrix(shapeMatrix)
    rectF.set(0f, 0f, bWidth.toFloat(), bHeight.toFloat())
    val shapeDrawable = ShapeDrawable(OvalShape())
    shapeDrawable.paint.shader = bitmapShader
    shapeDrawable.bounds = rectF.toRect()
    shapeDrawable.draw(canvas)
}
</code></pre>
<h2 id="环形渲染-radialgradient">环形渲染 RadialGradient</h2>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/23c886987bc816cb4b8128b52169155e-image-20201210180214610-e2b7f3.png" alt="image-20201210180214610" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val radialGradient = RadialGradient(
        400f, 400f, 300f,
        intArrayOf(
            Color.RED,
            Color.GREEN,
            Color.BLUE,
            Color.YELLOW
        ), null, Shader.TileMode.REPEAT
    )
    paint.shader = radialGradient
    canvas.drawCircle(400f,400f,400f, paint)
}
</code></pre>
<h2 id="渐变渲染-sweepgradient">渐变渲染 SweepGradient</h2>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/11/37ceff71f9bc763ddc547dea5ef61570-image-20201211093531255-d05eaa.png" alt="image-20201211093531255" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val sweepGradient = SweepGradient(
        300f,300f,
        intArrayOf(
            Color.RED,
            Color.GREEN,
            Color.BLUE,
            Color.YELLOW
    ), null)
    paint.shader = sweepGradient
    canvas.drawCircle(300f,300f,300f,paint)
}
</code></pre>
<h2 id="组合着色-composeshader">组合着色 ComposeShader</h2>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/11/741ceb198042d9e6d563121c62daf599-image-20201211093902530-e90cc5.png" alt="image-20201211093902530" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val linearGradient = LinearGradient(0f, 0f, 300f, 300f, Color.RED, Color.WHITE,Shader.TileMode.CLAMP)
    val sweepGradient = SweepGradient(
        200f, 200f, intArrayOf(
            Color.RED,
            Color.GREEN,
            Color.BLUE,
            Color.YELLOW
        ), null
    )
    val composeShader = ComposeShader(linearGradient,sweepGradient,PorterDuff.Mode.MULTIPLY)
    paint.shader = composeShader
    canvas.drawRect(100f,100f,500f,500f,paint)
}
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/11/a6490c5461077c4705972003b829ea1c-image-20201211094327261-dfbcdc.png" alt="image-20201211094327261" loading="lazy"></figure>
<pre><code class="language-kotlin">override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    val bitmap = BitmapFactory.decodeResource(resources, R.drawable.heart)
    canvas.translate(measuredWidth/4f, measuredHeight/4f)
    val heartBitmapShader = BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
 
    val linearGradient = LinearGradient(
        0f,
        0f,
        bitmap.width.toFloat(),
        bitmap.height.toFloat(),
        Color.RED,
        Color.GREEN,
        Shader.TileMode.CLAMP
    )
    val composeShader =
    ComposeShader(heartBitmapShader, linearGradient, PorterDuff.Mode.MULTIPLY)
    paint.isAntiAlias = true
    paint.shader = composeShader
    canvas.drawRect(0f, 0f, bitmap.width.toFloat(), bitmap.height.toFloat(), paint)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图形绘制-Paint]]></title>
        <id>https://jxiaow.gitee.io/posts/46f22235/</id>
        <link href="https://jxiaow.gitee.io/posts/46f22235/">
        </link>
        <updated>2020-12-10T05:35:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="canvas和paint的关系">Canvas和Paint的关系</h2>
<p>在对UI绘制流程的分析中，可以知道<code>performCanvas()</code>方法最终会调用到<code>View#onDraw()</code>方法，并且会传递<code>Canvas</code>，那么<code>Canvas</code>到底有什么用呢？</p>
<p><code>Canvas</code>在UI绘制中扮演的是<code>会话角色</code>，我们通常情况下都能够知道使用Canvas去 画圆型，矩形图片等，但是最终其真正的绘制并不是在我们的android 层面进行的。</p>
<p>通过源码分析，<code>Canvas</code> 继承了<code>BaseCanvas</code></p>
<pre><code class="language-java">public class Canvas extends BaseCanvas {}
</code></pre>
<p>在<code>BaseCanvas</code>中，我们可以发现有大量以<code>nDraw</code>开头的方法，比如<code>drawCircle</code>。</p>
<pre><code class="language-java">public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint) {
    throwIfHasHwBitmapInSwMode(paint);
    nDrawCircle(mNativeCanvasWrapper, cx, cy, radius, paint.getNativeInstance());
}
</code></pre>
<pre><code class="language-java">private static native void nDrawCircle(long nativeCanvas, float cx, float cy, float radius, long nativePaint);
</code></pre>
<p>通过上述代码块我们可以知道，Canvas并不是具体的执行者，而是一个传达着， 在Canvas当中我们会将所有的参数信息设置好，然后交由底层去绘制。</p>
<p>我们通过观察Canvas中的绘制方法，可以发现每一个绘制方法中都有一个<code>Paint</code>类型的参数，那么Paint的职责到底是什么呢？打开Paint的源码，可以看到:</p>
<pre><code class="language-java">/**
* The Paint class holds the style and color information about how to draw
* geometries, text and bitmaps.
*/
public class Paint {}
</code></pre>
<p>注释中描述了Paint 在绘制过程中保存了色彩信息和样式信息。</p>
<h2 id="paint基础">Paint基础</h2>
<p>Paint方法主要可以抽象成2大类：</p>
<h3 id="设置和获取图像绘制-路径相关数据">设置和获取图像绘制、路径相关数据</h3>
<h4 id="设置画笔样式">设置画笔样式</h4>
<pre><code class="language-kotlin">// 设置画笔填充样式
paint.style = Paint.Style.STROKE
</code></pre>
<blockquote>
<p>Paint.Style.FILL :填充内部<br>
Paint.Style.FILL_AND_STROKE ：填充内部和描边<br>
Paint.Style.STROKE ：仅描边<br>
注意 STROKE、FILL_AND_STROKE与FILL模式相比 外轮廓的位置会扩大。</p>
</blockquote>
<h4 id="设置画笔宽度">设置画笔宽度</h4>
<pre><code class="language-kotlin">// 设置画笔宽度
paint.strokeWidth = 200.0f
</code></pre>
<h4 id="抗锯齿功能">抗锯齿功能</h4>
<ul>
<li>设置抗锯齿</li>
</ul>
<pre><code class="language-kotlin">// 开启抗锯齿
paint.isAntiAlias = true
</code></pre>
<ul>
<li>获取是否开启抗锯齿</li>
</ul>
<pre><code class="language-kotlin">val isAntiAlias = paint.isAntiAlias
</code></pre>
<blockquote>
<p>开启抗锯齿功能会消耗较大资源，绘制图形速度会变慢，但开启后绘制图像会平滑一些。</p>
</blockquote>
<h4 id="设置线冒样式">设置线冒样式</h4>
<pre><code class="language-kotlin">// 设置圆形线冒
paint.strokeCap = Paint.Cap.ROUND
</code></pre>
<blockquote>
<p>Cap.ROUND(圆形线冒)、 Cap.SQUARE(方形线冒) 、Paint.Cap.BUTT(无线冒)</p>
</blockquote>
<p>效果图：<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/964578978be8541993263fbf3950f8b1-image-20201210094248494-65db78.png" alt="image-20201210094248494" loading="lazy"></p>
<p>代码如下：</p>
<pre><code class="language-kotlin">val paint = Paint()
fun init() {
    // 设置画笔填充样式
    paint.style = Paint.Style.STROKE
    // 开启抗锯齿
    paint.isAntiAlias = true
    // 设置画笔颜色
    paint.color = Color.RED
    // 设置画笔宽度
    paint.strokeWidth = 200.0f
    // 设置圆形线冒
    paint.strokeCap = Paint.Cap.ROUND
}
 
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    canvas.drawLine(200f, 300f, 400f, 300f, paint)
}
</code></pre>
<h4 id="设置连接处线段">设置连接处线段</h4>
<pre><code class="language-kotlin">// 设置线段链接处的样式
paint.strokeJoin = Paint.Join.MITER
</code></pre>
<blockquote>
<p>Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线)</p>
</blockquote>
<p>效果图：<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/10/8559d0ecf86dabc0e14da1eca468675c-image-20201210094852252-2c05c2.png" alt="image-20201210094852252" loading="lazy"></p>
<p>代码如下：</p>
<pre><code class="language-kotlin">// 创建画笔
private val paint: Paint = Paint()
// 创建矩形区域
private val rect: Rect = Rect()
 
 
init {
    // 设置画笔填充样式
    paint.style = Paint.Style.STROKE
    // 开启抗锯齿
    paint.isAntiAlias = true
    // 设置画笔颜色
    paint.color = Color.RED
    // 设置画笔宽度
    paint.strokeWidth = 200.0f
    // 设置线段链接处于样式
    paint.strokeJoin = Paint.Join.ROUND
}
 
 
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    rect.set(200, 300, 400, 400)
    canvas.drawRect(rect, paint)
}
</code></pre>
<h4 id="设置画笔倾斜度">设置画笔倾斜度</h4>
<pre><code class="language-kotlin">// 设置画笔倾斜度
paint.strokeMiter = 0.8f
</code></pre>
<h4 id="清空画笔复位">清空画笔复位</h4>
<pre><code class="language-kotlin">// 画笔复位
paint.reset()
</code></pre>
<h4 id="设置外来画笔">设置外来画笔</h4>
<pre><code class="language-kotlin">// 设置一个新的画笔
paint.set(Paint())
</code></pre>
<h4 id="获取与设置alpha值颜色和argb">获取与设置alpha值，颜色和ARGB</h4>
<pre><code class="language-kotlin">// 透明度 0 -100
// r、g、b 0-255
paint.setARGB(80,110,234, 125)
 
 
// 设置透明度 0（完全透明） - 100 （不透明）
paint.alpha = 100
// 获取透明度
val alpha = paint.alpha
 
 
// 设置颜色
paint.color = Color.BLUE
// 获取颜色
val color = paint.color
</code></pre>
<h4 id="图像抖动处理">图像抖动处理</h4>
<ul>
<li>开启图像抖动</li>
</ul>
<pre><code class="language-kotlin">// 开启图像抖动
paint.isDither = true
</code></pre>
<ul>
<li>获取图像抖动是否开启</li>
</ul>
<pre><code class="language-kotlin">// 开启图像抖动
val isDither = paint.isDither
</code></pre>
<blockquote>
<p>会使绘制出来的图像颜色更加平滑、饱满和图像更加清晰</p>
</blockquote>
<h4 id="设置绘制路径效果">设置绘制路径效果</h4>
<pre><code class="language-kotlin">// 设置虚线
// intervals： 控制实线和实线之后空白线的宽度（数组长度必须为偶数）
// phase： 将View向”左“偏移phase
paint.pathEffect = DashPathEffect(intervals = floatArrayOf(20f,10f,50f,100f), phase = 15f)
</code></pre>
<blockquote>
<p>CornerPathEffect  ——圆形拐角效果<br>
paint.setPathEffect(new CornerPathEffect(100))<br>
利用半径R=50的圆来代替原来两条直线间的夹角<br>
DashPathEffect  ——虚线效果    画同一条线段,偏移值为15<br>
paint.setPathEffect(new DashPathEffect(new float[]{20,10,50,100},15))<br>
intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[]中这些基本线段循环组成的。比如，我们定义new float[] {20,10}； 那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10；<br>
phase：开始绘制的偏移值</p>
</blockquote>
<h4 id="设置图形重叠时的处理方式">设置图形重叠时的处理方式</h4>
<pre><code class="language-kotlin">paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.MULTIPLY)
</code></pre>
<p>通过设置xfermode 可以设置许多不同的效果，如 制作橡皮擦， 具体介绍请看 Paint的高级用法</p>
<h4 id="设置maskfilter">设置MaskFilter</h4>
<pre><code class="language-kotlin">paint.maskFilter = MaskFilter()
</code></pre>
<p>可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等 。</p>
<pre><code class="language-java">/**
* Create a blur maskfilter.
*
* @param radius 阴影的半径
 * @param style  NORMOL -- 整个图像都被模糊掉
 *               SOLID -- 图像边界外产生一层与Paint颜色一致阴影效果，不影响图像的本身
 *               OUTER -- 图像边界外产生一层阴影，并且将图像变成透明效果
 *               INNER -- 在图像内部边沿产生模糊效果
* @return
*/
paint.setMaskFilter(new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL));
</code></pre>
<pre><code class="language-java">/**
* Create an emboss maskfilter
*
 * @param direction  指定光源的位置，长度为xxx的数组标量[x,y,z]
 * @param ambient    环境光的因子 （0~1），越接近0，环境光越暗
 * @param specular   镜面反射系数 越接近0，镜面反射越强
* @param blurRadius 模糊半径 值越大，模糊效果越明显
*/
paint.setMaskFilter(new EmbossMaskFilter(new float[]{1,1,1},0.2f,60,80));
</code></pre>
<h4 id="设置颜色过滤器">设置颜色过滤器</h4>
<pre><code class="language-kotlin">paint.colorFilter = ColorFilter()
</code></pre>
<p>可以在绘制颜色时实现不用颜色的变换效果，可以用来设置图像的黑白效果。</p>
<h4 id="设置图像效果">设置图像效果</h4>
<pre><code class="language-kotlin">paint.shader = Shader()
</code></pre>
<p>使用Shader可以绘制出各种渐变效果。Shader有一些子类，如：LinearGradient。</p>
<h4 id="在图像下设置阴影层">在图像下设置阴影层</h4>
<pre><code class="language-kotlin">// radius 为阴影的角度
// dx和dy为阴影在x轴和y轴上的距离
// color为阴影的颜色
paint.setShadowLayer(float radius ,float dx,float dy,int color)
</code></pre>
<h3 id="设置获取文字相关的">设置获取文字相关的</h3>
<h4 id="获取字符的行间距">获取字符的行间距</h4>
<pre><code class="language-kotlin">val spacing = paint.fontSpacing
</code></pre>
<h4 id="设置和获取字符的间距">设置和获取字符的间距</h4>
<pre><code class="language-kotlin">// 获取字符的间距 api &gt;= 21
val letterSpacing = paint.letterSpacing
// 设置字符的间距 api &gt;= 21
paint.letterSpacing = 20f
</code></pre>
<h4 id="是否有下划线和设置下划线">是否有下划线和设置下划线</h4>
<pre><code class="language-kotlin">// 获取是否有下划线
val isUnderlineText = paint.isUnderlineText
// 设置下划线
paint.isUnderlineText = true
</code></pre>
<h4 id="获取与设置是否有文本删除线">获取与设置是否有文本删除线</h4>
<pre><code class="language-kotlin">// 设置文本删除线
paint.isStrikeThruText = true
// 获取文本删除线
val isStrikeThruText = paint.isStrikeThruText
</code></pre>
<h4 id="获取与设置文字大小">获取与设置文字大小</h4>
<pre><code class="language-kotlin">// 获取文字大小
val textSize = paint.textSize
// 设置文字大小
paint.textSize = 14f
</code></pre>
<p><strong>注意：</strong> <code>Paint.setTextSize</code> 单位是<code>px</code>，<code>TextView.setTextSize</code>单位是<code>sp</code>。</p>
<h4 id="获取与设置字体类型">获取与设置字体类型</h4>
<pre><code class="language-kotlin">// 设置字体样式
paint.typeface = Typeface.DEFAULT
val typeface = paint.typeface
</code></pre>
<blockquote>
<p>默认有四种字体样式：     BOLD(加粗、BOLD_ITALIC(加粗并倾斜)、ITALIC(倾斜)、NORMAL(正常)<br>
也可通过Typeface类来自定义个性化字体。</p>
</blockquote>
<h4 id="获取与设置文字倾斜">获取与设置文字倾斜</h4>
<pre><code class="language-kotlin">// 设置文字倾斜度
paint.textSkewX = -0.25f
val textSkewX = paint.textSkewX
</code></pre>
<blockquote>
<p>参数没有具体范围, 官方推荐值为-0.25，值为负则右倾，为正则左倾，默认值为0。</p>
</blockquote>
<h4 id="获取与设置文本对齐方式">获取与设置文本对齐方式</h4>
<pre><code class="language-kotlin">// 设置文本的对齐方式
paint.textAlign = Paint.Align.CENTER
val textAlign = paint.textAlign
</code></pre>
<blockquote>
<p>取值为 CENTER、LEFT、RIGHT，即文字绘制是左边对齐、右边还是局中。</p>
</blockquote>
<h4 id="亚像素">亚像素</h4>
<pre><code class="language-kotlin">// 设置亚像素
paint.isSubpixelText = true
</code></pre>
<blockquote>
<p>固定的几个范围：320<em>480，480</em>800，720<em>1280，1080</em>1920等，那么如何在同样的分辨率的显示器中增强显示清晰度呢？<br>
亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。 所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。</p>
</blockquote>
<h4 id="文本折断">文本折断</h4>
<pre><code class="language-kotlin">paint.breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)
</code></pre>
<p>如文本阅读器的翻页效果，我们需要在翻页的时候动态折断或生成一行字符串。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI布局绘制入口]]></title>
        <id>https://jxiaow.gitee.io/posts/cd03afe4/</id>
        <link href="https://jxiaow.gitee.io/posts/cd03afe4/">
        </link>
        <updated>2020-12-08T09:26:35.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/03/dd54efe6dc0cf2678d09ae0aa9551b0f-Android%20UI%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B-d85b30.svg" alt="Android UI绘制流程" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/03/dd54efe6dc0cf2678d09ae0aa9551b0f-Android%20UI%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B-d85b30.svg" alt="Android UI绘制流程" loading="lazy"></figure>
<!--more-->
<p>在Activity的生命周期中，系统服务AMS会调用到ActivityThread中的<code>handleResumeActivity</code>方法，在这个方法中，可以看到：</p>
<pre><code class="language-java">@Override

public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) {
    // ...
    // TODO Push resumeArgs into the activity for consideration
    final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);
    if (r == null) {
        // We didn't actually resume the activity, so skipping any follow-up actions.
        return;
    }

    // ...
    if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {
        // 获取window
        r.window = r.activity.getWindow();
        // 获取decor
        View decor = r.window.getDecorView();
        // 先将decorView设置不可见
        decor.setVisibility(View.INVISIBLE);
        // 获取windowManager
        ViewManager wm = a.getWindowManager();
        WindowManager.LayoutParams l = r.window.getAttributes();
        a.mDecor = decor;
        // 设置window的层级
        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
           // ...
        if (a.mVisibleFromClient) {
            if (!a.mWindowAdded) {
                a.mWindowAdded = true;
                wm.addView(decor, l);
            }
            // ...
        }
        // ...
    }

    // Get rid of anything left hanging around.
    cleanUpPendingRemoveWindows(r, false /* force */);
    // The window is now visible if it has been added, we are not
    // simply finishing, and we are not starting another activity.
    if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) {
        // ...
        // 设置decor可见
        if (r.activity.mVisibleFromClient) {
            r.activity.makeVisible();
        }
    }
    // ...
}
</code></pre>
<ol>
<li>获取activity中的window；</li>
<li>获取window中的decorView并设置为不可见；</li>
<li>获取windowManager并调用addView方法添加decorView；</li>
<li>添加完毕后，通过activity.makeVisible()设置decorView可见。</li>
</ol>
<h2 id="windowmanager">WindowManager</h2>
<p>我们知道<code>WindowManager</code>是用来管理view窗口的，它是<code>ViewManager</code>的子类，它的实现类是<code>WindowManagerImpl</code>。</p>
<pre><code class="language-java">public interface WindowManager extends ViewManager {}
</code></pre>
<pre><code class="language-java">public interface ViewManager{
    // 添加view
    public void addView(View view, ViewGroup.LayoutParams params);
    // 更新布局
    public void updateViewLayout(View view, ViewGroup.LayoutParams params);
    // 移除view
    public void removeView(View view);
}
</code></pre>
<pre><code class="language-java">public final class WindowManagerImpl implements WindowManager {
    // windowManager中持有一个WindowManagerGlobal单例
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
}
</code></pre>
<h3 id="addview">addView</h3>
<p>在上面<code>handleResumeActivity</code>中调用了<code>WindowManager</code>的<code>addView</code>方法。在 addView中：</p>
<pre><code class="language-java">@Override
public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
    applyDefaultToken(params);
    // 调用了WindowManagerGlobal中的addView方法
    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
}
</code></pre>
<p>在<code>WindowManagerImpl</code>的<code>addView</code>中调用了<code>WindowManagerGlobal</code>中<code>addView</code>。</p>
<pre><code class="language-java">public void addView(View view, ViewGroup.LayoutParams params,
                    Display display, Window parentWindow) {
    // ...
    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
    if (parentWindow != null) {
        parentWindow.adjustLayoutParamsForSubWindow(wparams);
    } else {
        // If there's no parent, then hardware acceleration for this view is
        // set from the application's hardware acceleration setting.
        final Context context = view.getContext();
        if (context != null
            &amp;&amp; (context.getApplicationInfo().flags
                &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
        }
    }
    ViewRootImpl root;
    View panelParentView = null;
    synchronized (mLock) {
        // ...
        root = new ViewRootImpl(view.getContext(), display);
        view.setLayoutParams(wparams);
        mViews.add(view);
        mRoots.add(root);
        mParams.add(wparams);
        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            if (index &gt;= 0) {
                removeViewLocked(index, true);
            }
            throw e;
        }
    }
}
</code></pre>
<p>mViews保存的是View对象，DecorView<br>
mRoots保存和顶层View关联的ViewRootImpl对象<br>
mParams保存的是创建顶层View的layout参数。<br>
调用<code>root.setView</code>将参数和视图同时交给了<code>ViewRootImpl</code>。</p>
<pre><code class="language-java">public final class ViewRootImpl implements ViewParent,
        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {}
</code></pre>
<pre><code class="language-java">public interface ViewParent {}
</code></pre>
<h3 id="setview">setView</h3>
<pre><code class="language-java">/**
  * We have one child
  */
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    synchronized (this) {
        if (mView == null) {
            mView = view;
            // ...
            mAdded = true;
            int res; /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            // ...
            try {
                // ...
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, 
                                                  getHostVisibility(),
                                                  mDisplay.getDisplayId(),
                                                  mTmpFrame,
                                                  mAttachInfo.mContentInsets,
                                                  mAttachInfo.mStableInsets,
                                                  mAttachInfo.mOutsets,
                                                  mAttachInfo.mDisplayCutout, mInputChannel,  mTempInsets);
                setFrame(mTmpFrame);
            } catch (RemoteException e) {
                // ...
                throw new RuntimeException(&quot;Adding window failed&quot;, e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            // ...
            view.assignParent(this);
            // ...
        }
    }
}
</code></pre>
<h3 id="requestlayout">requestLayout</h3>
<pre><code class="language-java">@Override
public void requestLayout() {
    if (!mHandlingLayoutInLayoutRequest) {
        checkThread();
        mLayoutRequested = true;
        scheduleTraversals();
    }
}
</code></pre>
<h3 id="scheduletraversals">scheduleTraversals</h3>
<pre><code class="language-java">void scheduleTraversals() {
    if (!mTraversalScheduled) {
        mTraversalScheduled = true;
        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
        // 利用handle回调了 mTraversalRunnable
        mChoreographer.postCallback(
            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
        if (!mUnbufferedInputDispatch) {
            scheduleConsumeBatchedInput();
        }
        notifyRendererOfFramePending();
        pokeDrawLockIfNeeded();
    }
}
</code></pre>
<h3 id="mtraversalrunnable">mTraversalRunnable</h3>
<pre><code class="language-java">final TraversalRunnable mTraversalRunnable = new TraversalRunnable();
final class TraversalRunnable implements Runnable {
    @Override
    public void run() {
        doTraversal();
    }
}
</code></pre>
<h3 id="dotraversal">doTraversal</h3>
<pre><code class="language-java">void doTraversal() {
    if (mTraversalScheduled) {
        mTraversalScheduled = false;
        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);
        if (mProfile) {
            Debug.startMethodTracing(&quot;ViewAncestor&quot;);
        }
        performTraversals();
        if (mProfile) {
            Debug.stopMethodTracing();
            mProfile = false;
        }
    }
}
</code></pre>
<h3 id="performtraversals">performTraversals</h3>
<pre><code class="language-java">private void performTraversals() {
    // ...
    if (mFirst || windowShouldResize || insetsChanged ||
        viewVisibilityChanged || params != null || mForceNextWindowRelayout) {
        mForceNextWindowRelayout = false;
        // ...
        if (!mStopped || mReportNextDraw) {
            boolean focusChangedDueToTouchMode = ensureTouchModeLocally(
                (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
            if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()  || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||
                updatedConfiguration) {
                int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
                int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
                // ...
                // Ask host how big it wants to be
                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Implementation of weights from WindowManager.LayoutParams
                // We just grow the dimensions as needed and re-measure if
                // needs be
                int width = host.getMeasuredWidth();
                int height = host.getMeasuredHeight();
                boolean measureAgain = false;
                if (lp.horizontalWeight &gt; 0.0f) {
                    width += (int) ((mWidth - width) * lp.horizontalWeight);
                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,
                    MeasureSpec.EXACTLY);
                    measureAgain = true;
                }
                if (lp.verticalWeight &gt; 0.0f) {
                    height += (int) ((mHeight - height) * lp.verticalWeight);
                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
                    measureAgain = true;
                }
                if (measureAgain) {
                    // 进行UI布局的测量
                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                }
                layoutRequested = true;
            }
        }
    }
    // ...
    final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);
    boolean triggerGlobalLayoutListener = didLayout
        || mAttachInfo.mRecomputeGlobalAttributes;
    if (didLayout) {
        // 进行UI控件的摆放
        performLayout(lp, mWidth, mHeight);
        // ...
    }
    // Remember if we must report the next draw.
    if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
        reportNextDraw();
    }
    boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
    if (!cancelDraw) {
        if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) {
            for (int i = 0; i &lt; mPendingTransitions.size(); ++i) {
                mPendingTransitions.get(i).startChangingAnimations();
            }
            mPendingTransitions.clear();
        }
        // 进行图形的绘画
        performDraw();
    } else {
        if (isViewVisible) {
            // Try again
            scheduleTraversals();
        } else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) {
            for (int i = 0; i &lt; mPendingTransitions.size(); ++i) {
                mPendingTransitions.get(i).endChangingAnimations();
            }
            mPendingTransitions.clear();
        }
    }
    mIsInTraversal = false;
}
</code></pre>
<p>在<code>performTravals()</code>中主要调用了<code>performMeasure()</code>、<code>performLayout()</code>和<code>performDraw()</code>来进行UI的测量、布局和绘制。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI整体绘制流程]]></title>
        <id>https://jxiaow.gitee.io/posts/69abe299/</id>
        <link href="https://jxiaow.gitee.io/posts/69abe299/">
        </link>
        <updated>2020-12-08T08:01:23.000Z</updated>
        <summary type="html"><![CDATA[<p>在阅读本篇文章时，我们需要考虑以下几点：</p>
<ol>
<li>Android程序是如何启动的，Activity生命周期是如何被调用的？</li>
<li>在Activity的<code>onCreate()</code>方法中<code>setContentView()</code> 是如何加载UI文件的？</li>
<li>UI是如何绘制的？</li>
</ol>
<blockquote>
<p>源码分析基于API 29</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p>在阅读本篇文章时，我们需要考虑以下几点：</p>
<ol>
<li>Android程序是如何启动的，Activity生命周期是如何被调用的？</li>
<li>在Activity的<code>onCreate()</code>方法中<code>setContentView()</code> 是如何加载UI文件的？</li>
<li>UI是如何绘制的？</li>
</ol>
<blockquote>
<p>源码分析基于API 29</p>
</blockquote>
<!--more-->
<h1 id="android-程序简单的启动流程">Android 程序简单的启动流程</h1>
<p>在刚接触<code>Java</code>时，我们知道Java程序的运行入口是<code>main()</code>方法，然而我们在日常App的开发中并没有发现<code>main()</code> 方法的存在，那么<code>Android</code> 中的程序是如何开始运行的呢？</p>
<p>查阅官方资料中我们会发现在<code>Android</code>的源码中有一个叫做<code>ActivityThread</code>的类，这个类就是<code>Android 中的主线程</code>，在ActivityThread中我们可以看到<code>main()</code> 方法的存在。</p>
<h2 id="activitythreadmain">ActivityThread#main()</h2>
<pre><code class="language-java">public static void main(String[] args) {
    //...
    Looper.prepareMainLooper();
    //...
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    // ...
    Looper.loop();
}
</code></pre>
<p>在<code>main()</code> 方法中实例化了<code>ActivityThread</code>类并调用了<code>attach()</code> 方法。</p>
<h2 id="activitythreadattach">ActivityThread#attach()</h2>
<pre><code class="language-java">@UnsupportedAppUsage
private void attach(boolean system, long startSeq) {
    sCurrentActivityThread = this;
    mSystemThread = system;
    if (!system) {
        // ...
        final IActivityManager mgr = ActivityManager.getService();
        try {
            mgr.attachApplication(mAppThread, startSeq);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
        // ...
    }
}
</code></pre>
<p>在<code>attach()</code> 方法中可以看到通过<code>ActivityManager.getService()</code> 获取到了<code>IActivityManager</code> ，然后调用了<code>IActivityManager.attachApplication()</code> 方法并将<code>ApplicationThread</code>实例传入。</p>
<p><strong>注意：</strong> <code>IActivityManager</code>是一个接口，它的的实现类类是<code>ActivityManagerService</code>。</p>
<h2 id="activitymanagergetservice">ActivityManager#getService()</h2>
<pre><code class="language-java">@UnsupportedAppUsage
public static IActivityManager getService() {
    return IActivityManagerSingleton.get();
}
</code></pre>
<pre><code class="language-java">@UnsupportedAppUsage
private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =
    new Singleton&lt;IActivityManager&gt;() {
    @Override
    protected IActivityManager create() {
        final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
        final IActivityManager am = IActivityManager.Stub.asInterface(b);
        return am;
    }
};
</code></pre>
<p>通过上述两段代码可知，<code>ActivityManager.getService()</code> 是通过<code>Binder</code>机制获取了系统服务<code>ActivityManagerService</code>。</p>
<h2 id="activitymanagerserviceattachapplication">ActivityManagerService#attachApplication()</h2>
<p>在<code>ActivityThread#attach()</code>中调用了<code>attachApplication()</code>方法。</p>
<pre><code class="language-java">@Override
public final void attachApplication(IApplicationThread thread, long startSeq) {
    synchronized (this) {
        // ...
        attachApplicationLocked(thread, callingPid, callingUid, startSeq);
        // ...
    }
}
</code></pre>
<pre><code class="language-java">private final boolean attachApplicationLocked(IApplicationThread thread,
           int pid, int callingUid, long startSeq) {
     //....
    thread.bindApplication(processName, appInfo, providers,
                        instr2.mClass,
                        profilerInfo, instr2.mArguments,
                        instr2.mWatcher,
                        instr2.mUiAutomationConnection, testMode,
                        mBinderTransactionTrackingEnabled, enableTrackAllocation,
                        isRestrictedBackupMode || !normalMode, app.isPersistent(),
                        new Configuration(app.getWindowProcessController().getConfiguration()),
                        app.compat, getCommonServicesLocked(app.isolated),
                        mCoreSettingsObserver.getCoreSettingsLocked(),
                        buildSerial, autofillOptions, contentCaptureOptions);
    //...
}
</code></pre>
<p><code>attachApplication</code> 的作用实际上是将<code>ActivityThread</code> 与<code>ApplicationThread</code>关联，<code>ApplicationThread</code>类为<code>Activity</code>的各种生命周期状态做了相对应的代理工作并进行 <code>Application</code>的初始化工作。</p>
<h2 id="applicationthread">ApplicationThread</h2>
<pre><code class="language-java">private class ApplicationThread extends IApplicationThread.Stub {}
</code></pre>
<p><code>ApplicationThread</code>的方法分析就不在此处赘述了，后面的<code>Activity的启动流程</code>会详细分析。</p>
<h1 id="activity-视图设置">Activity 视图设置</h1>
<p>在 <code>onCreate()</code>当中我们往往会使用<code>setContentView()</code> 去进行我们自己的布局文件或者view, 我们可以通过源码分析看看具体的流程。</p>
<h2 id="activitysetcontentview">Activity#setContentView()</h2>
<pre><code class="language-java">// Activity.java
public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}
</code></pre>
<p><code>Activity</code> 中的<code>setContentView()</code> 通过<code>getWindow()</code> 调用了<code>setContentView()</code> ，而 <code>getWindow()</code> 返回的是<code>PhoneWindow</code>。</p>
<h2 id="phonewindowsetcontentview">PhoneWindow#setContentView()</h2>
<pre><code class="language-java">// PhoneWindow.java
@Override
public void setContentView(int layoutResID) {
    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
    // decor, when theme attributes and the like are crystalized. Do not check the feature
    // before  this happens.
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        final Scene newScene
            = Scene.getSceneForLayout(mContentParent, layoutResID, getContext());
        transitionTo(newScene);
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    mContentParent.requestApplyInsets();
    // ...
}
</code></pre>
<p>在<code>PhoneWindow#setCcontentView()</code>中做了两件事（<code>installDecor和 inflate</code>）。</p>
<h2 id="phonewindowinstalldecor">PhoneWindow#installDecor()</h2>
<p><code>installDecor</code>中主要是创建了<code>Decor</code>（顶层视图）和<code>contentParent</code>视图（我们写的布局的父视图）。</p>
<pre><code class="language-java">private void installDecor() {
    mForceDecorInstall = false;
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
        mDecor.setIsRootNamespace(true);
        if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) {
            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
        }
    } else {
        mDecor.setWindow(this);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
        // ...
    }
    // ...
}
</code></pre>
<h2 id="phonewindowgeneratedecor">PhoneWindow#generateDecor()</h2>
<p>在<code>Window</code>中创建顶级的view。</p>
<pre><code class="language-java">protected DecorView generateDecor(int featureId) {
    // ...
    return new DecorView(context, featureId, this, getAttributes());
}
</code></pre>
<h2 id="phonewindowgeneratelayout">PhoneWindow#generateLayout()</h2>
<p>根据App设置的不同主题获取不同的系统父布局文件，进行布局初始化并查找<code>id</code> 为 <code>com.android.internal.R.id.content</code> 中的<code>contentParent</code>。</p>
<pre><code class="language-java">protected ViewGroup generateLayout(DecorView decor) {
    // Apply data from current theme.
    // 根据配置的不同主题，选择系统父布局文件
    layoutResource = R.layout.screen_simple;
    mDecor.startChanging();
    // 加载布局文件
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);

    // ...
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    // ...
    return contentParent;
}
</code></pre>
<h2 id="decorviewonresourcesloaded">DecorView#onResourcesLoaded()</h2>
<p><code>onResourcesLoaded</code> 加载系统父布局文件，并将其添加到<code>DecorView</code>中。</p>
<pre><code class="language-java">void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {
    //...
    final View root = inflater.inflate(layoutResource, null);
    // ...
    // Put it below the color views.
    addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    // ...
}
</code></pre>
<h2 id="rlayoutscreen_simplexml">R.layout.screen_simple.xml</h2>
<pre><code class="language-xml">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:orientation=&quot;vertical&quot;&gt;
    &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;
              android:inflatedId=&quot;@+id/action_mode_bar&quot;
              android:layout=&quot;@layout/action_mode_bar&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;wrap_content&quot;
              android:theme=&quot;?attr/actionBarTheme&quot; /&gt;
    &lt;FrameLayout
         android:id=&quot;@android:id/content&quot;
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;
         android:foregroundInsidePadding=&quot;false&quot;
         android:foregroundGravity=&quot;fill_horizontal|top&quot;
         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<h2 id="activity的窗口ui布局层级">Activity的窗口UI布局层级</h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/Activity-Activity%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84%E5%AE%B9%E5%99%A8.svg" alt="Activity-Activity视图结构容器" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android通过Intent简单实现分享功能]]></title>
        <id>https://jxiaow.gitee.io/posts/73a6d0c4/</id>
        <link href="https://jxiaow.gitee.io/posts/73a6d0c4/">
        </link>
        <updated>2020-12-04T16:03:24.000Z</updated>
        <summary type="html"><![CDATA[<p>现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过<code>Intent</code>方式打开在系统中安装的具有分享功能的App的分享页面。</p>
]]></summary>
        <content type="html"><![CDATA[<p>现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过<code>Intent</code>方式打开在系统中安装的具有分享功能的App的分享页面。</p>
<!-- more -->
<p>方法如下：</p>
<pre><code class="language-java">public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_SEND);
    intnet.setType(&quot;text/plain&quot;);
    PackageManager packageManager = context.getPackageManager();
    List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0);
    return resloveInfos;
}
</code></pre>
<p>如果只需要QQ和微信分享，可以进行如下操作：</p>
<pre><code class="language-java">public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_SEND);
    intnet.setType(&quot;text/plain&quot;);
    PackageManager packageManager = context.getPackageManager();
    List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0);
    List&lt;ResolveInfo&gt; shareItems = new ArrayList();    
    for(ResolveInfo info: resolveInfos) {
        String name = info.activityInfo.packageName;
        if (TextUtils.equals(packageName, &quot;com.tencent.mm&quot;)
                    || TextUtils.equals(packageName, &quot;com.tencent.mobileqq&quot;)) {
                shareItems.add(resolveInfo);
        }
    }
    return shareItems;
}
</code></pre>
<p>通过<code>ResolveInfo</code>获取图标<code>ICON</code>和<code>Label</code>:</p>
<pre><code class="language-java">Drawable drawable = resloveInfo.loadIcon(packageManager);
CharSequence label = resolveInfo.loadLabel(packageManager);
</code></pre>
<p>通过<code>Intent</code>发起分享：</p>
<pre><code class="language-java">public static void share(Context context, 
            ResolveInfo info, String shareContent){
    Intent itnent = new Intent();
    intnet.setAction(Intent.ACTION_SEND);
    String pkg = resolveInfo.activityInfo.packageName;
    String cls = resolveInfo.activityInfo.name;
    intent.setComponent(new Component(pkg, cls));
    intent.putExtra(Intent.EXTRA_TEXT, shareContent);
    context.startActivity(intent);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora + PicGo-Core + Github 实现图片上传到Github]]></title>
        <id>https://jxiaow.gitee.io/posts/cde2810e/</id>
        <link href="https://jxiaow.gitee.io/posts/cde2810e/">
        </link>
        <updated>2020-11-07T08:10:37.000Z</updated>
        <summary type="html"><![CDATA[<p>为了解决<code>为知笔记</code>使用<code>Typora</code>编辑<code>markdown</code>文件图片丢失的问题，我采用了<code>PicGo-Core +Github</code>实现了自定图床的功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>为了解决<code>为知笔记</code>使用<code>Typora</code>编辑<code>markdown</code>文件图片丢失的问题，我采用了<code>PicGo-Core +Github</code>实现了自定图床的功能。</p>
<!--more-->
<h2 id="下载picgo-core">下载PicGo-Core</h2>
<p>由于我的电脑有<code>nodejs</code>环境，所以我使用的是<code>npm</code>命令安装<code>picgo</code>, 命令如下：</p>
<pre><code class="language-shell">npm install picgo -g
</code></pre>
<p>安装完成后，检查命令行输出, 记录下红色框内的路径。<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105201730919.png" alt="image-20201105201730919" loading="lazy"></p>
<p>输入命令查看版本，如果有输出则添加成功。</p>
<pre><code class="language-shell">picgo -v
</code></pre>
<h2 id="安装github-plus">安装github-plus</h2>
<p>官方提供的github上传图库不好用，安装一款新的上传插件<code>github-plus</code>, 命令行执行：</p>
<pre><code class="language-shell">picgo install github-plus
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105223054898.png" alt="image-20201105223054898" loading="lazy"></figure>
<p>安装成功后会有提示。</p>
<h2 id="typora图像设置">Typora图像设置</h2>
<p>在<code>Typora</code>中配置图像上传信息。</p>
<h3 id="设置picgo的配置信息">设置PicGo的配置信息</h3>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105223720354.png" alt="" loading="lazy"></figure>
<p>如上图所示，分为2个步骤：</p>
<ol>
<li><strong>上传服务</strong>选择<code>PicGo-Core(command line)</code></li>
<li>打开配置文件，在打开的配置文件，添加相关信息。</li>
</ol>
<pre><code class="language-json">{
 &quot;picBed&quot;: {
   &quot;uploader&quot;: &quot;githubPlus&quot;,
   &quot;current&quot;: &quot;githubPlus&quot;,
   &quot;githubPlus&quot;: {
     &quot;branch&quot;: &quot;master&quot;,// 仓库分支
     &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest&quot;, // 访问的自定义url
     &quot;origin&quot;: &quot;github&quot;, // 存放的图片类型
     &quot;repo&quot;: &quot;jxiaow/cdn-images&quot;, // 存放图片的仓库
     &quot;path&quot;: &quot;blog-images&quot;,// 存放图片的仓库目录下的文件夹
     &quot;token&quot;: &quot;&quot; // 访问github的仓库的token, 不知道怎么设置的自行百度
   }
 },
 &quot;picgoPlugins&quot;: {
   &quot;picgo-plugin-github-plus&quot;: true // 启用github-plus插件
 },
 &quot;picgo-plugin-github-plus&quot;: {
   &quot;lastSync&quot;: &quot;2020-11-05 07:54:47&quot;
 }
}
</code></pre>
<h3 id="测试配置">测试配置</h3>
<p>根据上述配置完毕后我们需要进行测试链接是否成功，在测试之前还要进行如图所示的修改：<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105224420441.png" alt="image-20201105224420441" loading="lazy"></p>
<ol>
<li><strong>上传服务</strong>修改为<code>Custom Command</code></li>
<li>自定义命令 ： <code>picgo upload</code></li>
<li>点击验证图片上传选项</li>
<li>如果显示验证成功，则表示配置完成。<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105225415181.png" alt="image-20201105225415181" loading="lazy"></li>
</ol>
<h2 id="图片上传">图片上传</h2>
<p>将图片拖入Typora中，然后在图片单击右键，图片上传即可。</p>
<h2 id="安装文件重命名插件-picgo-plugin-rename-file">安装文件重命名插件 <a href="https://github.com/liuwave/picgo-plugin-rename-file">picgo-plugin-rename-file</a></h2>
<p><code>picgo-plugin-rename-file</code> 插件可以帮我们安装一定的规则将文件进行重命名，具体设置请看github。</p>
<p>输入一下命令安装:</p>
<pre><code class="language-shell">picgo install rename-file
</code></pre>
<p>安装完成后，打开<code>picgo</code>的配置文件<code>C:\Users\xxx\.picgo\config.json</code>末尾最后一个大括号前添加一下信息即可。</p>
<pre><code class="language-json">,
&quot;picgo-plugin-rename-file&quot;: {
    &quot;format&quot;: &quot;{y}/{m}/{d}/{hash}-{origin}-{rand:6}&quot;
}
</code></pre>
<h2 id="添加水印">添加水印</h2>
<p><em><strong>注意：此插件目前会导致文件上传重命名插件不生效</strong></em><br>
插件地址: <a href="https://github.com/Dec-F/picgo-plugin-watermark">picgo-plugin-watermark</a> ，<code>watermark</code>插件可以帮我们在上传图片的时候添加水印。</p>
<p>安装命令：</p>
<pre><code class="language-shell">picgo install watermark
</code></pre>
<p>安装成功后，<code>C:\Users\xxx\.picgo\config.json</code>末尾最后一个大括号前添加一下信息即可。</p>
<pre><code class="language-json">,
&quot;picgo-plugin-watermark&quot;: { // 以下配置信息参考插件地址说明
    &quot;text&quot;: &quot;jxiaow&quot;, // 水印名称
    &quot;fontSize&quot;: 18, // 水印字体大小
    &quot;position&quot;:&quot;rm&quot; // 水印位置
},
</code></pre>
<p><strong>注意：</strong> 由于这个插件安装过程中需要下载字体，会导致下载特别慢，尽可能使用代理。</p>
<p><strong>website:</strong> <a href="https://xiaowujiang.cn">xiaowujiang.cn</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[360加固Gradle插件实现]]></title>
        <id>https://jxiaow.gitee.io/posts/6c01e784/</id>
        <link href="https://jxiaow.gitee.io/posts/6c01e784/">
        </link>
        <updated>2020-09-07T16:14:31.000Z</updated>
        <content type="html"><![CDATA[<p>最近码了一个基于360加固的流程实现的Gradle插件，在自动编译打包后进行360加固流程操作。只需要配置一些参数后，就可以实现自动打包编译和加固。</p>
<p>项目地址:https://github.com/jxiaow/android-gradle-plugin</p>
<h3 id="使用步骤">使用步骤</h3>
<h4 id="1-添加依赖">1. 添加依赖</h4>
<ul>
<li>在根<code>build.gradle</code>中添加：</li>
</ul>
<pre><code class="language-groovy">allprojects {
    repositories {
        maven { url &quot;https://jitpack.io&quot; }
    }
}

dependencies {
    ...
    classpath 'com.github.jxiaow:android-gradle-plugin:$version'
}
</code></pre>
<p>(请替换 <code>$version</code>为最新的版本号:<a href="https://jitpack.io/#jxiaow/android-gradle-plugin"><img src="https://jitpack.io/v/jxiaow/android-gradle-plugin.svg" alt="" loading="lazy"></a>)</p>
<ul>
<li>在<code>app</code>的模块<code>build.gradle</code>中添加：</li>
</ul>
<pre><code class="language-groovy">apply plugin: 'com.github.jxiaow.jiagu'
</code></pre>
<h4 id="2-参数配置">2. 参数配置</h4>
<p>使用这款插件需要在<code>app</code>的<code>build.gradle</code>中添加一些配置信息，如下：</p>
<pre><code class="language-groovy">jiagu {
    home '../360jiagu' // 360加固软件的根目录
    buildTypes 'release', 'debug' // 需要加固的编译类型
    configs '-crashlog' // 选择360的可选配置服务
    username 'user' // 360加固用户名
    password 'password' // 360加固密码
    charsetName 'GBK' // 360加固控制台输出字符编码
    // apk签名文件， 如果在Android中配置了签名文件，此项可以不用配置，插件会自动读取名为'release'的签名文件
    signingConfig { 
        key_alias         : KEY_ALIAS, 
        key_password      : KEY_PASSWORD,
        key_store_password: KEY_STORE_PASSWORD,
        key_store_file    : KEY_STORE_FILE
    }
}
</code></pre>
<h4 id="3-开始加固">3. 开始加固</h4>
<p>确认上述参数无误后，就可以在控制台中切换到当前项目根目录执行</p>
<pre><code class="language-shell"># 各个系统的控制台gradle命令可能不一样： ./gradlew 或 gradlew 
./gradlew clean jiaGuApk 
</code></pre>
<h3 id="文档">文档</h3>
<p><a href="https://jxiaow.github.io/android-gradle-plugin/plugin/com.github.jxiaow.jiagu/index.html">android-gradle-plugin</a></p>
<h3 id="360加固助手">360加固助手</h3>
<p><a href="https://jiagu.360.cn/#/global/download">360加固助手</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Http框架封装]]></title>
        <id>https://jxiaow.gitee.io/posts/84a009ed/</id>
        <link href="https://jxiaow.gitee.io/posts/84a009ed/">
        </link>
        <updated>2020-04-26T02:03:07.000Z</updated>
        <summary type="html"><![CDATA[<p>用过了现有的一些<code>http</code>请求框架，决定自己也来简单的封装一个。本文只是基于一些http请求框架二次封装的，高手勿喷。<a href="https://github.com/ixiaow/ppjoke/tree/master/network/src/main/java/com/mooc/network">源码</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>用过了现有的一些<code>http</code>请求框架，决定自己也来简单的封装一个。本文只是基于一些http请求框架二次封装的，高手勿喷。<a href="https://github.com/ixiaow/ppjoke/tree/master/network/src/main/java/com/mooc/network">源码</a></p>
<!-- more -->
<h2 id="http的请求和响应">http的请求和响应</h2>
<p>一个http的请求通常包含请求头、请求体、响应头和响应体，考虑到这些因素，<code>HttpConfig</code>和 <code>ApiResponse</code>就诞生了: <a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/HttpConfig.java">HttpConfig</a></p>
<h3 id="httpconfig">HttpConfig</h3>
<p>http参数配置类，应该包含如下属性:</p>
<ul>
<li>baseUrl/url</li>
</ul>
<p>如果使用restful形式，baseUrl是不能为空并且url为业务path, 如果是非restful,url必须为请求全路径</p>
<ul>
<li>GET/POST</li>
</ul>
<p>有了url，接下来需要有请求的方法类型，由于我这边只用到了<code>GET</code>和<code>POST</code>,所以只对此做了封装。</p>
<p><strong>特别说明：</strong> POST 有三种提交方式（form表单、json形式和 复杂形式）</p>
<pre><code class="language-java">FORM_DATA(&quot;application/x-www-form-urlencoded;charset=utf-8&quot;),
JSON_DATA(&quot;application/json;charset=utf-8&quot;),
MULTI_PART_DATA(&quot;multipart/form-data;charset=utf-8&quot;);
</code></pre>
<ul>
<li>headers</li>
</ul>
<p>http的请求头封装，采用<code>(Map&lt;String,String&gt;)</code>集合</p>
<ul>
<li>params</li>
</ul>
<p>http的请求参数，采用<code>(Map&lt;String,Object&gt;)</code>如果请求方法是<code>GET</code>形式，那么采用拼接字符串的形式将参数拼接到url中; 如果请求方法是<code>POST</code>形式，则需要根据提交参数的方式不同，会有不同的请求体。</p>
<ul>
<li>cacheStrategy</li>
</ul>
<p>考虑到App的使用交互和服务器减压，我们要考虑有一些请求可以做一些缓存，那么常用的缓存策略有<code>CACHE_ONLY</code>、<code>CACHE_FIRST</code>、<code>NET_ONLY</code>和<code>NET_CACHE</code></p>
<ul>
<li>type</li>
</ul>
<p>type是响应数据的type,这个主要用在Http请求结果返回后将json转为bean对象的映射类型，需要考虑泛型和非泛型（Class和ParamizableType）</p>
<ul>
<li>tag</li>
</ul>
<p>给每一个请求链接打一个标签，可用于一些其它的操作，如根据tag取消请求</p>
<ul>
<li>isAsync</li>
</ul>
<p>当前请求是同步执行还是异步执行的标志，异步执行会在子线程中进行http请求，同步执行在当前线程中执行http请求。</p>
<h4 id="apiresponset">ApiResponse<T></h4>
<p>使用<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/ApiResponse.java">ApiResponse</a>的原因是为了规范请求结果返回的表现形式，他有一个<code>T</code>类型的数据。</p>
<ul>
<li>code</li>
</ul>
<p>状态码,与http请求响应状态码一致，200~300 请求成功，304 使用缓存</p>
<ul>
<li>message</li>
</ul>
<p>请求响应的错误信息</p>
<ul>
<li>data</li>
</ul>
<p>响应的数据，泛型T, 根据<code>httpConfig</code>中的type,映射 json--&gt; bean</p>
<h2 id="http引擎">Http引擎</h2>
<p><a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/IHttpEngine.java">IHttpEngine</a>是一个接口，使用者可以根据实际的情况做具体的实现。</p>
<pre><code class="language-java">public interface IHttpEngine {

    // 开始执行 http请求
    &lt;T&gt; execute(HttpConfig config, MultableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData);
    // 根据tag取消
    void cancel(Object tag);
}
</code></pre>
<p>由于http请求有同步和异步两种情况并且又牵扯到了缓存策略问题（如果先进行缓存返回在执行网络请求并返回数据），在异步回调的情况下这些问题可以通过回调解决，但是在同步情况下，这些问题并不能很好的处理，曾经有使用过将当前请求<code>clone</code>,然后再次调用请求服务器的方法，但是在使用过<code>jetpack</code>的<code>LiveData</code>框架后这些问题都可以解决了。</p>
<h2 id="okhttpengine">OkhttpEngine</h2>
<p>Android开发目前来说大多数项目使用的都是<code>Okhttp</code>来做请求，本次我使用的默认引擎也是使用它来作为默认的实现。<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/okhttp/OkHttpEngine.java">OkHttpEngine</a></p>
<h3 id="okhttp简单配置">okhttp简单配置</h3>
<p>对okhttp进行一些简单的配置就可以进行网络请求了，如下：</p>
<ul>
<li>创建okHttpClient</li>
</ul>
<pre><code class="language-java"> private static final OkHttpClient OK_HTTP_CLIENT;

 // 添加日志拦截器
 HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
 loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);

 OK_HTTP_CLIENT = new OkHttpClient.Builder()
               .connectTimeout(15, TimeUnit.SECONDS)
               .readTimeout(15, TimeUnit.SECONDS)
               .writeTimeout(15, TimeUnit.SECONDS)
               .addInterceptor(loggingInterceptor)
               .build();
</code></pre>
<ul>
<li>添加证书管理</li>
</ul>
<pre><code class="language-java">TrustManager[] trustManagers = new TrustManager[]{
    new X509TrustManager() {
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }
     }
};

SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;);
sslContext.init(null, trustManagers, new SecureRandom());
HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -&gt; true);
</code></pre>
<h3 id="实现http请求">实现Http请求</h3>
<p>IHttpEngine中的<code>execute</code>方法是具体的http请求方法，所有实现<code>IHttpEngine</code>的方法都需要实现此方法。</p>
<pre><code class="language-java">@NonNull
@Override
public &lt;T&gt; void execute(@NonNull Config config, 
                        @NonNull MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
    Request request = generateRequest(config);
    Call call = OK_HTTP_CLIENT.newCall(request);
    if (!config.isAsync) {
        execute(call, config, liveData);
    } else {
        enqueue(call, config, liveData);
    }
}
</code></pre>
<p><code>execute</code>方法中大致需要做以下事：</p>
<ul>
<li>创建request--&gt; genearteRequest</li>
<li>发送http请求 ---&gt; execute/enqueue</li>
</ul>
<h4 id="创建httprequest">创建httpRequest</h4>
<p><code>generateRequest()</code>根据<code>HttpConfig</code>中的请求方式来创建不同的http请求。</p>
<pre><code class="language-java">/**
 * 根据配置信息生成request
 *
 * @param config 配置信息
 * @return request
 */
 @NonNull
 private Request generateRequest(@NonNull Config config) {
    switch (config.method) {
       case Config.GET:
           return generateGetRequest(config);
       case Config.POST:
           return generatePostRequest(config);

       default:
           throw new IllegalStateException(&quot;this request method invalidate: &quot; + config.method);
    }
}
</code></pre>
<h5 id="get请求的创建方式">GET请求的创建方式</h5>
<p><code>genearteGetReques()</code>方法，利用okhttp的Request类创建request实例，并利用<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/UrlCreator.java">UrlCreator</a>将参数拼接到url中。Url拼接时需要注意使用<code>UrlEncoder</code>编码，不然可能会造成服务器和客户端解析数据不一致的情况。</p>
<pre><code class="language-java">/**
 * 生成get方式的请求
 *
 * @param config 请求配置
 * @return 返回get方式的request
 */
@NonNull
private Request generateGetRequest(@NonNull Config config) {
   Request.Builder builder = new Request.Builder().get();
   builder.tag(config.tag);
   addHeader(builder, config);
   String url = UrlCreator.generateUrlForParams(config.url(), config.getParams());
   return builder.url(url).build();
}
</code></pre>
<h5 id="post请求的创建方式">POST请求的创建方式</h5>
<p>POST请求方式提交内容时相对于GET方式要复杂许多，他需要根据提交方式的不同添加不同的<code>header</code>和内容<code>body</code>, 在<code>generatePostRequest()</code>方法中先利用okhttp的request类创建request实例，根据调用者在<code>HttpConfig</code>中设置<code>formData</code>来创建不同形式的<code>body</code>。</p>
<pre><code class="language-java">/**
 * 生成post请求
 *
 * @param config http请求配置信息
 * @return 请求request
 */
@NonNull
private Request generatePostRequest(@NonNull Config config) {
   Request.Builder builder = new Request.Builder().url(config.url());
   builder.tag(config.tag);
   addHeader(builder, config);

   // 根据提交方式添加header信息
   Pair&lt;String, String&gt; header = config.formData.getHeader();
   builder.addHeader(header.first, header.second);

   // 创建body
   RequestBody body = generatePostRequestBody(config);
   return builder.post(body).build();
}
</code></pre>
<p>判断<code>formData</code>类型，创建不同的<code>request body</code>。</p>
<pre><code class="language-java">/**
 * 获取post提交体
 *
 * @param config 请求配置信息
 * @return RequestBody
 */
@NonNull
private RequestBody generatePostRequestBody(@NonNull Config config) {
   FormData formData = config.formData;
   switch (formData) {
       case FORM_DATA:
           return getFormDataRequestBody(config);
       case JSON_DATA:
           return getJsonDataRequestBody(config);
       case MULTI_PART_DATA:
           return getMultiDataRequestBody(config);
       default:
           throw new IllegalArgumentException(&quot;post formData is invalidate: &quot; + formData);
   }
}
</code></pre>
<h6 id="创建formdata表单">创建FormData(表单)</h6>
<p>form表单形式比较简单，只需要创建一个okhttp的FormBody并将param添加，需要注意的是添加param时调用的是<code>addEncoded</code>方法。</p>
<pre><code class="language-java">/**
 * 生成form data形式的post数据
 *
 * @param config 请求配置
 * @return FromBody
 */
 @NonNull
 private RequestBody getFormDataRequestBody(@NonNull Config config) {
     FormBody.Builder builder = new FormBody.Builder(StandardCharsets.UTF_8);
     Map&lt;String, Object&gt; params = config.getParams();
     for (Map.Entry&lt;String, Object&gt; entry : params.entrySet()) {
          builder.addEncoded(entry.getKey(), String.valueOf(entry.getValue()));
     }
     return builder.build();
 }
</code></pre>
<h6 id="json形式">json形式</h6>
<p>利用okHttp中的<code>RequestBody.create()</code>方法创建一个json形式的body,需要传递json和json形式的header。</p>
<pre><code class="language-java">/**
 * 生成json形式的post数据
 *
 * @param config 请求配置
 * @return RequestBody
 */
 @NonNull
 private RequestBody getJsonDataRequestBody(@NonNull Config config) {
   if (config.getParams().isEmpty()) {
        throw new IllegalArgumentException(&quot;json data is null&quot;);
   }
   Object json = config.getParams().get(Config.JSON_KEY);
   return RequestBody.create(String.valueOf(json), MediaType.parse(config.formData.getValue()));
 }
</code></pre>
<h6 id="复杂形式的body">复杂形式的body</h6>
<p>复杂形式的body，主要是用在文件上传这一块儿。它需要判断当前param是普通key-value、单文件和多文件。</p>
<p>利用okhttp的MultiparBody创建body对象并根据内容类型调用的不同的body,然后调用<code>addFormDataPart</code>添加到MultipartBody中。</p>
<pre><code class="language-java">/**
 * 获取复杂的post提交体
 *
 * @param config 请求配置信息
 * @return MultipartBody
 */
@NonNull
@SuppressWarnings(&quot;unchecked&quot;)
private RequestBody getMultiDataRequestBody(@NonNull Config config) {

    MultipartBody.Builder builder = new MultipartBody.Builder();
    builder.setType(MultipartBody.FORM);

    for (Map.Entry&lt;String, Object&gt; entry : config.getParams().entrySet()) {
        String key = entry.getKey();
        Object value = entry.getValue();

        if (value instanceof File) {
            File file = (File) value;
            RequestBody requestBody = MultipartBody.create(file, getFileMediaType(file));
            builder.addFormDataPart(key, file.getName(), requestBody);
        } else if (value instanceof List) {
            List&lt;File&gt; files = (List&lt;File&gt;) value;
            for (int i = 0; i &lt; files.size(); i++) {
                File file = files.get(i);
                RequestBody requestBody = MultipartBody.create(file, getFileMediaType(file));
                builder.addFormDataPart(key + i, file.getName(), requestBody);
            }
        } else {
            builder.addFormDataPart(key, String.valueOf(value));
        }
    }
    return builder.build();
}
</code></pre>
<p>添加文件时需要有文件的类型，文件类型的获取方式是通过<code>UrlConnection</code>的getFileNameMap方法获取。</p>
<pre><code class="language-java">/**
 * 获取文件的type类型
 *
 * @param file 文件
 * @return MediaType
 */
@Nullable
private MediaType getFileMediaType(@NonNull File file) {
    FileNameMap fileNameMap = URLConnection.getFileNameMap();
    String contentTypeFor = fileNameMap.getContentTypeFor(file.getAbsolutePath());
    if (contentTypeFor == null) {
        contentTypeFor = &quot;application/octet-stream&quot;;
    }
    return MediaType.parse(contentTypeFor);
</code></pre>
<p>通过以上的几种方式就可以创建一个http请求了，接下来需要发送请求了，发送请求需要通过httpConfig中的<code>isAsync</code>来判断是开启一个子线程还是在当前线程中执行操作（同步与异步）。</p>
<h4 id="发送http请求">发送http请求</h4>
<p>发送http请求会有同步请求(execute)和异步请求(enqueue), 同步请求是在当前线程中发送http请求，异步请求采用okhttp线程池发送请求。处理请求时在合适的地方需要判断该请求是否被取消。</p>
<pre><code class="language-java"> if (call.isCanceled()) {
    return;
 }
</code></pre>
<h5 id="同步请求execute">同步请求(execute)</h5>
<p>在发送http请求时会根据缓存策略进行响应的处理，而同步请求没有办法做到<code>return</code>后可以继续进行网络请求，所以引入了<code>LiveData</code>来发送数据。</p>
<p>目前缓存策略有四种，我们需要根据判断来进行不同的操作，关于缓存的创建和获取后续会有说明，这块儿只有根据缓存策略处理数据。</p>
<pre><code class="language-java">/**
 * 同步执行的方法
 */
@SuppressWarnings(&quot;unchecked&quot;)
private &lt;T&gt; void execute(Call call, Config config, MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
    ApiResponse&lt;T&gt; apiResponse;
    Logs.d(&quot;execute before cache: &quot; + Thread.currentThread().getName());
    // 只访问本地数据
    if (config.cacheStrategy == Config.CACHE_ONLY) {
        apiResponse = readCache(call.request().url().toString());
        liveData.postValue(apiResponse);
        return;
    }

    // 先访问本地数据，然后再发起网络请求
    if (config.cacheStrategy == Config.CACHE_FIRST) {
        apiResponse = readCache(call.request().url().toString());
        liveData.postValue(apiResponse);
    }

    Logs.d(&quot;execute current thread: &quot; + Thread.currentThread().getName());
    // ..... 此处开始进行http网络请求


    if (call.isCanceled()) {
        return;
    }
    // liveData发送数据
    liveData.postValue(apiResponse);
    if (config.cacheStrategy != Config.NET_ONLY) {
        saveCache(call.request().url().toString(), apiResponse);
    }
}
</code></pre>
<p>使用okhttp的<code>execute</code>方法发送http请求,并利用<code>ConvertFactory</code>进行数据解析，ConvertFactory后续会介绍。</p>
<pre><code class="language-java"> try {
      Response response = call.execute();
      IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
      apiResponse = convert.convert(response, config.type);
 } catch (IOException e) {
      e.printStackTrace();
      apiResponse = new ApiResponse&lt;&gt;();
      apiResponse.status = 500;
      apiResponse.message = e.getMessage();
 }
</code></pre>
<h5 id="异步请求enqueue">异步请求(enqueue)</h5>
<p>异步请求与同步请求一样也需要进行缓存策略进行缓存处理，这块儿的处理逻辑一致，所以下面的代码块将这部分省略。使用okhttp的<code>enqueue</code>方法发送http请求,在<code>onResponse</code>中并利用<code>ConvertFactory</code>进行数据的解析，在<code>onFailure</code>中自定义错误信息的返回。</p>
<pre><code class="language-java">private &lt;T&gt; void enqueue(Call call, Config config, MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
        //... 缓存策略判断数据处理返回
        ...
        // 开始请求服务器
        call.enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                if (call.isCanceled()) {
                    return;
                }
                ApiResponse&lt;T&gt; apiResponse = new ApiResponse&lt;&gt;();
                apiResponse.status = 500;
                apiResponse.message = e.getMessage();
                liveData.postValue(apiResponse);
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                if (call.isCanceled()) {
                    return;
                }
                IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
                ApiResponse&lt;T&gt; apiResponse = convert.convert(response, config.type);
                liveData.postValue(apiResponse);
                if (config.cacheStrategy != Config.NET_ONLY) {
                    saveCache(call.request().url().toString(), apiResponse);
                }
            }
        });
    }
</code></pre>
<h3 id="取消请求">取消请求</h3>
<p><code>cancle()</code>方法中，利用Okhttp来取消请求，主要是比对tag, 如下：</p>
<pre><code class="language-java">@Override
public void cancel(@NonNull Object tag) {
    if (OK_HTTP_CLIENT == null) {
        return;
    }

    //查找当前需要取消的tag是否在未执行的请求中
    for (Call call : OK_HTTP_CLIENT.dispatcher().queuedCalls()) {
        if (tag.equals(call.request().tag())) {
            call.cancel();
        }
    }

    //查找当前需要请求的tag是否在正在执行的请求中
    for (Call call : OK_HTTP_CLIENT.dispatcher().runningCalls()) {
        if (tag.equals(call.request().tag())) {
            call.cancel();
        }
    }
}
</code></pre>
<h2 id="响应数据转换">响应数据转换</h2>
<p>从服务器返回数据后，需要将数据格式进行转换成数据模型bean，由于数据返回的形式有多种，所以解析方式也会有多种，所以这块儿可以考虑使用数据解析工厂类去做数据解析，不同的解析数据做不同的逻辑实现，达到解偶。</p>
<p>定义一个<code>Convert</code>类，利用泛型的方式进行参数传递。</p>
<pre><code class="language-java">public interface IConvert&lt;T, R&gt; {
    // 数据的返回形式必须是ApiResponse, type即为泛型T的类型
    @NonNull
    ApiResponse&lt;R&gt; convert(@NonNull T t, @NonNull Type type);
}
</code></pre>
<p>这边提供了一种简单的convert调用方式，后面可以要考虑进行扩展选择：</p>
<pre><code class="language-java"> IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
 apiResponse = convert.convert(response, config.type);
</code></pre>
<p><code>ConverFactory</code>为<code>IConvert</code>的实现类。</p>
<pre><code class="language-java">public class ConvertFactory&lt;R&gt; implements IConvert&lt;Response, R&gt; {
    private static ConvertFactory convertFactory;


    public static ConvertFactory create() {
        if (convertFactory == null) {
            convertFactory = new ConvertFactory();
        }
        return convertFactory;
    }

    ...........
}
</code></pre>
<h2 id="本地缓存">本地缓存</h2>
<p>数据缓存采用的是<code>Room</code>数据库进行数据的存储，room是jetpack中的一种组件。它的创建方式也很简单。</p>
<h3 id="创建数据库表">创建数据库表</h3>
<pre><code class="language-java">// Entity 表示该对象是一张数据库表
@Entity(tableName = &quot;cache&quot;)
public class Cache {
    // primarykey表示表的主键
    @PrimaryKey
    @NonNull
    public String key;
    // ColumnInfo表示该字段在表中显示的字段名
    @ColumnInfo(name = &quot;_data&quot;)
    public byte[] data;
}
</code></pre>
<h3 id="创建数据库">创建数据库</h3>
<pre><code class="language-java">// entities 表示 需要在该数据库中创建的表，可以创建多张
// version 数据库的版本号
// exportSchema 导出表创建的语句
@Database(entities = Cache.class, version = 1, exportSchema = true)
public abstract class CacheDatabase extends RoomDatabase {
    private static final CacheDatabase cacheDatabase;

    static {
        Application application = AppGlobals.getApplication();
        cacheDatabase = Room.databaseBuilder(application, CacheDatabase.class, &quot;net_cache.db&quot;)
                .allowMainThreadQueries()
                .build();
    }

    // 数据库与Dao关联
    public abstract CacheDao getCacheDao();

    public static CacheDatabase get() {
        return cacheDatabase;
    }
} 
</code></pre>
<h3 id="创建数据库表操作类dao">创建数据库表操作类Dao</h3>
<pre><code class="language-java">// Dao 用来表示当前类是数据库表的操作类
@Dao
public interface CacheDao {
    // Insert 表示增加一条记录到数据库表中
    // onConflict 表示如果添加数据时出现冲突的解决策略
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void save(@NonNull Cache cache);

    // Delete 表示删除一条记录
    @Delete
    int delete(@NonNull Cache cache);

    // Update 表示更新一条记录
    // onConflict 表示如果更新数据时出现冲突的解决策略
    @Update(onConflict = OnConflictStrategy.REPLACE)
    int update(@NonNull Cache cache);

    // Query 查找一条记录
    @Query(&quot;SELECT * FROM cache WHERE `key`=:key&quot;)
    Cache query(@NonNull String key);
}
</code></pre>
<h2 id="type类型">Type类型</h2>
<p>由于java中的泛型在编译完毕后会擦除该类型，所以我们无法在同步执行或者多级泛型嵌套的情况下拿到泛型的实际类型。目前的解决方式有两种。</p>
<h3 id="调用者传入实际类型">调用者传入实际类型</h3>
<p>提供可以传入实际类型的方法，调用处将明确类型传递。</p>
<h3 id="利用子类实现的方式获取实际类型">利用子类实现的方式获取实际类型</h3>
<p>Java代码在编译成字节码class文件时会保留子类的泛型信息。所以大部分的json数据解析都是采用的此方法，如：Gson中的TypeToken 以及fasjson中的TypeReference。</p>
<pre><code class="language-java">public abstract class TypeToken&lt;T&gt; {
    // 泛型T的实际类型
    protected Type type;

    public TypeToken() {
        Type superClass = getClass().getGenericSuperclass();
        // 获取泛型的实际类型
        Type oriType = ((ParameterizedType) superClass).getActualTypeArguments()[0];

        if (oriType instanceof Class) {
            type = oriType;
        } else {
            //修复在安卓环境中问题
            type = putCacheTypeIfAbsent(oriType);
        }
    }
}
</code></pre>
<p>由于本次封装的返回的数据类型是<code>ApiResponse&lt;T&gt;</code>所以需要对泛型进行二次解析，所以新建了一个ApiResponseToken。</p>
<pre><code class="language-java">public abstract class ApiResponseToken&lt;T&gt; extends TypeToken&lt;T&gt; {

    public ApiResponseToken() {
        Type superClass = getClass().getGenericSuperclass();

        Type oriType = ((ParameterizedType) superClass).getActualTypeArguments()[0];

        if (oriType instanceof Class) {
            type = oriType;
        } else {
            // 解决ApiResponse&lt;T&gt;这种情况
            if (oriType instanceof ParameterizedType) {
                oriType = ((ParameterizedType) oriType).getActualTypeArguments()[0];
            }
            type = putCacheTypeIfAbsent(oriType);
        }
    }
}
</code></pre>
<p>由于本次框架的数据返回使用了<code>LiveData&lt;T&gt;</code>的形式，并通过订阅的方式实现数据返回，所以又添加了一个类型，用于自行获取type。</p>
<pre><code class="language-java">public abstract class HttpObserver&lt;T&gt; extends ApiResponseToken&lt;T&gt; 
        implements Observer&lt;T&gt; {
}
</code></pre>
<p>在使用LiveData的observe方法订阅时，在创建一个HttpObserserver实例，在构造方法中就可以解析出T的类型，就不需要我们手动传入T的真实类型了。</p>
<pre><code class="language-java"> /**
 * 开始订阅请求网络数据
 */
public &lt;T&gt; void observe(LifecycleOwner owner,
                        HttpObserver&lt;ApiResponse&lt;T&gt;&gt; observer) {
    // 由于HttpObserver是继承ApiResponseToken的，
    // 所以可以快速的获取到泛型T的实际类型
    Type type = observer.getType();
    mConfig.type = type;
    Logs.e(&quot;type: &quot; + type);
}
</code></pre>
<p>使用方式：</p>
<pre><code class="language-java">.observe(owner, 
        // 通过new HtppObserver的方式就可以拿到具体的泛型值
         new HttpObserver&lt;ApiResponse&lt;JSONObject&gt;&gt;() {
             @Override
             public void onChanged(ApiResponse&lt;JSONObject&gt; apiResponse) {
                  .....
              }
        }
);
</code></pre>
<h2 id="http请求入口类">Http请求入口类</h2>
<p>LiveHttp的封装，LiveHttp主要提供了以下功能：</p>
<ul>
<li>
<p>持有一个默认的http引擎</p>
</li>
<li>
<p>可支持设置baseUrl和设置引擎的入口</p>
</li>
<li>
<p>设置HttpConfig中的参数</p>
</li>
<li>
<p>执行Http请求入口</p>
</li>
<li>
<p>提供取消http请求的入口</p>
</li>
<li>
<p>支持链式调用</p>
</li>
</ul>
<p>以上几点都很简单，主要是来说一下执行http请求入口：</p>
<pre><code class="language-java">/**
 * 开始订阅请求网络数据
 */
public &lt;T&gt; void observe(LifecycleOwner owner,
                        HttpObserver&lt;ApiResponse&lt;T&gt;&gt; observer) {
    // 获取泛型实际类型
    Type type = observer.getType();
    mConfig.type = type;
    Logs.d(&quot;type: &quot; + type);

    if (TextUtils.isEmpty(mConfig.url())) {
        throw new IllegalArgumentException(&quot;请求路径不能为空&quot;);
    }

    MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData = new MutableLiveData&lt;&gt;();
    // liveData的订阅必须是要在主线程中
    TaskExecutor.get().postToMain(() -&gt; liveData.observe(owner, observer));
    sHttpEngine.execute(mConfig, liveData);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PicGo搭建github图床]]></title>
        <id>https://jxiaow.gitee.io/posts/2513fba4/</id>
        <link href="https://jxiaow.gitee.io/posts/2513fba4/">
        </link>
        <updated>2020-04-13T09:35:45.000Z</updated>
        <summary type="html"><![CDATA[<p>使用图床可以节省本地服务器空间，加快图片打开速度，对于写博客或者一些网站使用很有必要，本次介绍的是PicGo的使用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用图床可以节省本地服务器空间，加快图片打开速度，对于写博客或者一些网站使用很有必要，本次介绍的是PicGo的使用。</p>
<!-- more -->
<ol>
<li>
<p>下载<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>并安装；</p>
</li>
<li>
<p>生成<a href="https://github.com/">Github</a>token</p>
</li>
</ol>
<p>步骤如下：</p>
<ul>
<li>
<p>点击个人中心，选择<code>Settings</code>,打开个人设置页面；</p>
</li>
<li>
<p>在个人设置页面选择<code>Developer Settings</code></p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-52-50-github-developer-settings.png" alt="github-developer-settings.png" loading="lazy"></figure>
<ul>
<li>进入<code>Developer settings</code>页后，点击<code>Personal access tokens</code>打开新的页面后,并点击右边的<code>Generate new token</code> 生成<code>token</code></li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-54-02-image-20200413170324831.png" alt="image-20200413170324831.png" loading="lazy"></figure>
<ul>
<li>在生成<code>token</code>页面，勾选<code>repo</code></li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-54-38-image-20200413170138935.png" alt="image-20200413170138935.png" loading="lazy"></figure>
<ol start="3">
<li>创建公共仓库，用来存放相关资源图片</li>
</ol>
<p>​    在github上创建一个仓库，用来存放一些资源</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-55-22-image-20200413172848852.png" alt="image-20200413172848852.png" loading="lazy"></figure>
<ol start="4">
<li>在PicGo中配置github图床相关信息</li>
</ol>
<ul>
<li>
<p>打开PicGo 后，先安装一个插件<code>github-plus</code>，该插件是用来将图片上传到<code>gitee</code>或<code>github</code>上，比自带的<code>github</code>图床方便(自带的没有办法删除远程记录)</p>
</li>
<li>
<p>安装完成后，插件配置：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-55-54-picgo-logo.png" alt="picgo-logo.png" loading="lazy"></figure>
<p>① 处是需要存放图片的仓库，格式为 <code>github用户名/ 仓库名</code>;</p>
<p>② 处是存放图片路径的仓库下的分支，默认<code>master</code>分支；</p>
<p>③ token 为第二步骤上生成的<strong>github token</strong>；</p>
<p>④ 远程仓库存放图片的的路径，可自定义，可不填；</p>
<p>⑤ 自定义的图片路径，由于我使用了<code>jsDelivr</code>来实现github的<code>cdn缓存</code>，所以设置了此路径，如果不需要可不填；</p>
<p><strong>jsDelivr路径规则：</strong> <code>https://cdn.jsdelivr.net/gh/用户名/仓库名@版本号</code>，我这边版本号设置的是<code>latest</code>表示获取最新资源。</p>
<p>⑥ origin 表示 仓库可以是gitee或<code>github</code>,根据前面的步骤，此处只能是github；</p>
<p>⑦ 将其设置为默认图床</p>
</li>
</ul>
<p>** 注意事项**</p>
<ul>
<li>
<p>如果仓库需要设置自定义域名，需要将我们的资源提交到一个<code>gh-pages</code>分区</p>
</li>
<li>
<p>如果你的自定义域名配置dns区分了境外和国内，那么就需要注意，访问该仓库可能会出现404的情况</p>
<p>解决办法：</p>
<ul>
<li>创建一条新的cname解析，添加一个二级域名即可</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dagger2在Android中的使用]]></title>
        <id>https://jxiaow.gitee.io/posts/e781e647/</id>
        <link href="https://jxiaow.gitee.io/posts/e781e647/">
        </link>
        <updated>2019-12-06T16:24:44.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="/posts/cbb172f8">Dagger 2 完全解析（一）,基本使用与原理</a><br>
<a href="/posts/b74c4b6c">Dagger 2 完全解析（二）, 进阶使用</a><br>
<a href="/posts/e30bee8a">Dagger 2 完全解析（三）,  Component 与 SubComponent</a><br>
<a href="/posts/e781e647">Dagger 2 完全解析（四）,在Android中的使用</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="/posts/cbb172f8">Dagger 2 完全解析（一）,基本使用与原理</a><br>
<a href="/posts/b74c4b6c">Dagger 2 完全解析（二）, 进阶使用</a><br>
<a href="/posts/e30bee8a">Dagger 2 完全解析（三）,  Component 与 SubComponent</a><br>
<a href="/posts/e781e647">Dagger 2 完全解析（四）,在Android中的使用</a></p>
<!-- more -->
<blockquote>
<p>本系列文章是基于 Google Dagger 2.23.2 版本， Kotlin 1.3.21版本</p>
</blockquote>
<p>在Android项目中使用Dagger2时，像 <code>Activity</code>和<code>Fragment</code>这种类型的初始化操作都是有Android系统提供的，如果要往其注入对象，不免会有这样的写法：</p>
<pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {

    @Inject
    lateinit var activity: MainActivity

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        DaggerMainActivityComponent.builder()
            .mainActivityModule(MainActivityModule(this))
            .appComponent(
                (application as MyApplication)
                    .daggerAppComponent
            ).build()
            .inject(this)
    }
}
</code></pre>
<p>上述写法，会有以下几个我们几乎无法避免的问题：</p>
<ol>
<li>
<p>上述Dagger部分的代码存在<strong>模板代码</strong>，在每个Activity中都会这么写到，即便抽取到BaseActivity中，也有一些特殊部分需要在每个Activity中单独处理，随着业务的增加后期维护不易；</p>
</li>
<li>
<p>从上面的代码可以看出，<code>MainActivityModule</code>中持有了<code>MainActivity</code>实例，并且需要在<code>MainActivity</code>传入参数，它打破了依赖注入的核心原则：<strong>类不应该知道它是如何注入的。</strong></p>
</li>
</ol>
<p>因此为了解决上面的问题，谷歌官方推出了<code>dagger.android</code>。</p>
<p>下面是基本的使用方式，包括如何注入<code>Activity</code>和<code>Fragment</code>,本篇只讲如何使用，后续再分析其原理。</p>
<h2 id="引入daggerandroid依赖">引入<code>Dagger.android</code>依赖</h2>
<p>在<code>build.gradle</code>中添加：</p>
<pre><code class="language-groovy">implementation 'com.google.dagger:dagger-android:2.23.2'
implementation 'com.google.dagger:dagger-android-support:2.23.2'
kapt 'com.google.dagger:dagger-android-processor:2.23.2'
</code></pre>
<h2 id="注入activity">注入Activity</h2>
<p>以<code>MainActivity</code>为例</p>
<h3 id="dagger2中的写法">Dagger2中的写法</h3>
<pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {
    // 这里只是做了一个例子
    @Inject
    lateinit var activity: MainActivity

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        DaggerMainActivityComponent.builder()
            .mainActivityModule(MainActivityModule(this))
            .appComponent(
                (application as MyApplication)
                    .daggerAppComponent
            ).build()
            .inject(this)
    }
}

@ActivityScope
@Component(modules = [MainActivityModule::class], dependencies = [AppComponent::class])
interface MainActivityComponent {
    fun inject(activity: MainActivity)
}

@Module
class MainActivityModule(private val activity: MainActivity) {
    @Provides
    fun provideMainActivity(): MainActivity = activity
}

@Scope
annotation class ActivityScope
</code></pre>
<h3 id="dagger2-android中的写法">Dagger2-Android中的写法</h3>
<h4 id="修改mainactivitycomponent">修改<code>MainActivityComponent</code></h4>
<pre><code class="language-kotlin">@ActivityScope
@Subcomponent
interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt; {
    // 声明MainActivity创建的工厂接口
    @dagger.Subcomponent.Factory
    interface Factory : AndroidInjector.Factory&lt;MainActivity&gt;
}
</code></pre>
<h4 id="修改mainactivitymodule">修改<code>MainActivityModule</code></h4>
<pre><code class="language-kotlin">@Module(subcomponents = [MainActivityComponent::class])
abstract class MainActivityModule {
    // module中提供绑定工厂方法
    @Binds
    @IntoMap
    @ClassKey(MainActivity::class)
    abstract fun bind(
        factory: MainActivityComponent.Factory
    ): AndroidInjector.Factory&lt;*&gt;
}
</code></pre>
<h4 id="修改oncreate中的dagger注入">修改<code>onCreate()</code>中的Dagger注入</h4>
<pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
   // 在super.onCreate前添加
   AndroidInjection.inject(this)
   super.onCreate(savedInstanceState)
   setContentView(R.layout.activity_main)
}
</code></pre>
<h4 id="修改myapplication">修改<code>MyApplication</code></h4>
<p>通过<code>dagger.android</code>注入时，Application中也发生了相应的变化</p>
<pre><code class="language-kotlin">class MyApplication : Application(), HasAndroidInjector {

    @Inject
    lateinit var dispatchingAndroidInjector: DqispatchingAndroidInjector&lt;Any&gt;

    override fun onCreate() {
        super.onCreate()
        DaggerAppComponent.factory().create(this).inject(this)
    }

    override fun androidInjector(): AndroidInjector&lt;Any&gt; {
        return dispatchingAndroidInjector
    }
}

@dagger.Component(
    modules = [AndroidInjectionModule::class,// 引入框架提供的InjectionModule
        AndroidSupportInjectionModule::class,// 如果使用了support相关的类，也需要引入
        MainActivityModule::class // 这是我们自定义的Module
    ]
)
interface AppComponent : AndroidInjector&lt;MyApplication&gt; {
    @dagger.Component.Factory
    interface Factory : AndroidInjector.Factory&lt;MyApplication&gt;
}
</code></pre>
<p>我们需要将我们在<code>MainActivity</code>中的<code>MainActivityModule</code>加入到<code>Application</code>中的<code>AppComponent</code>的<code>module</code>,然后<code>Make Project</code>或<code>Make App</code>或<code>build project</code>，如果未报错即成功。</p>
<h3 id="简洁写法">简洁写法</h3>
<p>如果相应的<code>ActivityComponent</code>中只有以下操作时：</p>
<pre><code class="language-kotlin">@ActivityScope
@Subcomponent
interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt; {
    // 声明MainActivity创建的工厂接口
    @dagger.Subcomponent.Factory
    interface Factory : AndroidInjector.Factory&lt;MainActivity&gt;
}
</code></pre>
<p>我们可以新建一个module类， 将满足以上条件的Component 集中到一起，并删除对应的Component，如：</p>
<pre><code class="language-kotlin">@Module
abstract class ActivityBindingModule {
    @ActivityScoped
    @ContributesAndroidInjector(modules = [MainActivityModule.class])
    abstract fun mainActivity() : MainActivity

    @ActivityScoped
    @ContributesAndroidInjector(modules = [AddEditTaskModule.class])
    abstract fun addEditTaskActivity(): AddEditTaskActivity 
}
</code></pre>
<p>删除 原有module中的<code>bind*</code>方法</p>
<pre><code class="language-java">@Module
public class MainActivityModule{

}
</code></pre>
<h2 id="注入fragment">注入Fragment</h2>
<p>注入<code>Fragment</code>与注入<code>Activity</code>类似，唯一不同的地方在于我们需要在<code>onAttach</code>方法中执行<code>AndroidSupportInject.inject(this)</code></p>
<pre><code class="language-kotlin">class BlankFragment : Fragment() {

    override fun onAttach(context: Context?) {
        AndroidSupportInjection.inject(this)
        super.onAttach(context)
    }
}

@dagger.Module
abstract class FragmentBindModule {
    @ContributesAndroidInjector
    abstract fun blankFragment(): BlankFragment
}


@dagger.Component(
    modules = [AndroidInjectionModule::class,
        AndroidSupportInjectionModule::class,
        ActivityBinder::class,
        FragmentBindModule::class
    ]
)
interface AppComponent : AndroidInjector&lt;MyApplication&gt; {

    @dagger.Component.Factory
    interface Factory : AndroidInjector.Factory&lt;MyApplication&gt;
}
</code></pre>
<p>对于<code>FragmentBindModule</code>不仅可以放入到<code>AppComponent</code>中，也可以放入到<code>MainActivityComponent</code>,或者<code>FragmentComponent</code>如：</p>
<pre><code class="language-kotlin">@dagger.Subcomponent(modules = [FragmentBindModule::class])
interface MainActivityComponent : AndroidInjector&lt;MainActivity&gt;{

    @dagger.Subcomponent.Factory
    interface Factory: AndroidInjector.Factory&lt;MainActivity&gt;
}


@dagger.Module(subcomponents = [
    MainActivityComponent::class // 将fragment放入到了activity对应的Component
])
abstract class MainActivityModule{

    @Binds
    @IntoMap
    @ClassKey(MainActivity::class)
    abstract fun bind(factory:MainActivityComponent.Factory):AndroidInjector.Factory&lt;*&gt;
}
</code></pre>
<h2 id="一些问题">一些问题</h2>
<h3 id="model-注解的是抽象类时-provides-标注的必须是静态方法">@Model  注解的是抽象类时  @provides 标注的必须是静态方法</h3>
<blockquote>
<p>A @Module may not contain both non-static @Provides methods and abstract @Binds or @Multibinds declarations</p>
</blockquote>
<p>这个错误提示是将<code>Module</code>定义成了抽象类，这在<code>java</code>中只需要将<code>@Provide</code>标注的方法设置为静态方法即可，但是在<code>Kotlin</code>中是行不通的，因为在<code>kotlin</code>中静态方法是写在<code>companion object</code>代码块内，所以解决方法有两种：</p>
<ul>
<li>
<p>用<code>Module</code>标注<code>companion object</code></p>
<pre><code class="language-kotlin">@dagger.Module
abstract class MainActivityModule() {
    @dagger.Module
    companion object {
        @JvmStatic
        @Provides
        fun provideFragment() = BlankFragment()
    }

    @Binds
    abstract fun context(activity: MainActivity): Context
}
</code></pre>
</li>
<li>
<p>使用多个<code>Module</code>将抽象方法和<code>@provide</code>标注的方法分开，如：</p>
<pre><code class="language-kotlin">@Module
abstract class MainActivityBindsModule {
    @Binds
    abstract fun context(activity: MainActivity): Context
}

@Module(includes = arrayOf(MainActivityBindsModule ::class))
class MainActivityProvidesModule {
      @Provides
      fun provideFragment() = BlankFragment()
}
</code></pre>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>通过前面的例子我们亦可以看出：</p>
<ol>
<li>Dagger2-android 使用的是Dagger2中的<strong>继承关系</strong>；</li>
<li>使用它，我们就可以不用写那么多的模版代码，相对于<code>Dagger2</code>方便了许多；</li>
<li>Dagger2-Android 比Dagger2更强大，我们使用<code>@Binds</code>绑定抽象方法来注入一些提供初始化的类等。</li>
</ol>
]]></content>
    </entry>
</feed>