<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jxiaow.gitee.io</id>
    <title>Xiaowu</title>
    <updated>2021-01-21T15:08:25.891Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jxiaow.gitee.io"/>
    <link rel="self" href="https://jxiaow.gitee.io/atom.xml"/>
    <subtitle>心若没有栖息的地方，到哪里都是在流浪</subtitle>
    <logo>https://jxiaow.gitee.io/images/avatar.png</logo>
    <icon>https://jxiaow.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Xiaowu</rights>
    <entry>
        <title type="html"><![CDATA[屏幕适配]]></title>
        <id>https://jxiaow.gitee.io/posts/9233ed3f/</id>
        <link href="https://jxiaow.gitee.io/posts/9233ed3f/">
        </link>
        <updated>2021-01-21T15:00:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dp-和-sp">dp 和 sp</h2>
<p>dp与像素无关， Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时，1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp&gt;1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。</p>
<h2 id="android-布局文件适配">Android 布局文件适配</h2>
<p><strong>Android 分辨率</strong></p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/17/3499134421b76a11b04b406081c0c756-1592361871473-f993ade9-a337-4f81-bac3-0bfa55b45f9c-8f16fe.png" alt="1592361871473f993ade9a3374f81bac30bfa55b45f9c" loading="lazy"></figure>
<p>如果在不同的分辨率上布局文件不一致，我们可以在res目录下，新建一个文件夹，如：layout-1080x720 <strong>数值大的在前面</strong></p>
<h2 id="android使用最小宽度限定符">Android使用最小宽度限定符</h2>
<p>Android开发中最头疼的问题之一就是兼容不同尺寸和分辨率的设备。在使用最小宽度限定符时这个最小宽度的该如何计算。<br>
最小宽度限定符可以使用一个与屏幕像素密度无关为单位（dp）的数值区分出的不同设备，以应用不同的资源。<br>
如下图中values-sw600dp的sw表示最小宽度，那么600dp是如何确定的呢？<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/17/3951c6895aa89c18d0edb4ed07c7422b-1592361824722-3dc4f61f-cf86-4f64-a49d-5b44a9323dfc-6aea5c.jpeg" alt="" loading="lazy"></p>
<p>举个例子：一般情况下我们可以容易知道设备的分辨率和尺寸的参数。比如现在有平板A（分辨率1280<em>720px，尺寸是8inch）， 手机B（分辨率1920</em>1080px，尺寸是5.7inch），手机C（分辨率1280*720px，尺寸是5inch）。通过下面的屏幕像素密度的计算公式，我们可以分别计算出他们的屏幕像素密度：<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/17/c90f834a918dd3c890ff085200b82c99-1592361824704-5e404eb9-c6d6-4892-a694-cb799b7f98d8-307fca.jpeg" alt="" loading="lazy"></p>
<p>平板A约为184dpi，手机B约为386dpi，手机C约为293dpi。<br>
接下里需要注意的是，最小宽度是不考虑横屏或竖屏的，也就是说最小宽度是设备屏幕四条边里最短的那两条边。<br>
如果需要考虑横竖屏那么可以加入屏幕方向限定符，这不在我们讨论之列。那么接下来我们取最短边的像素数，并通过下面的公式计算最小宽度（dp）： 平板A约为626dp，手机B约为448dp，手机C约为393dp。<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/17/272d10e130c9cee86c82ad20765303f4-1592361824487-166a5ec5-7be0-44cd-9370-12465939e47d-718378.jpeg" alt="" loading="lazy"></p>
<h2 id="android-studio-插件">Android Studio 插件</h2>
<p>在Android Studio插件市场，我们可以找到<code>ScreenMatch</code>来自动生成dimen.xml文件。</p>
<p>github地址：<a href="https://github.com/mengzhinan/PhoneScreenMatch">GitHub - mengzhinan/PhoneScreenMatch: 屏幕适配方案</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android属性动画]]></title>
        <id>https://jxiaow.gitee.io/posts/c521d2cf/</id>
        <link href="https://jxiaow.gitee.io/posts/c521d2cf/">
        </link>
        <updated>2021-01-21T12:51:11.000Z</updated>
        <content type="html"><![CDATA[<p>属性动画整理的脑图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/21/d78657d763dc999937aadb47a4225b21-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB-6d8276.png" alt="属性动画" loading="lazy"></figure>
<h2 id="基本使用">基本使用</h2>
<h3 id="valueanimator">ValueAnimator</h3>
<p><code>ValueAnimator</code>是整个属性动画机制当中最核心的一个类，属性动画的运行机制是<strong>通过不断地对值进行操作</strong>来实现的，而初始值和结束值之间的动画过渡就是由<code>ValueAnimator</code>这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，确实是一个非常重要的类。</p>
<pre><code class="language-kotlin"> ValueAnimator.ofXXX(0f, 100f, 50f, 100f)
       .apply {
          duration = 300
          addUpdateListener {
          // ...
       }
  }.start()
</code></pre>
<p>ps：<code>ofXXX</code>代表数值类型，可以是<code>ofInt</code>，<code>ofFloat</code>等。</p>
<h3 id="objectanimator">ObjectAnimator</h3>
<p><code>ObjectAnimator</code>继承自<code>ValueAnimator</code>, ValueAnimator是对值进行了一个平滑的动画过渡，而ObjectAnimator 可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。</p>
<pre><code class="language-kotlin">// 设置imageView的透明度属性
ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 1.0f, 0.4f, 1.0f)
    .apply {
        duration = 1000
        startDelay = 300
    }.start()
</code></pre>
<h3 id="propertyvaluesholder">PropertyValuesHolder</h3>
<p><code>PropertyValuesHolder</code>对象可用于通过<code>ValueAnimator</code>或<code>ObjectAnimator</code>创建动画，这些动画可以并行操作多个不同的属性。</p>
<pre><code class="language-kotlin">val holder1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1f, 0.5f)
val holder2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f, 0.5f)
val holder3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0.5f)
val animator: ObjectAnimator =
        ObjectAnimator.ofPropertyValuesHolder(binding.imgIv, holder1, holder2, holder3)
animator.duration = 200
animator.start()
</code></pre>
<h3 id="typeevaluator">TypeEvaluator</h3>
<p>通过<code>ValueAnimator#setEvaluator()</code>方法设置估值器，<code>TypeEvaluator</code>能够支持我们创建支持任意属性类型的动画。</p>
<p>系统内置了一些估值器：</p>
<blockquote>
<p><strong>ArgbEvaluator</strong>, <strong>FloatArrayEvaluator</strong>, <strong>FloatEvaluator</strong>, <strong>IntArrayEvaluator</strong>, <strong>IntEvaluator</strong>, <strong>PointFEvaluator</strong>, <strong>RectEvaluator</strong>， <strong>TypeEvaluator</strong></p>
</blockquote>
<p>我们也可以自定义，如下：</p>
<pre><code class="language-kotlin">ValueAnimator().apply {
    duration = 3000
    setObjectValues(PointF(0f, 0f))
    interpolator = AccelerateInterpolator(10f)
    val point = PointF()
    //自定义估值器
    setEvaluator { fraction, startValue, endValue -&gt;
                  point.x = 100f * (fraction * 5)
                  // y=vt=1/2*g*t*t(重力计算)
                  point.y = 0.5f * 98f * (fraction * 5) * (fraction * 5)
                  point
                 }
    addUpdateListener {
        val p = it.animatedValue as PointF
        imageView.apply {
            x = p.x
            y = p.y
        }
    }
}.start()
</code></pre>
<h3 id="interpolator">Interpolator</h3>
<p><code>Interpolator</code>被用于定义动画的变化速率。也可以说是加速度。系统自带了一些插值器如下：</p>
<ul>
<li>AccelerateDecelerateInterolator：先加速后减速</li>
<li>AccelerateInterpolator：加速</li>
<li>DecelerateInterpolator：减速</li>
<li>AnticipateInterpolator：先向相反方向改变一段再加速播放</li>
<li>AnticipateOvershootInterpolator：先向相反方向改变，再加速播放，会超出目标值然后缓慢移动至目标值，类似于弹簧回弹</li>
<li>BounceInterpolator：快到目标值时值会跳跃</li>
<li>CycleIinterpolator：动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI)</li>
<li>LinearInterpolator：线性均匀改变</li>
<li>OvershottInterpolator：最后超出目标值然后缓慢改变到目标值</li>
<li>TimeInterpolator：一个允许自定义Interpolator的接口，以上都实现了该接口</li>
</ul>
<p>都是通过：<br>
<code>valueAnimator.setInterpolator(new LinearInterpolator());</code><br>
设置即可。</p>
<pre><code class="language-kotlin">ValueAnimator().apply {
    duration = 3000
    setObjectValues(PointF(0f, 0f))
    interpolator = AccelerateInterpolator(10f)
}.start()
</code></pre>
<h3 id="animatorset">AnimatorSet</h3>
<p><code>AnimatorSet</code>是对属性动画的一个集合，可以让很多动画按一定顺序或者 同时进行。</p>
<pre><code class="language-kotlin">val translationXAnimator = ObjectAnimator.ofFloat(binding.imgIv, &quot;translationX&quot;, 0f, 500f)
val alphaAnimator = ObjectAnimator.ofFloat(binding.imgIv, &quot;alpha&quot;, 0f, 1f)
val scaleXAnimator = ObjectAnimator.ofFloat(binding.imgIv, &quot;scaleX&quot;, 0f, 2f)

val animatorSet = AnimatorSet()
animatorSet.duration = 500

// 按照顺序执行
// animatorSet.playSequentially(translationXAnimator, alphaAnimator, scaleXAnimator)
// 一起执行
// animatorSet.playTogether(translationXAnimator, alphaAnimator, scaleXAnimator)
// 链式调用
// animatorSet.play(translationXAnimator).with(alphaAnimator).with(scaleXAnimator)
// after 在 play之前执行  before 在 play之后执行
animatorSet.play(translationXAnimator).after(scaleXAnimator).before(alphaAnimator)
animatorSet.start()
</code></pre>
<h2 id="实战">实战</h2>
<p><a href="https://gitee.com/jxiaow/practiseCodeAndroid/blob/master/AnimationSample/app/src/main/java/com/github/jxiaow/animation/SplashView.kt">xiaow/AndroidPractiseCode: Android 代码练习库 - Gitee.com</a></p>
<h2 id="动画框架">动画框架</h2>
<p><a href="https://gitee.com/jxiaow/practiseCodeAndroid/blob/master/AnimationSample/app/src/main/java/com/github/jxiaow/framework/AnimatorScrollView.kt">xiaow/AndroidPractiseCode: Android 代码练习库 - Gitee.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Klint格式化代码]]></title>
        <id>https://jxiaow.gitee.io/posts/745cbbe1/</id>
        <link href="https://jxiaow.gitee.io/posts/745cbbe1/">
        </link>
        <updated>2021-01-05T02:13:13.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/shyiko/ktlint">ktlint</a> 是一款用来检查Kotlin代码风格的工具，在Android Studio 中可以使用 <a href="https://github.com/diffplug/spotless">spotless</a>。</p>
<p>在 project 下的build.gradle 中：</p>
<pre><code>buildscript {
    // Define versions in a single place
    ext {
        // Sdk and tools
        ktlintVersion = '0.33.0'
    }
}
 
plugins {
    id &quot;com.diffplug.gradle.spotless&quot; version &quot;4.3.0&quot;
}
 
spotless {
    kotlin {
        target &quot;**/*.kt&quot;
        ktlint(ktlintVersion).userData(['max_line_length' : '100'])
    }
}
</code></pre>
<p>设置好后，在控制台输入</p>
<pre><code>gradlew build
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/05/1243d237d8337ca75622d34561a177e6-1592451801894-6b55f217-0517-4bee-acaf-48c5cb326807-062f08.png" alt="image.png" loading="lazy"></figure>
<p>如果有错误的话，就会出现提示，然后再次输入命令：</p>
<pre><code>gradlew :spotlessApply
</code></pre>
<p>即可修复。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 事件分发机制]]></title>
        <id>https://jxiaow.gitee.io/posts/149503c8/</id>
        <link href="https://jxiaow.gitee.io/posts/149503c8/">
        </link>
        <updated>2021-01-04T05:53:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android事件分发机制">Android事件分发机制</h1>
<blockquote>
<p>源码基于 API 30</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/04/66b068244f5dd3120267516cdb214013-Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6-bb31d3.png" alt="Android事件分发机制" loading="lazy"></figure>
<h2 id="activity-事件分发">Activity 事件分发</h2>
<p>流程图：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/31/1a58b9a8e764d57a34b8a0fa3d260f1e-Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE-e99245.svg" alt="Activity事件分发流程图" loading="lazy"></figure>
<h3 id="activitydispatchtouchevent">Activity#dispatchTouchEvent()</h3>
<pre><code class="language-java">public boolean dispatchTouchEvent(MotionEvent ev) {
    // 一般事件都是从DOWN事件开始，故此处为true
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
</code></pre>
<h3 id="activityonuserinteraction">Activity#onUserInteraction()</h3>
<blockquote>
<p>默认实现为空</p>
<p>当activity在栈顶时，按home，back,menu键时会触发此方法</p>
</blockquote>
<pre><code class="language-java">public void onUserInteraction() {
}
</code></pre>
<h3 id="phonewindowsuperdispatchtouchevent">PhoneWindow#superDispatchTouchEvent()</h3>
<p>在<code>Activity#dispatchTouchEvent</code>中调用了<code>getWindow().superDisaptchTouchEvent()</code>， 而我们知道<code>getWindow()</code>返回的是<code>PhoneWindow</code>，所以 间接的调用了<code>PhoneWindow#superDispatchTouchEvent()</code>。</p>
<pre><code class="language-java">@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}
</code></pre>
<p>从上述方法可以看出，<code>superDispatchTouchEvent</code>调用了<code>mDecor</code>（不在此处详细介绍了）的<code>superDispatchTouchEvent</code>。</p>
<h3 id="decorviewsuperdispatchtouchevent">DecorView#superDispatchTouchEvent()</h3>
<pre><code class="language-java">public boolean superDispatchTouchEvent(MotionEvent event) {
    return super.dispatchTouchEvent(event);
}
</code></pre>
<p><code>DecorView</code>继承自<code>FrameLayout</code>，所以<code>super.dispatchTouchEvent(event)</code>会调用到<code>ViewGroup</code>中的<code>dispatchTouchEvent(event)</code>方法。</p>
<h3 id="activityontouch">Activity#onTouch()</h3>
<p>前面通过源码跟踪了<code>getWindow().superDispatchTouchEvent(ev)</code>的调用过程，现在看一下<code>onTouch()</code>。</p>
<pre><code class="language-java">public boolean onTouchEvent(MotionEvent event) {
    if (mWindow.shouldCloseOnTouch(this, event)) {
        finish();
        return true;
    }
    return false;
}
</code></pre>
<p>当一个点击事件未被<code>Activity</code>下的任何一个<code>view</code>消耗时，就会调用此方法。如： 处理发生在<code>Window</code>边界外的触摸事件。</p>
<h3 id="windowshouldcloseontouch">Window#shouldCloseOnTouch()</h3>
<pre><code class="language-java">public boolean shouldCloseOnTouch(Context context, MotionEvent event) {
    final boolean isOutside =
        event.getAction() == MotionEvent.ACTION_UP &amp;&amp; isOutOfBounds(context, event)
        || event.getAction() == MotionEvent.ACTION_OUTSIDE;
    if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) {
        return true;
    }
    return false;
}
</code></pre>
<p>主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等。</p>
<h2 id="viewgroup-事件分发">ViewGroup 事件分发</h2>
<p>从上面<code>Activity</code>事件分发机制可知，<code>ViewGroup</code>事件分发机制从<code>dispatchTouchEvent()</code>开始。</p>
<h3 id="viewgroupdispatchtouchevent">ViewGroup.dispatchTouchEvent()</h3>
<pre><code class="language-java">@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    // ...
 
    boolean handled = false;
 
    // 过滤掉不安全的事件响应
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;
 
        // DOWN事件下做初始化操作
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            // 取消和清除上一次的触摸对象
            cancelAndClearTouchTargets(ev);
            // 重置触摸状态
            resetTouchState();
        }
 
        // 检查是否需要拦截处理
        // Check for interception.
        final boolean intercepted;
        // DOWN事件或有触摸对象的情况下，检查是否需要做事件拦截处理
        if (actionMasked == MotionEvent.ACTION_DOWN
            || mFirstTouchTarget != null) {
            // 默认情况下是false,子view调用了父view的 requestDisallowInterceptTouchEvent() 改变
            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
            // false的情况下，会调用onInterceptTouchEvent,根据intercepted的值进行判断是否需要拦截
            if (!disallowIntercept) {
                // 一般情况下，不做拦截
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else { // 否则不拦截
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
 
        // If intercepted, start normal event dispatch. Also if there is already
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
 
        // 检查是否需要取消
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this)
            || actionMasked == MotionEvent.ACTION_CANCEL;
 
        // Update list of touch targets for pointer down, if needed.
        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0
            &amp;&amp; !isMouseEvent;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        // 不拦截，不取消的情况下
        if (!canceled &amp;&amp; !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                ? findChildWithAccessibilityFocus() : null;
 
            // DOWN事件处理
            if (actionMasked == MotionEvent.ACTION_DOWN
                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                final int actionIndex = ev.getActionIndex(); // always 0 for down
                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                    : TouchTarget.ALL_POINTER_IDS;
 
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
 
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                    final float x =
                        isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);
                    final float y =
                        isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    // 对当前view下所有的子view根据z轴的值大小，从小到大进行排序
                    final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null
                        &amp;&amp; isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    // 从后往前遍历所有child，将事件传递
                    for (int i = childrenCount - 1; i &gt;= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(
                            childrenCount, i, customOrder);
                        // 获取child
                        final View child = getAndVerifyPreorderedView(
                            preorderedList, children, childIndex);
                        // 如果child不能接收事件或者当前事件未在child内，则寻找下一个child
                        if (!child.canReceivePointerEvents()
                            || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        // 第一次查找，由于mFirstTouchTarget为null,所以newTouchTarget也为null
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
 
                        resetCancelNextUpFlag(child);
                        // 将事件分发到child, 如果child已消耗事件，则返回true
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j &lt; childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            // 事件被child消耗，那么会将child复制给 mFirstTouchTarget和 newTouchTarget, 并结束查找
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
 
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null) preorderedList.clear();
                }
                // 如果已经找到,newTouchTarget 不为空
                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // 如果 mFirstTouchTarget 为 null，表明没有找到需要消耗该事件的child
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // 传递child 为null后，会调用 super.dispatchTouchEvent()，进入view的事件分发中
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                                                    TouchTarget.ALL_POINTER_IDS);
        } else { // 找到了需要拦截的child, 进行后续事件处理
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                    // Down 事件 拦截处理
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                        || intercepted;
                    // 其他事件调用child分发
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                                                      target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // ...
    }
    // ...
    return handled;
}
</code></pre>
<h3 id="viewgrouponfiltertoucheventforsecurity">ViewGroup.onFilterTouchEventForSecurity()</h3>
<p>当视图被隐藏或者窗口被遮挡时，过滤掉该事件响应。</p>
<pre><code class="language-java">public boolean onFilterTouchEventForSecurity(MotionEvent event) {
    //noinspection RedundantIfStatement
    // 当视图被隐藏或者窗口被遮挡时，过滤掉该事件响应
    if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0
        &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
        // Window is obscured, drop this touch.
        return false;
    }
    return true;
}
</code></pre>
<h3 id="viewgrouprequestdisallowintercepttouchevent">ViewGroup.requestDisallowInterceptTouchEvent()</h3>
<p>设置是否允许父view拦截触摸事件， true 不允许，false运行。</p>
<pre><code class="language-java">@Override
public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
 
    if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) {
        // We're already in this state, assume our ancestors are too
        return;
    }
 
    if (disallowIntercept) {
        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;
    } else {
        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
    }
 
    // Pass it up to our parent
    if (mParent != null) {
        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
    }
}
</code></pre>
<h3 id="viewgrouponintercepttouchevent">ViewGroup.onInterceptTouchEvent()</h3>
<p><code>onInterceptTouchEvent</code>的返回值决定当前viewGroup是否要对触摸事件进行拦截，如果为true，则进行拦截并终止事件往下传递，一般情况下不拦截。</p>
<pre><code class="language-java">public boolean onInterceptTouchEvent(MotionEvent ev) {
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN
            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {
        return true;
    }
    return false;
}
</code></pre>
<h3 id="viewgroupbuildtouchdispatchchildlist">ViewGroup.buildTouchDispatchChildList()</h3>
<p>将<code>child</code>根据<code>z</code>轴值的大小进行从小到大排列（即 离用户的远近进行排列）。</p>
<pre><code class="language-java">public ArrayList&lt;View&gt; buildTouchDispatchChildList() {
    return buildOrderedChildList();
}
</code></pre>
<pre><code class="language-java">ArrayList&lt;View&gt; buildOrderedChildList() {
    final int childrenCount = mChildrenCount;
    if (childrenCount &lt;= 1 || !hasChildWithZ()) return null;
 
    if (mPreSortedChildren == null) {
        mPreSortedChildren = new ArrayList&lt;&gt;(childrenCount);
    } else {
        // callers should clear, so clear shouldn't be necessary, but for safety...
        mPreSortedChildren.clear();
        mPreSortedChildren.ensureCapacity(childrenCount);
    }
 
    final boolean customOrder = isChildrenDrawingOrderEnabled();
    // 遍历child，根据getZ()进行排列
    for (int i = 0; i &lt; childrenCount; i++) {
        // add next child (in child order) to end of list
        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        final View nextChild = mChildren[childIndex];
        final float currentZ = nextChild.getZ();
 
        // insert ahead of any Views with greater Z
        int insertIndex = i;
        while (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) {
            insertIndex--;
        }
        mPreSortedChildren.add(insertIndex, nextChild);
    }
    return mPreSortedChildren;
}
</code></pre>
<h3 id="viewgroupgettouchtarget">ViewGroup.getTouchTarget()</h3>
<p>根据child获取触摸的对象，第一次执行时，返回值为null。</p>
<pre><code class="language-java">private TouchTarget getTouchTarget(@NonNull View child) {
    for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
        if (target.child == child) {
            return target;
        }
    }
    return null;
}
</code></pre>
<h3 id="viewgroupdispatchtransformedtouchevent">ViewGroup.dispatchTransformedTouchEvent()</h3>
<p>将当前事件进行child分发，当child为null时，调用<code>super.dispatchTouchEvent()</code>，返回true，代表事件已被消耗。</p>
<pre><code class="language-java">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
                                              View child, int desiredPointerIdBits) {
    final boolean handled;
 
    // Canceling motions is a special case.  We don't need to perform any transformations
    // or filtering.  The important part is the action, not the contents.
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) {
            handled = super.dispatchTouchEvent(event);
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        event.setAction(oldAction);
        return handled;
    }
 
    // Calculate the number of pointers to deliver.
    final int oldPointerIdBits = event.getPointerIdBits();
    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;
 
    // If for some reason we ended up in an inconsistent state where it looks like we
    // might produce a motion event with no pointers in it, then drop the event.
    if (newPointerIdBits == 0) {
        return false;
    }
 
    // If the number of pointers is the same and we don't need to perform any fancy
    // irreversible transformations, then we can reuse the motion event for this
    // dispatch as long as we are careful to revert any changes we make.
    // Otherwise we need to make a copy.
    final MotionEvent transformedEvent;
    if (newPointerIdBits == oldPointerIdBits) {
        if (child == null || child.hasIdentityMatrix()) {
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                final float offsetX = mScrollX - child.mLeft;
                final float offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);
 
                handled = child.dispatchTouchEvent(event);
 
                event.offsetLocation(-offsetX, -offsetY);
            }
            return handled;
        }
        transformedEvent = MotionEvent.obtain(event);
    } else {
        transformedEvent = event.split(newPointerIdBits);
    }
 
    // Perform any necessary transformations and dispatch.
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (!child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }
 
        handled = child.dispatchTouchEvent(transformedEvent);
    }
 
    // Done.
    transformedEvent.recycle();
    return handled;
}
</code></pre>
<h2 id="view-事件分发">View 事件分发</h2>
<h3 id="viewgroupaddtouchtarget">ViewGroup.addTouchTarget()</h3>
<p>获取<code>TouchTarget</code>并将其赋值给<code>mFirstTouchTarget</code>。</p>
<pre><code class="language-java">private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
    target.next = mFirstTouchTarget;
    mFirstTouchTarget = target;
    return target;
}
</code></pre>
<h3 id="viewdispatchtouchevent">View.dispatchTouchEvent()</h3>
<p>touch事件最终会传递到<code>View</code>的<code>dispatchTouchEvent</code>中，根据其返回值决定是否会消耗该事件。</p>
<pre><code class="language-java">public boolean dispatchTouchEvent(MotionEvent event) {
    // ...
    boolean result = false;
 
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    // DOWN事件下停止上一次的滚动事件
    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }
    // 过滤到不安全的事件响应
    if (onFilterTouchEventForSecurity(event)) {
        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {
            result = true;
        }
        // 先处理setOnTouchListener中的onTouch方法，如果返回true，则不再进行方法传递
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
        // 如果mOnTouchListener == null  或 mOnTouchListener.onTouch() 为false,则会调用onTouchEvent()方法。
        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }
 
    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
 
    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn't want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }
 
    return result;
}
</code></pre>
<h2 id="补充点">补充点</h2>
<p><strong>action与actionMasked</strong>的区别：</p>
<blockquote>
<p><strong>相同点：</strong><br>
都表示此次MotionEvent的事件类型-手指按下/移动/抬起</p>
<p><strong>不同点：</strong><br>
action 无法直接识别第二根手指的按下与抬起，而 actionMasked 可以。action 的类型有 按下、移动、抬起，而 actionMasked 有额外两种类型：<br>
ACTION_POINTER_DOWN - “已经有手指按着了，又按下了新手指”<br>
ACTION_POINTER_UP - “手指抬起了，但仍有其它手指按着”</p>
<p><strong>使用建议：</strong><br>
action比actionMasked少了多指识别，适合&quot;检测点击位置&quot;、&quot;记录按下时间&quot;这种只涉及按下抬起的动作。<br>
对于单指拖拽动作要确保用户只用一根手指，不会出现类似“按下第二根手指后抬起第一根手指，继续拖拽”这种临时多指的动作，否则位置会跳。<br>
actionMasked比action更全面，无论处理简单拖拽还是复杂的多指事件都适用。</p>
</blockquote>
<pre><code class="language-kotlin">fun parseActionString(actionMasked: Int): String {
    return when (actionMasked) {
        MotionEvent.ACTION_DOWN -&gt; &quot;按下&quot;
            MotionEvent.ACTION_POINTER_DOWN -&gt; &quot;按下(已有其它触摸点)&quot;
            MotionEvent.ACTION_MOVE -&gt; &quot;移动&quot;
            MotionEvent.ACTION_POINTER_UP -&gt; &quot;抬起(仍留其它触摸点)&quot;
            MotionEvent.ACTION_UP -&gt; &quot;抬起&quot;
            MotionEvent.ACTION_CANCEL -&gt; &quot;取消&quot;
            else -&gt; &quot;未知&quot;
            }
}
</code></pre>
<h2 id="思维导图">思维导图</h2>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/20/bb611881dedbef108831f4feefa3165b-Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6-6d6774.png" alt="Android事件分发机制" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI绘制合集]]></title>
        <id>https://jxiaow.gitee.io/posts/b1e45c68/</id>
        <link href="https://jxiaow.gitee.io/posts/b1e45c68/">
        </link>
        <updated>2020-12-17T09:33:22.000Z</updated>
        <summary type="html"><![CDATA[<p>最近正在整理以前总结的关于 <strong>Android高级UI</strong> 相关的知识，本篇文章只是一个目录，用于进行文章归档。</p>
<h2 id="ui-思维导图">UI 思维导图</h2>
]]></summary>
        <content type="html"><![CDATA[<p>最近正在整理以前总结的关于 <strong>Android高级UI</strong> 相关的知识，本篇文章只是一个目录，用于进行文章归档。</p>
<h2 id="ui-思维导图">UI 思维导图</h2>
<!--more-->
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/04/b8784e03ce0e921ad0fbe1a023c28e41-Android-ui-update-50349d.png" alt="Android-ui-update" loading="lazy"></figure>
<h2 id="ui-测量布局绘制流程">UI 测量布局绘制流程</h2>
<h3 id="整体绘制流程"><a href="https://jxiaow.gitee.io/posts/69abe299/">整体绘制流程</a></h3>
<h3 id="布局绘制入口"><a href="https://jxiaow.gitee.io/posts/cd03afe4/">布局绘制入口</a></h3>
<h3 id="测量流程"><a href="https://jxiaow.gitee.io/posts/a920adc7">测量流程</a></h3>
<h3 id="布局流程"><a href="https://jxiaow.gitee.io/posts/6f6ae2ee">布局流程</a></h3>
<h3 id="绘制流程"><a href="https://jxiaow.gitee.io/posts/94ccb851">绘制流程</a></h3>
<h2 id="绘制流程-2">绘制流程</h2>
<h3 id="paint的基本使用"><a href="https://jxiaow.gitee.io/posts/46f22235">Paint的基本使用</a></h3>
<h3 id="paint的高级使用-shader"><a href="https://jxiaow.gitee.io/posts/36c3e87b">Paint的高级使用-Shader</a></h3>
<h3 id="paint的高级使用-滤镜"><a href="https://jxiaow.gitee.io/posts/49e1d711">Paint的高级使用-滤镜</a></h3>
<h3 id="paint的高级使用-xfermode"><a href="https://jxiaow.gitee.io/posts/b2c61861">Paint的高级使用-xfermode</a></h3>
<h3 id="pathmeasure的基本使用"><a href="https://jxiaow.gitee.io/posts/3d90af75">PathMeasure的基本使用</a></h3>
<h2 id="自定义view">自定义view</h2>
<h3 id="自定义view-2"><a href="https://jxiaow.gitee.io/posts/b6d9f081">自定义view</a></h3>
<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android通过Intent简单实现分享功能]]></title>
        <id>https://jxiaow.gitee.io/posts/73a6d0c4/</id>
        <link href="https://jxiaow.gitee.io/posts/73a6d0c4/">
        </link>
        <updated>2020-12-04T16:03:24.000Z</updated>
        <summary type="html"><![CDATA[<p>现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过<code>Intent</code>方式打开在系统中安装的具有分享功能的App的分享页面。</p>
]]></summary>
        <content type="html"><![CDATA[<p>现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过<code>Intent</code>方式打开在系统中安装的具有分享功能的App的分享页面。</p>
<!-- more -->
<p>方法如下：</p>
<pre><code class="language-java">public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_SEND);
    intnet.setType(&quot;text/plain&quot;);
    PackageManager packageManager = context.getPackageManager();
    List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0);
    return resloveInfos;
}
</code></pre>
<p>如果只需要QQ和微信分享，可以进行如下操作：</p>
<pre><code class="language-java">public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_SEND);
    intnet.setType(&quot;text/plain&quot;);
    PackageManager packageManager = context.getPackageManager();
    List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0);
    List&lt;ResolveInfo&gt; shareItems = new ArrayList();    
    for(ResolveInfo info: resolveInfos) {
        String name = info.activityInfo.packageName;
        if (TextUtils.equals(packageName, &quot;com.tencent.mm&quot;)
                    || TextUtils.equals(packageName, &quot;com.tencent.mobileqq&quot;)) {
                shareItems.add(resolveInfo);
        }
    }
    return shareItems;
}
</code></pre>
<p>通过<code>ResolveInfo</code>获取图标<code>ICON</code>和<code>Label</code>:</p>
<pre><code class="language-java">Drawable drawable = resloveInfo.loadIcon(packageManager);
CharSequence label = resolveInfo.loadLabel(packageManager);
</code></pre>
<p>通过<code>Intent</code>发起分享：</p>
<pre><code class="language-java">public static void share(Context context, 
            ResolveInfo info, String shareContent){
    Intent itnent = new Intent();
    intnet.setAction(Intent.ACTION_SEND);
    String pkg = resolveInfo.activityInfo.packageName;
    String cls = resolveInfo.activityInfo.name;
    intent.setComponent(new Component(pkg, cls));
    intent.putExtra(Intent.EXTRA_TEXT, shareContent);
    context.startActivity(intent);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora + PicGo-Core + Github 实现图片上传到Github]]></title>
        <id>https://jxiaow.gitee.io/posts/cde2810e/</id>
        <link href="https://jxiaow.gitee.io/posts/cde2810e/">
        </link>
        <updated>2020-11-07T08:10:37.000Z</updated>
        <summary type="html"><![CDATA[<p>为了解决<code>为知笔记</code>使用<code>Typora</code>编辑<code>markdown</code>文件图片丢失的问题，我采用了<code>PicGo-Core +Github</code>实现了自定图床的功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>为了解决<code>为知笔记</code>使用<code>Typora</code>编辑<code>markdown</code>文件图片丢失的问题，我采用了<code>PicGo-Core +Github</code>实现了自定图床的功能。</p>
<!--more-->
<h2 id="下载picgo-core">下载PicGo-Core</h2>
<p>由于我的电脑有<code>nodejs</code>环境，所以我使用的是<code>npm</code>命令安装<code>picgo</code>, 命令如下：</p>
<pre><code class="language-shell">npm install picgo -g
</code></pre>
<p>安装完成后，检查命令行输出, 记录下红色框内的路径。<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105201730919.png" alt="image-20201105201730919" loading="lazy"></p>
<p>输入命令查看版本，如果有输出则添加成功。</p>
<pre><code class="language-shell">picgo -v
</code></pre>
<h2 id="安装github-plus">安装github-plus</h2>
<p>官方提供的github上传图库不好用，安装一款新的上传插件<code>github-plus</code>, 命令行执行：</p>
<pre><code class="language-shell">picgo install github-plus
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105223054898.png" alt="image-20201105223054898" loading="lazy"></figure>
<p>安装成功后会有提示。</p>
<h2 id="typora图像设置">Typora图像设置</h2>
<p>在<code>Typora</code>中配置图像上传信息。</p>
<h3 id="设置picgo的配置信息">设置PicGo的配置信息</h3>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105223720354.png" alt="" loading="lazy"></figure>
<p>如上图所示，分为2个步骤：</p>
<ol>
<li><strong>上传服务</strong>选择<code>PicGo-Core(command line)</code></li>
<li>打开配置文件，在打开的配置文件，添加相关信息。</li>
</ol>
<pre><code class="language-json">{
 &quot;picBed&quot;: {
   &quot;uploader&quot;: &quot;githubPlus&quot;,
   &quot;current&quot;: &quot;githubPlus&quot;,
   &quot;githubPlus&quot;: {
     &quot;branch&quot;: &quot;master&quot;,// 仓库分支
     &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest&quot;, // 访问的自定义url
     &quot;origin&quot;: &quot;github&quot;, // 存放的图片类型
     &quot;repo&quot;: &quot;jxiaow/cdn-images&quot;, // 存放图片的仓库
     &quot;path&quot;: &quot;blog-images&quot;,// 存放图片的仓库目录下的文件夹
     &quot;token&quot;: &quot;&quot; // 访问github的仓库的token, 不知道怎么设置的自行百度
   }
 },
 &quot;picgoPlugins&quot;: {
   &quot;picgo-plugin-github-plus&quot;: true // 启用github-plus插件
 },
 &quot;picgo-plugin-github-plus&quot;: {
   &quot;lastSync&quot;: &quot;2020-11-05 07:54:47&quot;
 }
}
</code></pre>
<h3 id="测试配置">测试配置</h3>
<p>根据上述配置完毕后我们需要进行测试链接是否成功，在测试之前还要进行如图所示的修改：<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105224420441.png" alt="image-20201105224420441" loading="lazy"></p>
<ol>
<li><strong>上传服务</strong>修改为<code>Custom Command</code></li>
<li>自定义命令 ： <code>picgo upload</code></li>
<li>点击验证图片上传选项</li>
<li>如果显示验证成功，则表示配置完成。<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/image-20201105225415181.png" alt="image-20201105225415181" loading="lazy"></li>
</ol>
<h2 id="图片上传">图片上传</h2>
<p>将图片拖入Typora中，然后在图片单击右键，图片上传即可。</p>
<h2 id="安装文件重命名插件-picgo-plugin-rename-file">安装文件重命名插件 <a href="https://github.com/liuwave/picgo-plugin-rename-file">picgo-plugin-rename-file</a></h2>
<p><code>picgo-plugin-rename-file</code> 插件可以帮我们安装一定的规则将文件进行重命名，具体设置请看github。</p>
<p>输入一下命令安装:</p>
<pre><code class="language-shell">picgo install rename-file
</code></pre>
<p>安装完成后，打开<code>picgo</code>的配置文件<code>C:\Users\xxx\.picgo\config.json</code>末尾最后一个大括号前添加一下信息即可。</p>
<pre><code class="language-json">,
&quot;picgo-plugin-rename-file&quot;: {
    &quot;format&quot;: &quot;{y}/{m}/{d}/{hash}-{origin}-{rand:6}&quot;
}
</code></pre>
<h2 id="添加水印">添加水印</h2>
<p><em><strong>注意：此插件目前会导致文件上传重命名插件不生效</strong></em><br>
插件地址: <a href="https://github.com/Dec-F/picgo-plugin-watermark">picgo-plugin-watermark</a> ，<code>watermark</code>插件可以帮我们在上传图片的时候添加水印。</p>
<p>安装命令：</p>
<pre><code class="language-shell">picgo install watermark
</code></pre>
<p>安装成功后，<code>C:\Users\xxx\.picgo\config.json</code>末尾最后一个大括号前添加一下信息即可。</p>
<pre><code class="language-json">,
&quot;picgo-plugin-watermark&quot;: { // 以下配置信息参考插件地址说明
    &quot;text&quot;: &quot;jxiaow&quot;, // 水印名称
    &quot;fontSize&quot;: 18, // 水印字体大小
    &quot;position&quot;:&quot;rm&quot; // 水印位置
},
</code></pre>
<p><strong>注意：</strong> 由于这个插件安装过程中需要下载字体，会导致下载特别慢，尽可能使用代理。</p>
<p><strong>website:</strong> <a href="https://xiaowujiang.cn">xiaowujiang.cn</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[360加固Gradle插件实现]]></title>
        <id>https://jxiaow.gitee.io/posts/6c01e784/</id>
        <link href="https://jxiaow.gitee.io/posts/6c01e784/">
        </link>
        <updated>2020-09-07T16:14:31.000Z</updated>
        <content type="html"><![CDATA[<p>最近码了一个基于360加固的流程实现的Gradle插件，在自动编译打包后进行360加固流程操作。只需要配置一些参数后，就可以实现自动打包编译和加固。</p>
<p>项目地址:https://github.com/jxiaow/android-gradle-plugin</p>
<h3 id="使用步骤">使用步骤</h3>
<h4 id="1-添加依赖">1. 添加依赖</h4>
<ul>
<li>在根<code>build.gradle</code>中添加：</li>
</ul>
<pre><code class="language-groovy">allprojects {
    repositories {
        maven { url &quot;https://jitpack.io&quot; }
    }
}

dependencies {
    ...
    classpath 'com.github.jxiaow:android-gradle-plugin:$version'
}
</code></pre>
<p>(请替换 <code>$version</code>为最新的版本号:<a href="https://jitpack.io/#jxiaow/android-gradle-plugin"><img src="https://jitpack.io/v/jxiaow/android-gradle-plugin.svg" alt="" loading="lazy"></a>)</p>
<ul>
<li>在<code>app</code>的模块<code>build.gradle</code>中添加：</li>
</ul>
<pre><code class="language-groovy">apply plugin: 'com.github.jxiaow.jiagu'
</code></pre>
<h4 id="2-参数配置">2. 参数配置</h4>
<p>使用这款插件需要在<code>app</code>的<code>build.gradle</code>中添加一些配置信息，如下：</p>
<pre><code class="language-groovy">jiagu {
    home '../360jiagu' // 360加固软件的根目录
    buildTypes 'release', 'debug' // 需要加固的编译类型
    configs '-crashlog' // 选择360的可选配置服务
    username 'user' // 360加固用户名
    password 'password' // 360加固密码
    charsetName 'GBK' // 360加固控制台输出字符编码
    // apk签名文件， 如果在Android中配置了签名文件，此项可以不用配置，插件会自动读取名为'release'的签名文件
    signingConfig { 
        key_alias         : KEY_ALIAS, 
        key_password      : KEY_PASSWORD,
        key_store_password: KEY_STORE_PASSWORD,
        key_store_file    : KEY_STORE_FILE
    }
}
</code></pre>
<h4 id="3-开始加固">3. 开始加固</h4>
<p>确认上述参数无误后，就可以在控制台中切换到当前项目根目录执行</p>
<pre><code class="language-shell"># 各个系统的控制台gradle命令可能不一样： ./gradlew 或 gradlew 
./gradlew clean jiaGuApk 
</code></pre>
<h3 id="文档">文档</h3>
<p><a href="https://jxiaow.github.io/android-gradle-plugin/plugin/com.github.jxiaow.jiagu/index.html">android-gradle-plugin</a></p>
<h3 id="360加固助手">360加固助手</h3>
<p><a href="https://jiagu.360.cn/#/global/download">360加固助手</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Http框架封装]]></title>
        <id>https://jxiaow.gitee.io/posts/84a009ed/</id>
        <link href="https://jxiaow.gitee.io/posts/84a009ed/">
        </link>
        <updated>2020-04-26T02:03:07.000Z</updated>
        <summary type="html"><![CDATA[<p>用过了现有的一些<code>http</code>请求框架，决定自己也来简单的封装一个。本文只是基于一些http请求框架二次封装的，高手勿喷。<a href="https://github.com/ixiaow/ppjoke/tree/master/network/src/main/java/com/mooc/network">源码</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>用过了现有的一些<code>http</code>请求框架，决定自己也来简单的封装一个。本文只是基于一些http请求框架二次封装的，高手勿喷。<a href="https://github.com/ixiaow/ppjoke/tree/master/network/src/main/java/com/mooc/network">源码</a></p>
<!-- more -->
<h2 id="http的请求和响应">http的请求和响应</h2>
<p>一个http的请求通常包含请求头、请求体、响应头和响应体，考虑到这些因素，<code>HttpConfig</code>和 <code>ApiResponse</code>就诞生了: <a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/HttpConfig.java">HttpConfig</a></p>
<h3 id="httpconfig">HttpConfig</h3>
<p>http参数配置类，应该包含如下属性:</p>
<ul>
<li>baseUrl/url</li>
</ul>
<p>如果使用restful形式，baseUrl是不能为空并且url为业务path, 如果是非restful,url必须为请求全路径</p>
<ul>
<li>GET/POST</li>
</ul>
<p>有了url，接下来需要有请求的方法类型，由于我这边只用到了<code>GET</code>和<code>POST</code>,所以只对此做了封装。</p>
<p><strong>特别说明：</strong> POST 有三种提交方式（form表单、json形式和 复杂形式）</p>
<pre><code class="language-java">FORM_DATA(&quot;application/x-www-form-urlencoded;charset=utf-8&quot;),
JSON_DATA(&quot;application/json;charset=utf-8&quot;),
MULTI_PART_DATA(&quot;multipart/form-data;charset=utf-8&quot;);
</code></pre>
<ul>
<li>headers</li>
</ul>
<p>http的请求头封装，采用<code>(Map&lt;String,String&gt;)</code>集合</p>
<ul>
<li>params</li>
</ul>
<p>http的请求参数，采用<code>(Map&lt;String,Object&gt;)</code>如果请求方法是<code>GET</code>形式，那么采用拼接字符串的形式将参数拼接到url中; 如果请求方法是<code>POST</code>形式，则需要根据提交参数的方式不同，会有不同的请求体。</p>
<ul>
<li>cacheStrategy</li>
</ul>
<p>考虑到App的使用交互和服务器减压，我们要考虑有一些请求可以做一些缓存，那么常用的缓存策略有<code>CACHE_ONLY</code>、<code>CACHE_FIRST</code>、<code>NET_ONLY</code>和<code>NET_CACHE</code></p>
<ul>
<li>type</li>
</ul>
<p>type是响应数据的type,这个主要用在Http请求结果返回后将json转为bean对象的映射类型，需要考虑泛型和非泛型（Class和ParamizableType）</p>
<ul>
<li>tag</li>
</ul>
<p>给每一个请求链接打一个标签，可用于一些其它的操作，如根据tag取消请求</p>
<ul>
<li>isAsync</li>
</ul>
<p>当前请求是同步执行还是异步执行的标志，异步执行会在子线程中进行http请求，同步执行在当前线程中执行http请求。</p>
<h4 id="apiresponset">ApiResponse<T></h4>
<p>使用<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/ApiResponse.java">ApiResponse</a>的原因是为了规范请求结果返回的表现形式，他有一个<code>T</code>类型的数据。</p>
<ul>
<li>code</li>
</ul>
<p>状态码,与http请求响应状态码一致，200~300 请求成功，304 使用缓存</p>
<ul>
<li>message</li>
</ul>
<p>请求响应的错误信息</p>
<ul>
<li>data</li>
</ul>
<p>响应的数据，泛型T, 根据<code>httpConfig</code>中的type,映射 json--&gt; bean</p>
<h2 id="http引擎">Http引擎</h2>
<p><a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/IHttpEngine.java">IHttpEngine</a>是一个接口，使用者可以根据实际的情况做具体的实现。</p>
<pre><code class="language-java">public interface IHttpEngine {

    // 开始执行 http请求
    &lt;T&gt; execute(HttpConfig config, MultableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData);
    // 根据tag取消
    void cancel(Object tag);
}
</code></pre>
<p>由于http请求有同步和异步两种情况并且又牵扯到了缓存策略问题（如果先进行缓存返回在执行网络请求并返回数据），在异步回调的情况下这些问题可以通过回调解决，但是在同步情况下，这些问题并不能很好的处理，曾经有使用过将当前请求<code>clone</code>,然后再次调用请求服务器的方法，但是在使用过<code>jetpack</code>的<code>LiveData</code>框架后这些问题都可以解决了。</p>
<h2 id="okhttpengine">OkhttpEngine</h2>
<p>Android开发目前来说大多数项目使用的都是<code>Okhttp</code>来做请求，本次我使用的默认引擎也是使用它来作为默认的实现。<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/okhttp/OkHttpEngine.java">OkHttpEngine</a></p>
<h3 id="okhttp简单配置">okhttp简单配置</h3>
<p>对okhttp进行一些简单的配置就可以进行网络请求了，如下：</p>
<ul>
<li>创建okHttpClient</li>
</ul>
<pre><code class="language-java"> private static final OkHttpClient OK_HTTP_CLIENT;

 // 添加日志拦截器
 HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
 loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);

 OK_HTTP_CLIENT = new OkHttpClient.Builder()
               .connectTimeout(15, TimeUnit.SECONDS)
               .readTimeout(15, TimeUnit.SECONDS)
               .writeTimeout(15, TimeUnit.SECONDS)
               .addInterceptor(loggingInterceptor)
               .build();
</code></pre>
<ul>
<li>添加证书管理</li>
</ul>
<pre><code class="language-java">TrustManager[] trustManagers = new TrustManager[]{
    new X509TrustManager() {
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }
     }
};

SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;);
sslContext.init(null, trustManagers, new SecureRandom());
HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -&gt; true);
</code></pre>
<h3 id="实现http请求">实现Http请求</h3>
<p>IHttpEngine中的<code>execute</code>方法是具体的http请求方法，所有实现<code>IHttpEngine</code>的方法都需要实现此方法。</p>
<pre><code class="language-java">@NonNull
@Override
public &lt;T&gt; void execute(@NonNull Config config, 
                        @NonNull MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
    Request request = generateRequest(config);
    Call call = OK_HTTP_CLIENT.newCall(request);
    if (!config.isAsync) {
        execute(call, config, liveData);
    } else {
        enqueue(call, config, liveData);
    }
}
</code></pre>
<p><code>execute</code>方法中大致需要做以下事：</p>
<ul>
<li>创建request--&gt; genearteRequest</li>
<li>发送http请求 ---&gt; execute/enqueue</li>
</ul>
<h4 id="创建httprequest">创建httpRequest</h4>
<p><code>generateRequest()</code>根据<code>HttpConfig</code>中的请求方式来创建不同的http请求。</p>
<pre><code class="language-java">/**
 * 根据配置信息生成request
 *
 * @param config 配置信息
 * @return request
 */
 @NonNull
 private Request generateRequest(@NonNull Config config) {
    switch (config.method) {
       case Config.GET:
           return generateGetRequest(config);
       case Config.POST:
           return generatePostRequest(config);

       default:
           throw new IllegalStateException(&quot;this request method invalidate: &quot; + config.method);
    }
}
</code></pre>
<h5 id="get请求的创建方式">GET请求的创建方式</h5>
<p><code>genearteGetReques()</code>方法，利用okhttp的Request类创建request实例，并利用<a href="https://github.com/ixiaow/ppjoke/blob/master/network/src/main/java/com/mooc/network/http/UrlCreator.java">UrlCreator</a>将参数拼接到url中。Url拼接时需要注意使用<code>UrlEncoder</code>编码，不然可能会造成服务器和客户端解析数据不一致的情况。</p>
<pre><code class="language-java">/**
 * 生成get方式的请求
 *
 * @param config 请求配置
 * @return 返回get方式的request
 */
@NonNull
private Request generateGetRequest(@NonNull Config config) {
   Request.Builder builder = new Request.Builder().get();
   builder.tag(config.tag);
   addHeader(builder, config);
   String url = UrlCreator.generateUrlForParams(config.url(), config.getParams());
   return builder.url(url).build();
}
</code></pre>
<h5 id="post请求的创建方式">POST请求的创建方式</h5>
<p>POST请求方式提交内容时相对于GET方式要复杂许多，他需要根据提交方式的不同添加不同的<code>header</code>和内容<code>body</code>, 在<code>generatePostRequest()</code>方法中先利用okhttp的request类创建request实例，根据调用者在<code>HttpConfig</code>中设置<code>formData</code>来创建不同形式的<code>body</code>。</p>
<pre><code class="language-java">/**
 * 生成post请求
 *
 * @param config http请求配置信息
 * @return 请求request
 */
@NonNull
private Request generatePostRequest(@NonNull Config config) {
   Request.Builder builder = new Request.Builder().url(config.url());
   builder.tag(config.tag);
   addHeader(builder, config);

   // 根据提交方式添加header信息
   Pair&lt;String, String&gt; header = config.formData.getHeader();
   builder.addHeader(header.first, header.second);

   // 创建body
   RequestBody body = generatePostRequestBody(config);
   return builder.post(body).build();
}
</code></pre>
<p>判断<code>formData</code>类型，创建不同的<code>request body</code>。</p>
<pre><code class="language-java">/**
 * 获取post提交体
 *
 * @param config 请求配置信息
 * @return RequestBody
 */
@NonNull
private RequestBody generatePostRequestBody(@NonNull Config config) {
   FormData formData = config.formData;
   switch (formData) {
       case FORM_DATA:
           return getFormDataRequestBody(config);
       case JSON_DATA:
           return getJsonDataRequestBody(config);
       case MULTI_PART_DATA:
           return getMultiDataRequestBody(config);
       default:
           throw new IllegalArgumentException(&quot;post formData is invalidate: &quot; + formData);
   }
}
</code></pre>
<h6 id="创建formdata表单">创建FormData(表单)</h6>
<p>form表单形式比较简单，只需要创建一个okhttp的FormBody并将param添加，需要注意的是添加param时调用的是<code>addEncoded</code>方法。</p>
<pre><code class="language-java">/**
 * 生成form data形式的post数据
 *
 * @param config 请求配置
 * @return FromBody
 */
 @NonNull
 private RequestBody getFormDataRequestBody(@NonNull Config config) {
     FormBody.Builder builder = new FormBody.Builder(StandardCharsets.UTF_8);
     Map&lt;String, Object&gt; params = config.getParams();
     for (Map.Entry&lt;String, Object&gt; entry : params.entrySet()) {
          builder.addEncoded(entry.getKey(), String.valueOf(entry.getValue()));
     }
     return builder.build();
 }
</code></pre>
<h6 id="json形式">json形式</h6>
<p>利用okHttp中的<code>RequestBody.create()</code>方法创建一个json形式的body,需要传递json和json形式的header。</p>
<pre><code class="language-java">/**
 * 生成json形式的post数据
 *
 * @param config 请求配置
 * @return RequestBody
 */
 @NonNull
 private RequestBody getJsonDataRequestBody(@NonNull Config config) {
   if (config.getParams().isEmpty()) {
        throw new IllegalArgumentException(&quot;json data is null&quot;);
   }
   Object json = config.getParams().get(Config.JSON_KEY);
   return RequestBody.create(String.valueOf(json), MediaType.parse(config.formData.getValue()));
 }
</code></pre>
<h6 id="复杂形式的body">复杂形式的body</h6>
<p>复杂形式的body，主要是用在文件上传这一块儿。它需要判断当前param是普通key-value、单文件和多文件。</p>
<p>利用okhttp的MultiparBody创建body对象并根据内容类型调用的不同的body,然后调用<code>addFormDataPart</code>添加到MultipartBody中。</p>
<pre><code class="language-java">/**
 * 获取复杂的post提交体
 *
 * @param config 请求配置信息
 * @return MultipartBody
 */
@NonNull
@SuppressWarnings(&quot;unchecked&quot;)
private RequestBody getMultiDataRequestBody(@NonNull Config config) {

    MultipartBody.Builder builder = new MultipartBody.Builder();
    builder.setType(MultipartBody.FORM);

    for (Map.Entry&lt;String, Object&gt; entry : config.getParams().entrySet()) {
        String key = entry.getKey();
        Object value = entry.getValue();

        if (value instanceof File) {
            File file = (File) value;
            RequestBody requestBody = MultipartBody.create(file, getFileMediaType(file));
            builder.addFormDataPart(key, file.getName(), requestBody);
        } else if (value instanceof List) {
            List&lt;File&gt; files = (List&lt;File&gt;) value;
            for (int i = 0; i &lt; files.size(); i++) {
                File file = files.get(i);
                RequestBody requestBody = MultipartBody.create(file, getFileMediaType(file));
                builder.addFormDataPart(key + i, file.getName(), requestBody);
            }
        } else {
            builder.addFormDataPart(key, String.valueOf(value));
        }
    }
    return builder.build();
}
</code></pre>
<p>添加文件时需要有文件的类型，文件类型的获取方式是通过<code>UrlConnection</code>的getFileNameMap方法获取。</p>
<pre><code class="language-java">/**
 * 获取文件的type类型
 *
 * @param file 文件
 * @return MediaType
 */
@Nullable
private MediaType getFileMediaType(@NonNull File file) {
    FileNameMap fileNameMap = URLConnection.getFileNameMap();
    String contentTypeFor = fileNameMap.getContentTypeFor(file.getAbsolutePath());
    if (contentTypeFor == null) {
        contentTypeFor = &quot;application/octet-stream&quot;;
    }
    return MediaType.parse(contentTypeFor);
</code></pre>
<p>通过以上的几种方式就可以创建一个http请求了，接下来需要发送请求了，发送请求需要通过httpConfig中的<code>isAsync</code>来判断是开启一个子线程还是在当前线程中执行操作（同步与异步）。</p>
<h4 id="发送http请求">发送http请求</h4>
<p>发送http请求会有同步请求(execute)和异步请求(enqueue), 同步请求是在当前线程中发送http请求，异步请求采用okhttp线程池发送请求。处理请求时在合适的地方需要判断该请求是否被取消。</p>
<pre><code class="language-java"> if (call.isCanceled()) {
    return;
 }
</code></pre>
<h5 id="同步请求execute">同步请求(execute)</h5>
<p>在发送http请求时会根据缓存策略进行响应的处理，而同步请求没有办法做到<code>return</code>后可以继续进行网络请求，所以引入了<code>LiveData</code>来发送数据。</p>
<p>目前缓存策略有四种，我们需要根据判断来进行不同的操作，关于缓存的创建和获取后续会有说明，这块儿只有根据缓存策略处理数据。</p>
<pre><code class="language-java">/**
 * 同步执行的方法
 */
@SuppressWarnings(&quot;unchecked&quot;)
private &lt;T&gt; void execute(Call call, Config config, MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
    ApiResponse&lt;T&gt; apiResponse;
    Logs.d(&quot;execute before cache: &quot; + Thread.currentThread().getName());
    // 只访问本地数据
    if (config.cacheStrategy == Config.CACHE_ONLY) {
        apiResponse = readCache(call.request().url().toString());
        liveData.postValue(apiResponse);
        return;
    }

    // 先访问本地数据，然后再发起网络请求
    if (config.cacheStrategy == Config.CACHE_FIRST) {
        apiResponse = readCache(call.request().url().toString());
        liveData.postValue(apiResponse);
    }

    Logs.d(&quot;execute current thread: &quot; + Thread.currentThread().getName());
    // ..... 此处开始进行http网络请求


    if (call.isCanceled()) {
        return;
    }
    // liveData发送数据
    liveData.postValue(apiResponse);
    if (config.cacheStrategy != Config.NET_ONLY) {
        saveCache(call.request().url().toString(), apiResponse);
    }
}
</code></pre>
<p>使用okhttp的<code>execute</code>方法发送http请求,并利用<code>ConvertFactory</code>进行数据解析，ConvertFactory后续会介绍。</p>
<pre><code class="language-java"> try {
      Response response = call.execute();
      IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
      apiResponse = convert.convert(response, config.type);
 } catch (IOException e) {
      e.printStackTrace();
      apiResponse = new ApiResponse&lt;&gt;();
      apiResponse.status = 500;
      apiResponse.message = e.getMessage();
 }
</code></pre>
<h5 id="异步请求enqueue">异步请求(enqueue)</h5>
<p>异步请求与同步请求一样也需要进行缓存策略进行缓存处理，这块儿的处理逻辑一致，所以下面的代码块将这部分省略。使用okhttp的<code>enqueue</code>方法发送http请求,在<code>onResponse</code>中并利用<code>ConvertFactory</code>进行数据的解析，在<code>onFailure</code>中自定义错误信息的返回。</p>
<pre><code class="language-java">private &lt;T&gt; void enqueue(Call call, Config config, MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData) {
        //... 缓存策略判断数据处理返回
        ...
        // 开始请求服务器
        call.enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                if (call.isCanceled()) {
                    return;
                }
                ApiResponse&lt;T&gt; apiResponse = new ApiResponse&lt;&gt;();
                apiResponse.status = 500;
                apiResponse.message = e.getMessage();
                liveData.postValue(apiResponse);
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                if (call.isCanceled()) {
                    return;
                }
                IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
                ApiResponse&lt;T&gt; apiResponse = convert.convert(response, config.type);
                liveData.postValue(apiResponse);
                if (config.cacheStrategy != Config.NET_ONLY) {
                    saveCache(call.request().url().toString(), apiResponse);
                }
            }
        });
    }
</code></pre>
<h3 id="取消请求">取消请求</h3>
<p><code>cancle()</code>方法中，利用Okhttp来取消请求，主要是比对tag, 如下：</p>
<pre><code class="language-java">@Override
public void cancel(@NonNull Object tag) {
    if (OK_HTTP_CLIENT == null) {
        return;
    }

    //查找当前需要取消的tag是否在未执行的请求中
    for (Call call : OK_HTTP_CLIENT.dispatcher().queuedCalls()) {
        if (tag.equals(call.request().tag())) {
            call.cancel();
        }
    }

    //查找当前需要请求的tag是否在正在执行的请求中
    for (Call call : OK_HTTP_CLIENT.dispatcher().runningCalls()) {
        if (tag.equals(call.request().tag())) {
            call.cancel();
        }
    }
}
</code></pre>
<h2 id="响应数据转换">响应数据转换</h2>
<p>从服务器返回数据后，需要将数据格式进行转换成数据模型bean，由于数据返回的形式有多种，所以解析方式也会有多种，所以这块儿可以考虑使用数据解析工厂类去做数据解析，不同的解析数据做不同的逻辑实现，达到解偶。</p>
<p>定义一个<code>Convert</code>类，利用泛型的方式进行参数传递。</p>
<pre><code class="language-java">public interface IConvert&lt;T, R&gt; {
    // 数据的返回形式必须是ApiResponse, type即为泛型T的类型
    @NonNull
    ApiResponse&lt;R&gt; convert(@NonNull T t, @NonNull Type type);
}
</code></pre>
<p>这边提供了一种简单的convert调用方式，后面可以要考虑进行扩展选择：</p>
<pre><code class="language-java"> IConvert&lt;Response, T&gt; convert = ConvertFactory.create();
 apiResponse = convert.convert(response, config.type);
</code></pre>
<p><code>ConverFactory</code>为<code>IConvert</code>的实现类。</p>
<pre><code class="language-java">public class ConvertFactory&lt;R&gt; implements IConvert&lt;Response, R&gt; {
    private static ConvertFactory convertFactory;


    public static ConvertFactory create() {
        if (convertFactory == null) {
            convertFactory = new ConvertFactory();
        }
        return convertFactory;
    }

    ...........
}
</code></pre>
<h2 id="本地缓存">本地缓存</h2>
<p>数据缓存采用的是<code>Room</code>数据库进行数据的存储，room是jetpack中的一种组件。它的创建方式也很简单。</p>
<h3 id="创建数据库表">创建数据库表</h3>
<pre><code class="language-java">// Entity 表示该对象是一张数据库表
@Entity(tableName = &quot;cache&quot;)
public class Cache {
    // primarykey表示表的主键
    @PrimaryKey
    @NonNull
    public String key;
    // ColumnInfo表示该字段在表中显示的字段名
    @ColumnInfo(name = &quot;_data&quot;)
    public byte[] data;
}
</code></pre>
<h3 id="创建数据库">创建数据库</h3>
<pre><code class="language-java">// entities 表示 需要在该数据库中创建的表，可以创建多张
// version 数据库的版本号
// exportSchema 导出表创建的语句
@Database(entities = Cache.class, version = 1, exportSchema = true)
public abstract class CacheDatabase extends RoomDatabase {
    private static final CacheDatabase cacheDatabase;

    static {
        Application application = AppGlobals.getApplication();
        cacheDatabase = Room.databaseBuilder(application, CacheDatabase.class, &quot;net_cache.db&quot;)
                .allowMainThreadQueries()
                .build();
    }

    // 数据库与Dao关联
    public abstract CacheDao getCacheDao();

    public static CacheDatabase get() {
        return cacheDatabase;
    }
} 
</code></pre>
<h3 id="创建数据库表操作类dao">创建数据库表操作类Dao</h3>
<pre><code class="language-java">// Dao 用来表示当前类是数据库表的操作类
@Dao
public interface CacheDao {
    // Insert 表示增加一条记录到数据库表中
    // onConflict 表示如果添加数据时出现冲突的解决策略
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void save(@NonNull Cache cache);

    // Delete 表示删除一条记录
    @Delete
    int delete(@NonNull Cache cache);

    // Update 表示更新一条记录
    // onConflict 表示如果更新数据时出现冲突的解决策略
    @Update(onConflict = OnConflictStrategy.REPLACE)
    int update(@NonNull Cache cache);

    // Query 查找一条记录
    @Query(&quot;SELECT * FROM cache WHERE `key`=:key&quot;)
    Cache query(@NonNull String key);
}
</code></pre>
<h2 id="type类型">Type类型</h2>
<p>由于java中的泛型在编译完毕后会擦除该类型，所以我们无法在同步执行或者多级泛型嵌套的情况下拿到泛型的实际类型。目前的解决方式有两种。</p>
<h3 id="调用者传入实际类型">调用者传入实际类型</h3>
<p>提供可以传入实际类型的方法，调用处将明确类型传递。</p>
<h3 id="利用子类实现的方式获取实际类型">利用子类实现的方式获取实际类型</h3>
<p>Java代码在编译成字节码class文件时会保留子类的泛型信息。所以大部分的json数据解析都是采用的此方法，如：Gson中的TypeToken 以及fasjson中的TypeReference。</p>
<pre><code class="language-java">public abstract class TypeToken&lt;T&gt; {
    // 泛型T的实际类型
    protected Type type;

    public TypeToken() {
        Type superClass = getClass().getGenericSuperclass();
        // 获取泛型的实际类型
        Type oriType = ((ParameterizedType) superClass).getActualTypeArguments()[0];

        if (oriType instanceof Class) {
            type = oriType;
        } else {
            //修复在安卓环境中问题
            type = putCacheTypeIfAbsent(oriType);
        }
    }
}
</code></pre>
<p>由于本次封装的返回的数据类型是<code>ApiResponse&lt;T&gt;</code>所以需要对泛型进行二次解析，所以新建了一个ApiResponseToken。</p>
<pre><code class="language-java">public abstract class ApiResponseToken&lt;T&gt; extends TypeToken&lt;T&gt; {

    public ApiResponseToken() {
        Type superClass = getClass().getGenericSuperclass();

        Type oriType = ((ParameterizedType) superClass).getActualTypeArguments()[0];

        if (oriType instanceof Class) {
            type = oriType;
        } else {
            // 解决ApiResponse&lt;T&gt;这种情况
            if (oriType instanceof ParameterizedType) {
                oriType = ((ParameterizedType) oriType).getActualTypeArguments()[0];
            }
            type = putCacheTypeIfAbsent(oriType);
        }
    }
}
</code></pre>
<p>由于本次框架的数据返回使用了<code>LiveData&lt;T&gt;</code>的形式，并通过订阅的方式实现数据返回，所以又添加了一个类型，用于自行获取type。</p>
<pre><code class="language-java">public abstract class HttpObserver&lt;T&gt; extends ApiResponseToken&lt;T&gt; 
        implements Observer&lt;T&gt; {
}
</code></pre>
<p>在使用LiveData的observe方法订阅时，在创建一个HttpObserserver实例，在构造方法中就可以解析出T的类型，就不需要我们手动传入T的真实类型了。</p>
<pre><code class="language-java"> /**
 * 开始订阅请求网络数据
 */
public &lt;T&gt; void observe(LifecycleOwner owner,
                        HttpObserver&lt;ApiResponse&lt;T&gt;&gt; observer) {
    // 由于HttpObserver是继承ApiResponseToken的，
    // 所以可以快速的获取到泛型T的实际类型
    Type type = observer.getType();
    mConfig.type = type;
    Logs.e(&quot;type: &quot; + type);
}
</code></pre>
<p>使用方式：</p>
<pre><code class="language-java">.observe(owner, 
        // 通过new HtppObserver的方式就可以拿到具体的泛型值
         new HttpObserver&lt;ApiResponse&lt;JSONObject&gt;&gt;() {
             @Override
             public void onChanged(ApiResponse&lt;JSONObject&gt; apiResponse) {
                  .....
              }
        }
);
</code></pre>
<h2 id="http请求入口类">Http请求入口类</h2>
<p>LiveHttp的封装，LiveHttp主要提供了以下功能：</p>
<ul>
<li>
<p>持有一个默认的http引擎</p>
</li>
<li>
<p>可支持设置baseUrl和设置引擎的入口</p>
</li>
<li>
<p>设置HttpConfig中的参数</p>
</li>
<li>
<p>执行Http请求入口</p>
</li>
<li>
<p>提供取消http请求的入口</p>
</li>
<li>
<p>支持链式调用</p>
</li>
</ul>
<p>以上几点都很简单，主要是来说一下执行http请求入口：</p>
<pre><code class="language-java">/**
 * 开始订阅请求网络数据
 */
public &lt;T&gt; void observe(LifecycleOwner owner,
                        HttpObserver&lt;ApiResponse&lt;T&gt;&gt; observer) {
    // 获取泛型实际类型
    Type type = observer.getType();
    mConfig.type = type;
    Logs.d(&quot;type: &quot; + type);

    if (TextUtils.isEmpty(mConfig.url())) {
        throw new IllegalArgumentException(&quot;请求路径不能为空&quot;);
    }

    MutableLiveData&lt;ApiResponse&lt;T&gt;&gt; liveData = new MutableLiveData&lt;&gt;();
    // liveData的订阅必须是要在主线程中
    TaskExecutor.get().postToMain(() -&gt; liveData.observe(owner, observer));
    sHttpEngine.execute(mConfig, liveData);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PicGo搭建github图床]]></title>
        <id>https://jxiaow.gitee.io/posts/2513fba4/</id>
        <link href="https://jxiaow.gitee.io/posts/2513fba4/">
        </link>
        <updated>2020-04-13T09:35:45.000Z</updated>
        <summary type="html"><![CDATA[<p>使用图床可以节省本地服务器空间，加快图片打开速度，对于写博客或者一些网站使用很有必要，本次介绍的是PicGo的使用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用图床可以节省本地服务器空间，加快图片打开速度，对于写博客或者一些网站使用很有必要，本次介绍的是PicGo的使用。</p>
<!-- more -->
<ol>
<li>
<p>下载<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>并安装；</p>
</li>
<li>
<p>生成<a href="https://github.com/">Github</a>token</p>
</li>
</ol>
<p>步骤如下：</p>
<ul>
<li>
<p>点击个人中心，选择<code>Settings</code>,打开个人设置页面；</p>
</li>
<li>
<p>在个人设置页面选择<code>Developer Settings</code></p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-52-50-github-developer-settings.png" alt="github-developer-settings.png" loading="lazy"></figure>
<ul>
<li>进入<code>Developer settings</code>页后，点击<code>Personal access tokens</code>打开新的页面后,并点击右边的<code>Generate new token</code> 生成<code>token</code></li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-54-02-image-20200413170324831.png" alt="image-20200413170324831.png" loading="lazy"></figure>
<ul>
<li>在生成<code>token</code>页面，勾选<code>repo</code></li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-54-38-image-20200413170138935.png" alt="image-20200413170138935.png" loading="lazy"></figure>
<ol start="3">
<li>创建公共仓库，用来存放相关资源图片</li>
</ol>
<p>​    在github上创建一个仓库，用来存放一些资源</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-55-22-image-20200413172848852.png" alt="image-20200413172848852.png" loading="lazy"></figure>
<ol start="4">
<li>在PicGo中配置github图床相关信息</li>
</ol>
<ul>
<li>
<p>打开PicGo 后，先安装一个插件<code>github-plus</code>，该插件是用来将图片上传到<code>gitee</code>或<code>github</code>上，比自带的<code>github</code>图床方便(自带的没有办法删除远程记录)</p>
</li>
<li>
<p>安装完成后，插件配置：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/ixiaow/cdn-images/2020/05/10-00-55-54-picgo-logo.png" alt="picgo-logo.png" loading="lazy"></figure>
<p>① 处是需要存放图片的仓库，格式为 <code>github用户名/ 仓库名</code>;</p>
<p>② 处是存放图片路径的仓库下的分支，默认<code>master</code>分支；</p>
<p>③ token 为第二步骤上生成的<strong>github token</strong>；</p>
<p>④ 远程仓库存放图片的的路径，可自定义，可不填；</p>
<p>⑤ 自定义的图片路径，由于我使用了<code>jsDelivr</code>来实现github的<code>cdn缓存</code>，所以设置了此路径，如果不需要可不填；</p>
<p><strong>jsDelivr路径规则：</strong> <code>https://cdn.jsdelivr.net/gh/用户名/仓库名@版本号</code>，我这边版本号设置的是<code>latest</code>表示获取最新资源。</p>
<p>⑥ origin 表示 仓库可以是gitee或<code>github</code>,根据前面的步骤，此处只能是github；</p>
<p>⑦ 将其设置为默认图床</p>
</li>
</ul>
<p>** 注意事项**</p>
<ul>
<li>
<p>如果仓库需要设置自定义域名，需要将我们的资源提交到一个<code>gh-pages</code>分区</p>
</li>
<li>
<p>如果你的自定义域名配置dns区分了境外和国内，那么就需要注意，访问该仓库可能会出现404的情况</p>
<p>解决办法：</p>
<ul>
<li>创建一条新的cname解析，添加一个二级域名即可</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>