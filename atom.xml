<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jxiaow.gitee.io</id>
    <title>Xiaowu</title>
    <updated>2021-03-17T08:30:10.965Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jxiaow.gitee.io"/>
    <link rel="self" href="https://jxiaow.gitee.io/atom.xml"/>
    <subtitle>心若没有栖息的地方，到哪里都是在流浪</subtitle>
    <logo>https://jxiaow.gitee.io/images/avatar.png</logo>
    <icon>https://jxiaow.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Xiaowu</rights>
    <entry>
        <title type="html"><![CDATA[Git 基本使用]]></title>
        <id>https://jxiaow.gitee.io/posts/b8d683be/</id>
        <link href="https://jxiaow.gitee.io/posts/b8d683be/">
        </link>
        <updated>2021-03-17T08:26:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>以下内容是在初使用Git的时的笔记记录，会不定时更新。</p>
</blockquote>
<h1 id="1-git使用操作">1. Git使用操作</h1>
<h2 id="11-代理">1.1. 代理</h2>
<ul>
<li>设置代理</li>
</ul>
<p>如果需要下载墙外的仓库：</p>
<pre><code class="language-bash">//1080 可以根据自己买的vpn服务器端口
git config --global http.proxy 'socks5://127.0.0.1:1080'
 
git config --global https.proxy 'socks5://127.0.0.1:1080'
</code></pre>
<ul>
<li>删除代理</li>
</ul>
<pre><code>git config --global --unset http.proxy
 
git config --global --unset https.proxy
</code></pre>
<h2 id="12-android创建忽略文件gitignore">1.2. Android创建忽略文件<code>.gitignore</code></h2>
<ul>
<li>一般如果使用Android Studio创建的时候，IDE会自动给我创建<code>.gitignore</code>文件，但有时候我们也需要自定义此文件。因此，我们可以从 <a href="https://github.com/github/gitignore">github/gitignore</a>   项目中下载相应的文件，放到我们项目的根目录即可。</li>
</ul>
<h2 id="13-git撤销commit">1.3. git撤销commit</h2>
<pre><code>git commit --amend
</code></pre>
<h2 id="14-git-回到某个版本">1.4. git 回到某个版本</h2>
<pre><code>git reset id //只更改版本，不修改代码
git reset --hard id //版本和代码都修改
</code></pre>
<h2 id="15-git-多url推送">1.5. git 多url推送</h2>
<p>第一个url</p>
<pre><code>git remote add origin url
</code></pre>
<p>然后其他的</p>
<pre><code>git remote set-url --add origin url
</code></pre>
<h2 id="16-git-push-origin-master">1.6. git push origin master</h2>
<ul>
<li>git push 推送到默认分支</li>
<li>git push origin 推送到主机为origin的远程服务器上</li>
<li>git push origin master 推送到主机为origin的服务器上的master分支</li>
</ul>
<h2 id="17-git-放弃本地修改强制拉取更新">1.7. git 放弃本地修改，强制拉取更新</h2>
<ol>
<li>从服务器拉取数据到本地</li>
</ol>
<pre><code class="language-shell">git fetch --all
或者
git fetch 主机名 分支 （example: git fetch origin dev）
</code></pre>
<ol start="2">
<li>把Head指向最新拉取的分支</li>
</ol>
<pre><code class="language-SHELL">git reset --hard 主机名/分支 (example: git reset --hard origin/dev)
</code></pre>
<ol start="3">
<li>重新拉取（这步可忽略）</li>
</ol>
<pre><code class="language-shell">git pull 主机名 分支
</code></pre>
<h2 id="18-git-修改分支名称">1.8. git 修改分支名称</h2>
<pre><code class="language-shell">git branch -m oldBranchName newBranchName //修改本地的
git push //推送到远程分支
</code></pre>
<h2 id="19-git-push-出现错误error-failed-to-push-some-refs">1.9. git push 出现错误：<code>error: failed to push some refs</code></h2>
<p>1、在使用git 对源代码进行push到git仓库时可能会出错</p>
<p>2、出现错误的主要原因是本地和远程仓库中的代码不一致导致</p>
<p>3、可以通过如下命令进行代码合并【注：pull=fetch+merge]</p>
<pre><code class="language-shell">git pull --rebase origin master
</code></pre>
<p>4、此时再执行语句 git push 即可完成代码上传到远程仓库</p>
<h1 id="2-查看所有分支情况">2. 查看所有分支情况</h1>
<pre><code class="language-bash">git branch -a
</code></pre>
<h2 id="21-删除远程分支">2.1. 删除远程分支</h2>
<pre><code class="language-shell">git push origin --delete dev
</code></pre>
<h2 id="22-git提示auto-packing-the-repository-in-background-for-optimum-performance">2.2. git提示Auto packing the repository in background for optimum performance</h2>
<p>查资料，原来是自己本地一些 “悬空对象”太多(git删除分支或者清空stash的时候，这些其实还没有真正删除，成为悬空对象，我们可以使用merge命令可以从中恢复一些文件)</p>
<p>解决： (删除掉.)<br>
1.输入命令：git fsck -.-lost-found，可以看到好多“dangling commit”<br>
2.清空他们：git gc -.-prune=now，完成</p>
<h3 id="git-rebase-i-head~xxx是修改git-历史记录的一个很有用的命令">&quot;git rebase -i HEAD~xxx&quot;是修改git 历史记录的一个很有用的命令。</h3>
<p>但是有时在执行该命令时会出现以下错误：<br>
$ git rebase –i HEAD~8<br>
fatal: Needed a single revision<br>
invalid upstream –i</p>
<p>二、错误原因<br>
当前执行操作的点不在任何分支上，或者可能rebase后面的参数是一个错误的分支；<br>
当前执行操作的点前面的提交不够8个。</p>
<p>三、解决办法<br>
确认'-i' 之后的参数是否正确；<br>
确认需要rebase的提交相对于'HEAD'的序号，一种极端情况是想从当前分支的第一个提交开始rebase，可以使用以下命令：git rebase -i --root。</p>
<h2 id="3-修改本地分支名称和远程分支名称">3 修改本地分支名称和远程分支名称</h2>
<h3 id="本地分支重名名">本地分支重名名</h3>
<pre><code class="language-shell">git branch -m old_branch new_branch
</code></pre>
<h3 id="删除远程分支并重新推送">删除远程分支并重新推送</h3>
<pre><code class="language-shell">git push origin :old_branch
git push origin new_branch:new_branch
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binder解析]]></title>
        <id>https://jxiaow.gitee.io/posts/7425384b/</id>
        <link href="https://jxiaow.gitee.io/posts/7425384b/">
        </link>
        <updated>2021-01-31T13:32:11.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/cbe191fcba5fc5e06c7cd120d4f6a437-Binder-0748cb.png" alt="Binder" loading="lazy"></figure>
<ol>
<li>
<p>Binder 是什么？</p>
<blockquote>
<p>ipc通信方式</p>
</blockquote>
</li>
<li>
<p>什么时候需要用到进程间通信？</p>
<blockquote>
<p>webview访问，图片加载，推送 ，比较耗内存，单开一个会比较有保障， 系统的一些服务，如通话，闹钟，输入法服务等等</p>
</blockquote>
</li>
<li>
<p>为什么要多进程？</p>
<blockquote>
<p>虚拟机分配给各个应用的每个进程内存都是有限制的，耗内存的服务，如果不开一个服务，app的主进程内存会很快耗尽，会出现OOM</p>
</blockquote>
</li>
<li>
<p>进程间通信为什么需要用到Binder?</p>
<p>本篇主题。</p>
</li>
</ol>
<h3 id="linux进程空间划分">Linux进程空间划分</h3>
<ul>
<li>
<p>一个进程空间分为 <strong>用户空间</strong> &amp; <strong>内核空间(Kernel)</strong>，即把进程内 用户 &amp; 内核 隔离开来</p>
</li>
<li>
<p>二者区别：</p>
<ul>
<li>进程间，用户空间的数据不可共享，所以用户空间 = 不可共享空间</li>
<li>进程间，内核空间的数据可共享，所以内核空间 = 可共享空间</li>
</ul>
<blockquote>
<p>所有进程共用1个内核空间</p>
</blockquote>
</li>
<li>
<p>进程内 用户空间 &amp; 内核空间 进行交互 需通过 <strong>系统调用</strong>，主要通过函数：</p>
<blockquote>
<ol>
<li>copy_from_user（）：将用户空间的数据拷贝到内核空间</li>
<li>copy_to_user（）：将内核空间的数据拷贝到用户空间</li>
</ol>
</blockquote>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/d103f9c5352bb3fec41d063bd4e935d6-linux%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4-e559ed.png" alt="linux进程空间" loading="lazy"></figure>
<h4 id="进程隔离-跨进程通信-ipc">进程隔离 &amp; 跨进程通信（ IPC ）</h4>
<ul>
<li>
<p>进程隔离</p>
<blockquote>
<p>为了保证 安全性 &amp; 独立性，一个进程 不能直接操作或者访问另一个进程，即Android的进程是相互独立、隔离的</p>
</blockquote>
</li>
<li>
<p>跨进程通信（ IPC ）</p>
<blockquote>
<p>即进程间需进行数据交互、通信</p>
</blockquote>
</li>
<li>
<p>跨进程通信的基本原理</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/061dff9688cb48d2f1fbb6a3d2e0b038-%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-98ac4b.svg" alt="跨进程通信基本原理" loading="lazy"></figure>
<h4 id="内存映射mmap">内存映射mmap</h4>
<p><code>mmap</code>是一种<strong>内存映射文件</strong>的方法，即<strong>将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</strong> 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用<code>read</code>,<code>write</code>等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<h3 id="binder到底是什么">Binder到底是什么？</h3>
<ul>
<li>中文即 粘合剂，意思为粘合了两个不同的进程</li>
<li>需要从不同的角度去看</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/47a83ac9213dc05510ac96abd35abcde-Binder%E6%98%AF%E4%BB%80%E4%B9%88-6634e3.svg" alt="Binder是什么" loading="lazy"></figure>
<h4 id="binder-跨进程通信机制-模型">Binder 跨进程通信机制 模型</h4>
<ul>
<li>Binder 跨进程通信机制 模型 基于 Client - Server 模式</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/cac5b18e137aa0e0157a7d51dd1a76f3-Binder%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E6%A8%A1%E5%9E%8B-fd77ab.png" alt="binder_cs.png" loading="lazy"></figure>
<p>模型组成角色说明</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/a034f6a21009072f7ad7b1acd2c5cf68-Binder%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E8%A7%92%E8%89%B2%E8%AF%B4%E6%98%8E-87985d.png" alt="binder_proc.png" loading="lazy"></figure>
<h4 id="binder驱动的作用-原理">Binder驱动的作用 &amp; 原理</h4>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/01d62af6f5ce296329782cae1b99a40d-Binder%E9%A9%B1%E5%8A%A8-4d23b0.svg" alt="Binder驱动.svg" loading="lazy"></figure>
<ul>
<li>跨进程通信的核心原理</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/2f8331d74a12e7ce9869c1f126450a16-Binder%E9%80%9A%E4%BF%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-f552dc.png" alt="binder_work.png" loading="lazy"></figure>
<ul>
<li>模型原理步骤说明</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/0750bc30e4595f0a396d77d72b5ae039-Binder%E6%A0%B8%E5%BF%83%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E6%AD%A5%E9%AA%A4%E8%AF%B4%E6%98%8E-e42259.png" alt="binder_work_liucheng.png" loading="lazy"></figure>
<h4 id="注意">注意</h4>
<p>说明1：Client进程、Server进程 &amp; Service Manager 进程之间的交互 都必须通过Binder驱动（使用 open 和 ioctl文件操作函数），而非直接交互 原因：</p>
<ol>
<li>Client进程、Server进程 &amp; Service Manager进程属于进程空间的用户空间，不可进行进程间交互</li>
<li>Binder驱动 属于 进程空间的 内核空间，可进行进程间 &amp; 进程内交互</li>
</ol>
<p>所以，原理图可表示为以下：</p>
<blockquote>
<p>虚线表示并非直接交互</p>
</blockquote>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/8d1394e3d34347df5f25b8edeadcb97f-Binder%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86%E5%9B%BE-ce3e7f.png" alt="binder_yuanli.png" loading="lazy"></figure>
<p>说明2： Binder驱动 &amp; Service Manager进程 属于 Android基础架构（即系统已经实现好了）；而Client 进程 和 Server 进程 属于Android应用层（需要开发者自己实现） 所以，在进行跨进程通信时，开发者只需自定义Client &amp; Server 进程 并 显式使用上述3个步骤，最终借助 Android的基本架构功能就可完成进程间通信</p>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/f39430084d6be6162454436eb499376d-Android%E6%9E%B6%E6%9E%84binder%E9%80%9A%E4%BF%A1%E5%9B%BE-da3449.png" alt="binder_yuanli1.png" loading="lazy"></figure>
<p>说明3：Binder请求的线程管理 Server进程会创建很多线程来处理Binder请求 Binder模型的线程管理 采用Binder驱动的线程池，并由Binder驱动自身进行管理</p>
<blockquote>
<p>而不是由Server进程来管理的</p>
</blockquote>
<p>一个进程的Binder线程数默认最大是16，超过的请求会被阻塞等待空闲的Binder线程。</p>
<blockquote>
<p>所以，在进程间通信时处理并发问题时，如使用ContentProvider时，它的CRUD（创建、检索、更新和删除）方法只能同时有16个线程同时工作</p>
</blockquote>
<h3 id="binder机制-在android中的具体实现原理">Binder机制 在Android中的具体实现原理</h3>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/27/96134364cd18b64284736fb7976c2322-Binder%E6%9C%BA%E5%88%B6%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E5%8E%9F%E7%90%86-020a3f.webp" alt="java_binder.webp" loading="lazy"></figure>
<ul>
<li>IMyService接口由 AIDL 文件生成；</li>
<li>Stub 和 Proxy 则是IMyService的内部类，分别是 Binder 类和 BinderProxy 类的子类（Proxy 类虽然是用组合方式来持有 BinderProxy 的，但实际就是在直接用这个类，只不过做了一层封装，让其更易使用而已），Stub 和 Proxy 都实现了 IMyService；</li>
<li>IMyService是一个用于表达 Service 提供的功能的一个契约，也就是说 IInterface 里有的方法，Service 都能提供，调用者你别管用的是 BinderProxy 还是什么，只要拿到 IInterface，你就可以直接调用里面的方法，它就是一个接口；</li>
<li>同时 Stub 虽然实现了 IMyService，但是并没有实现厘米的任何方法，它是一个抽象类，开发者需要自己子类化 Stub 去实现具体的功能；</li>
<li>Proxy 实现了 IMyService，并且实现了里面的方法；</li>
<li>为什么 IMyService 要分 Stub 和 Proxy 呢？这是为了要适用于本地调用和远程调用两种情况。如果 Service 运行在同一个进程，那就直接用 Stub，因为它直接实现了 Service 提供的功能，不需要任何 IPC 过程。如果 Service 运行在其他进程，那客户端使用的就是 Proxy，这里这个 Proxy 的功能大家应该能想到了吧，就是把参数封装后发送给 Binder 驱动，然后执行一系列 IPC 操作最后再取出结果返回。</li>
<li>Stub 是继承自 Binder 并重写了onTransact函数，这个函数三个重要参数：int code、Parcel data、Parcel reply，分别对应了被调函数编号、参数包、响应包。当 Proxy 发起了一个请求，服务端中相应的响应线程就会通过 JNI 调用到 Stub 类，然后执行里面的 execTransact 方法，进而转到 onTransact 方法。</li>
</ul>
<h3 id="为什么android-要使用-binder">为什么Android 要使用 Binder ？</h3>
<p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于性能、稳定性和安全性几方面的原因。</p>
<h4 id="性能">性能</h4>
<ol>
<li>Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。</li>
<li>消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。</li>
<li>共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</li>
</ol>
<table>
<thead>
<tr>
<th>IPC方式</th>
<th style="text-align:center">数据拷贝次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享内存</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>Binder</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>Socket/管道/消息队列</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<h4 id="稳定性">稳定性</h4>
<p>Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h4 id="安全性">安全性</h4>
<p>Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。</p>
<ol>
<li>传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。</li>
<li>传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。</li>
<li>传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</li>
</ol>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<table>
<thead>
<tr>
<th>优势</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td style="text-align:center">只需要一次数据拷贝，性能上仅次于共享内存</td>
</tr>
<tr>
<td>稳定性</td>
<td style="text-align:center">基于C/S架构，职责明确、架构清晰，因此稳定性好</td>
</tr>
<tr>
<td>安全性</td>
<td style="text-align:center">为每个App分配UID，进程的UID是鉴别进程身份的重要标志</td>
</tr>
</tbody>
</table>
<h3 id="binder-通信中的代理模式">Binder 通信中的代理模式</h3>
<p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AIDL文件编写及源码分析]]></title>
        <id>https://jxiaow.gitee.io/posts/40026fc8/</id>
        <link href="https://jxiaow.gitee.io/posts/40026fc8/">
        </link>
        <updated>2021-01-30T14:38:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="aidl编写">AIDL编写</h2>
<p>Binder被用来实现进程间的通信，基本使用步骤如下：</p>
<ol>
<li>创建AIDL文件，编写接口方法；</li>
<li>如果有自定义的model对象，则在aidl下创建包名一致且名称与model名一致的aidl文件；</li>
<li>make project</li>
<li>编写相应的代码，启动服务发送和接收数据。</li>
</ol>
<p>具体操作：</p>
<p><strong>以下例子来源于 <a href="https://gitee.com/jxiaow/practiseCodeAndroid/tree/master/FrameWork/BinderSample">FrameWork/BinderSample</a></strong></p>
<h3 id="创建model对象">创建model对象</h3>
<p><code>Person</code> 实现 <code>Parcelable</code> 接口 （如果不需要自定义model，则不需要）</p>
<pre><code class="language-java">package com.github.jxiaow.sample.model;
import android.os.Parcel;
import android.os.Parcelable;
 
public class Personal implements Parcelable {
   public String name;
   public int age;
 
   public Personal(String name, int age) {
      this.name = name;
      this.age = age;
   }
   // .....
}
</code></pre>
<h3 id="创建aidl文件">创建AIDL文件</h3>
<p>如果有自定义model对象并且与AIDL接口文件的包名不一致时需要创建一个<code>AIDL</code>文件表示</p>
<pre><code class="language-java">// IPersonal.aidl
// 包名必须与model的一致
package com.github.jxiaow.sample.model;
 
// Declare any non-default types here with import statements
// 自定义的model需要使用parcelable进行声明
parcelable Personal;
</code></pre>
<p>编写AIDL接口文件</p>
<pre><code class="language-java">// ILeoAidl.aidl
package com.github.jxiaow.sample;
// Declare any non-default types here with import statements
// 导入model对应的aidl文件
import com.github.jxiaow.sample.model.IPersonal;
 
interface IPersonalAidlInterface {
    // 自己定义的model 需要添加in修饰
    void addPersonal(in Personal person);
    List&lt;Personal&gt; getPersonalList();
}
</code></pre>
<h3 id="make-project">make project</h3>
<p>通过Android studio 的 make project 后生成java版本的aidl接口类。代码结构：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/28/0e5e4f7da463171b64417ed0ba4492d8-image-20210128112830363-ea556a.png" alt="image-20210128112830363" loading="lazy"></figure>
<p>生成的重要部分代码如下：</p>
<pre><code class="language-java">package com.github.jxiaow.sample;
 
public interface IPersonalAidlInterface extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     * Stub 用于数据服务接收端，该抽象方法由服务接收端实现
     *  通过asInterface 返回一个proxy给数据发送端
     */
    public static abstract class Stub extends android.os.Binder
           implements com.github.jxiaow.sample.IPersonalAidlInterface {
        // 通过该字段区分binder
        private static final java.lang.String DESCRIPTOR =
            &quot;com.github.jxiaow.sample.IPersonalAidlInterface&quot;;
 
        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }
 
        /**
         * Cast an IBinder object into an com.github.jxiaow.sample.IPersonalAidlInterface interface,
         * generating a proxy if needed.
         */
        public static com.github.jxiaow.sample.IPersonalAidlInterface asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            // 如果服务端和客户端不在同一进程，那么obj.queryLocalInterface(DESCRIPTOR)为null
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof com.github.jxiaow.sample.IPersonalAidlInterface))) {
                return ((com.github.jxiaow.sample.IPersonalAidlInterface) iin);
            }
            // 返回一个服务端代理，用于客户端远程调用服务端的方法
            return new com.github.jxiaow.sample.IPersonalAidlInterface.Stub.Proxy(obj);
        }
 
        @Override
        public android.os.IBinder asBinder() {
            return this;
        }
        // onTransact 复写了Binder中的onTransact
        // 客户端调用代理执行相应的方法后会调用到服务端的此方法上进行相应的方法调用
        // 数据发送端proxy调用transact后通过binder会调用stub的onTransact
        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
                    throws android.os.RemoteException {
            java.lang.String descriptor = DESCRIPTOR;
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(descriptor);
                    return true;
                }
                case TRANSACTION_addPersonal: {
                    data.enforceInterface(descriptor);
                    com.github.jxiaow.sample.model.Personal _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = com.github.jxiaow.sample.model.Personal.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    this.addPersonal(_arg0);
                    reply.writeNoException();
                    return true;
                }
                case TRANSACTION_getPersonalList: {
                    data.enforceInterface(descriptor);
                    java.util.List&lt;com.github.jxiaow.sample.model.Personal&gt; _result = this.getPersonalList();
                    reply.writeNoException();
                    reply.writeTypedList(_result);
                    return true;
                }
                default: {
                    return super.onTransact(code, data, reply, flags);
                }
            }
        }
        // 代理静态内部类，用于发送数据到服务端
        private static class Proxy implements com.github.jxiaow.sample.IPersonalAidlInterface {
            private android.os.IBinder mRemote;
 
            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }
 
            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }
 
            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }
 
            @Override
            public void addPersonal(com.github.jxiaow.sample.model.Personal person)
                throws android.os.RemoteException {
                // _data 是发送的数据
                // _reply 接收的数据              
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    if ((person != null)) {
                        _data.writeInt(1);
                        person.writeToParcel(_data, 0);
                    } else {
                        _data.writeInt(0);
                    }
                    // mRemote.transact方法会调用到服务端的onTransact，然后进行方法标记分发
                    boolean _status = mRemote.transact(Stub.TRANSACTION_addPersonal, _data, _reply, 0);
                    if (!_status &amp;&amp; getDefaultImpl() != null) {
                        getDefaultImpl().addPersonal(person);
                        return;
                    }
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
 
            @Override
            public java.util.List&lt;com.github.jxiaow.sample.model.Personal&gt; getPersonalList()
                throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                java.util.List&lt;com.github.jxiaow.sample.model.Personal&gt; _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    boolean _status = mRemote.transact(Stub.TRANSACTION_getPersonalList, _data, _reply, 0);
                    if (!_status &amp;&amp; getDefaultImpl() != null) {
                        return getDefaultImpl().getPersonalList();
                    }
                    _reply.readException();
                    _result = _reply.createTypedArrayList(com.github.jxiaow.sample.model.Personal.CREATOR);
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }
 
            public static com.github.jxiaow.sample.IPersonalAidlInterface sDefaultImpl;
        }
        // 每个方法的标志
        static final int TRANSACTION_addPersonal = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_getPersonalList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
 
    }
 
    // 此方法有继承自Stub的子类实现
    public void addPersonal(com.github.jxiaow.sample.model.Personal person)
        throws android.os.RemoteException;
 
    public java.util.List&lt;com.github.jxiaow.sample.model.Personal&gt; getPersonalList()
        throws android.os.RemoteException;
}
</code></pre>
<h3 id="客户端使用">客户端使用</h3>
<pre><code class="language-java">// 8.0 以后，不允许service后台运行，所以如果将service至于后台，bindService会报错
// W/ActivityManager: Unable to start service Intent
// { cmp=com.github.jxiaow.binderservice/.MyService } U=0: not found
val intent = Intent()
intent.setClassName(
    &quot;com.github.jxiaow.binderservice&quot;,
    &quot;com.github.jxiaow.binderservice.MyService&quot;
)
bindService(intent, conn, Context.BIND_AUTO_CREATE)
</code></pre>
<p>通过asInterface 获取使用。</p>
<pre><code class="language-java">private val conn = object : ServiceConnection {
    override fun onServiceConnected(name: ComponentName, service: IBinder) {
        Log.d(&quot;Personal&quot;, &quot;onServiceConnected: &quot;)
        personalInterface = IPersonalAidlInterface.Stub.asInterface(service)
    }
 
    override fun onServiceDisconnected(name: ComponentName) {
        personalInterface = null
    }
}
</code></pre>
<h2 id="源码分析流程">源码分析流程</h2>
<blockquote>
<p>源码基于API 30</p>
</blockquote>
<h3 id="activitybindservice">Activity#bindService</h3>
<p>在<code>Acitivity</code>中绑定或启动<code>Service</code>时，经常会使用下面的方式，我们就以下面的方式进行源码调用分析。</p>
<pre><code class="language-kotlin">val intent = Intent(this, PersonalService::class.java)
bindService(intent, conn, Context.BIND_AUTO_CREATE)
</code></pre>
<h3 id="contextwrapperbindservice">ContextWrapper#bindService</h3>
<pre><code class="language-java">@Override
public boolean bindService(Intent service, ServiceConnection conn, int flags) {
    return mBase.bindService(service, conn, flags);
}
</code></pre>
<p>以上方法中调用了<code>mBase.bindService</code>，而我们可以知道<code>mBase</code>就是<code>ContextImpl</code>的实例。</p>
<h3 id="contextimplbindservice">ContextImpl#bindService</h3>
<pre><code class="language-java">@Override
public boolean bindService(Intent service, ServiceConnection conn, int flags) {
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, null, mMainThread.getHandler(), null, getUser());
}
</code></pre>
<h3 id="contextimplbindservicecommon">ContextImpl#bindServiceCommon</h3>
<p><code>bindServiceCommon</code>通过<code>ActivityManagerService</code>进行<code>Service</code>的相关操作。</p>
<pre><code class="language-java">private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,
                                  String instanceName, Handler handler, Executor executor, UserHandle user) {
        // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.
        // ....
        try {
            IBinder token = getActivityToken();
            if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null
                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion
                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                flags |= BIND_WAIVE_PRIORITY;
            }
            service.prepareToLeaveProcess(this);
            // 重点, 此处调用了ActivityManagerService中的方法
            // 用于service的相关生命周期处理
            int res = ActivityManager.getService().bindIsolatedService(
                mMainThread.getApplicationThread(), getActivityToken(), service,
                service.resolveTypeIfNeeded(getContentResolver()),
                sd, flags, instanceName, getOpPackageName(), user.getIdentifier());
            if (res &lt; 0) {
                throw new SecurityException(
                    &quot;Not allowed to bind to service &quot; + service);
            }
            return res != 0;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
}
</code></pre>
<h3 id="activitymanagergetservice">ActivityManager#getService</h3>
<pre><code class="language-java">// 获取一个IActivityManager AIDL接口实现proxy实例
// 由于android 8.0 采用的AIDL模板生成代码的方式，无法在Andorid Studio中看到生成的代码Proxy
// 返回一个单例 ActivityMangerService的Binder代理类
@UnsupportedAppUsage
public static IActivityManager getService() {
    return IActivityManagerSingleton.get();
}
 
@UnsupportedAppUsage
private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =
    new Singleton&lt;IActivityManager&gt;() {
    @Override
    protected IActivityManager create() {
        // 通过ServiceManager获取IActivityManager服务端（ActivityManagerService)的代理类
        final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
        // 通过Stub.asInterface 获取AIDL接口生成代码中的proxy实例
        // 此处获取的就是AIDL中的proxy, 如果有疑问，去看一下前面的创建AIDL文件处的代码
        final IActivityManager am = IActivityManager.Stub.asInterface(b);
        return am;
    }
};
</code></pre>
<p>具体的解析，请看上面代码中的注释，<code>ActivityManager.getService()</code>获取到的是一个<code>IActivityManagerService</code>的代理类。</p>
<pre><code class="language-java">public class ActivityManagerService extends IActivityManager.Stub
       implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback{}
</code></pre>
<h3 id="activitymanagerservicebindisolatedservice">ActivityManagerService#bindIsolatedService</h3>
<pre><code class="language-java">public int bindIsolatedService(IApplicationThread caller, IBinder token, Intent service,
                            String resolvedType, IServiceConnection connection,
                            int flags, String instanceName,
                            String callingPackage, int userId)
    throws TransactionTooLargeException {
     // ....
     synchronized(this) {
         return mServices.bindServiceLocked(caller, token, service,
              resolvedType, connection, flags, instanceName, callingPackage, userId);
     }
}
</code></pre>
<h3 id="activieservicebindservicelocked">ActivieService#bindServiceLocked</h3>
<p>如果service已经存在则直接绑定，如果不存在则先创建然后再绑定</p>
<pre><code class="language-java">int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,
                      String resolvedType, final IServiceConnection connection, int flags,
                      String instanceName, String callingPackage, final int userId)
    throws TransactionTooLargeException {
    // ....
    final boolean callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
    final boolean isBindExternal = (flags &amp; Context.BIND_EXTERNAL_SERVICE) != 0;
    final boolean allowInstant = (flags &amp; Context.BIND_ALLOW_INSTANT) != 0;
    // 获取Service信息缓存(serivceInfo)，如果缓存不存在则创建
    // 如果启动一个未启动的service，那么此处是没有缓存的
    // 如果启动的是一个已经启动了的service，那么缓存是存在的
    ServiceLookupResult res =
        retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,
                              Binder.getCallingPid(), Binder.getCallingUid(), userId, true,
                              callerFg, isBindExternal, allowInstant);
    if (res == null) {
        return 0;
    }
    if (res.record == null) {
        return -1;
    }
    ServiceRecord s = res.record;
    final long origId = Binder.clearCallingIdentity();
    try {
        // ....
        if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) {
            s.lastActivity = SystemClock.uptimeMillis();
            // 创建和绑定service
            if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,
                                     permissionsReviewRequired) != null) {
                return 0;
            }
        }
        // 由于service的创建最终是通过handler转发的，那么创建的时间一般情况下会晚于下面的代码执行
        // b.intent.received 未执行绑定操作时，默认情况下是 false,  publishService中置为true
        if (s.app != null &amp;&amp; b.intent.received) {
            // Service is already running, so we can immediately
            // publish the connection.
            try {
                // 调用的是ServiceDispatcher中的相关方法间接调用onServiceConnection
                c.conn.connected(s.name, b.intent.binder, false);
            } catch (Exception e) {
                Slog.w(TAG, &quot;Failure sending service &quot; + s.shortInstanceName
                       + &quot; to connection &quot; + c.conn.asBinder()
                       + &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);
            }
 
            // If this is the first app connected back to this binding,
            // and the service had previously asked to be told when
            // rebound, then do so.
            // b.intnet.doRebind 默认是false
            if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) {
                // 检查是否需要重新绑定
                requestServiceBindingLocked(s, b.intent, callerFg, true);
            }
        } 
        // 默认是false,绑定成功后为true，
        // 如果bringUpServiceLocked能执行到realStartService中,则b.intent.requested = true
        else if (!b.intent.requested) { 
            // 请求绑定service
            requestServiceBindingLocked(s, b.intent, callerFg, false);
        }
        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);
    }
    // ...
    return 1;
}
</code></pre>
<h3 id="activieservicebringupservicelocked">ActivieService#bringUpServiceLocked</h3>
<p><code>bringUpServiceLocked</code>中 先判断<code>service</code>是否已经创建，如果创建调用<code>sendServiceArgsLocked</code>方法进行相关操作，否则</p>
<p>调用<code>realStartServiceLocked</code>进行<code>service</code>创建和绑定。</p>
<pre><code class="language-java">private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,
                                    boolean whileRestarting, boolean permissionsReviewRequired)
    throws TransactionTooLargeException {
    // 如果service已经启动调用sendServiceArgsLocked方法通过远程服务执行onStartCommon
    if (r.app != null &amp;&amp; r.app.thread != null) {
        sendServiceArgsLocked(r, execInFg, false);
        return null;
    }
    // ....
    // 判断每次启动Service时是否需要独立开启一个进程，此属性是通过 android:isolatedProcess=&quot;false&quot; 设置
    // 默认false
    final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
    if (!isolated) {
        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
        if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid
                             + &quot; app=&quot; + app);
        // 启动服务的app是否为null
        if (app != null &amp;&amp; app.thread != null) {
            try {
                app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);
                // 重点, 创建并绑定service
                // 此方法
                realStartServiceLocked(r, app, execInFg);
                return null;
            }
            // ...
        }
    }
    // ....
    return null;
}
</code></pre>
<h3 id="activieservicesendserviceargslocked">ActivieService#sendServiceArgsLocked</h3>
<pre><code class="language-java">private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,
                                         boolean oomAdjusted) throws TransactionTooLargeException {
    // r.pendingStarts在service执行完onStartCommon后为空
    // 在startServiceLocked中添加service到pendingStarts中 （startService方式启动service）
    // 在realStartServiceLocked中也会添加 (bindService 方式启动service)
    final int N = r.pendingStarts.size();
    // 此处可以判断可以说明 onStartCommon只会执行一次
    if (N == 0) {
        return;
    }
    // ...
    ParceledListSlice&lt;ServiceStartArgs&gt; slice = new ParceledListSlice&lt;&gt;(args);
    slice.setInlineCountLimit(4);
    Exception caughtException = null;
    try {
        // 调用 applicationThread中的scheduleServiceArgs
        r.app.thread.scheduleServiceArgs(r, slice);
    }
    // ...
}
</code></pre>
<h3 id="acitivieservicerealstartservicelocked">AcitivieService#realStartServiceLocked</h3>
<p><code>realStartServiceLocked</code>方法中主要完成了2件事：1. 在<code>ApplicationThread</code>中调用<code>scheduleCreateService</code>进行 Service的创建；2. 请求绑定Service。</p>
<pre><code class="language-java">private final void realStartServiceLocked(ServiceRecord r,
                                          ProcessRecord app, boolean execInFg) throws RemoteException {
    // ....
    boolean created = false;
    try {
        //....
        // app.thread ===&gt; ApplicationThread
        // 1. AplicationThread 创建Service
        app.thread.scheduleCreateService(r, r.serviceInfo,
                                         mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),
                                         app.getReportedProcState());
        r.postNotification();
        created = true;
    }
    // ....
    // 2. 请求绑定Service
    requestServiceBindingsLocked(r, execInFg);
 
    // 3. 如果是startService方式，service恢复时调用onStartCommon方法
    // 正好验证了bindService() 不会调用onStartCommon方法
    // If the service is in the started state, and there are no
    // pending arguments, then fake up one so its onStartCommand() will
    // be called.
    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) {
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                                                        null, null, 0));
    }
    sendServiceArgsLocked(r, execInFg, true);
}
</code></pre>
<h3 id="activitythreadhandlecreateservice">ActivityThread#handleCreateService</h3>
<p>在<code>AcitivieService#realStartServiceLocked()</code>中调用<code>ApplicationThread#scheduleCreateService</code>后，<code>scheduleCreateService</code> 通过Handler发送what为<code>CREATE_SERVICE</code>的事件，然后在会调用<code>ActivityThread#handlerCreateService</code>进行Service 创建。</p>
<pre><code class="language-java">// 创建Service
@UnsupportedAppUsage
private void handleCreateService(CreateServiceData data) {
    // If we are getting ready to gc after going to the background, well
    // we are back active so skip it.
    unscheduleGcIdler();
    LoadedApk packageInfo = getPackageInfoNoCheck(
        data.info.applicationInfo, data.compatInfo);
    // 反射创建
    Service service = null;
    try {
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        service = packageInfo.getAppFactory()
            .instantiateService(cl, data.info.name, data.intent);
    } catch (Exception e) {
    }
    try {
        // ....
        // 调用service的onCreate
        service.onCreate();
        mServices.put(data.token, service);
       // ...
    } catch (Exception e) {
        // ....
    }
}
</code></pre>
<h3 id="activitythreadhandlebindservice">ActivityThread#handleBindService</h3>
<p>在<code>AcitivieService#realStartServiceLocked</code>中Service创建成功后，会调用<code>requestServiceBindingsLocked</code>进行Service的绑定，最终调用到<code>ActivityThread#handleBindService</code>。</p>
<pre><code class="language-java">// 绑定Service
private void handleBindService(BindServiceData data) {
    Service s = mServices.get(data.token);
    // ...
    if (s != null) {
        try {
            data.intent.setExtrasClassLoader(s.getClassLoader());
            data.intent.prepareToEnterProcess();
            try {
                if (!data.rebind) {
                    // onBind方法返回binder
                    IBinder binder = s.onBind(data.intent);
                    // 调用activityManagerService 的publishService
                    // 调用ServiceConnection的conn
                    ActivityManager.getService().publishService(
                        data.token, data.intent, binder);
                } else {
                    // 重新绑定
                    s.onRebind(data.intent);
                    ActivityManager.getService().serviceDoneExecuting(
                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
                }
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        } catch (Exception e) {
            // ....
        }
    }
}
</code></pre>
<h3 id="activitymanagerservicepublishservice">ActivityManagerService#publishService</h3>
<pre><code class="language-java">public void publishService(IBinder token, Intent intent, IBinder service) {
    // ...
    synchronized(this) {
        if (!(token instanceof ServiceRecord)) {
            throw new IllegalArgumentException(&quot;Invalid service token&quot;);
        }
        mServices.publishServiceLocked((ServiceRecord)token, intent, service);
    }
}
</code></pre>
<h3 id="activeservicespublishservicelocked">ActiveServices#publishServiceLocked</h3>
<ol>
<li>通过<code>intent</code>进行过滤获取<code>IntentBindRecord</code>并对<code>request</code>、<code>received</code>赋值为true；</li>
<li>遍历<code>connections</code>，调用<code>c.conn.connected</code>。</li>
</ol>
<pre><code class="language-java">void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) {
    final long origId = Binder.clearCallingIdentity();
    try {
        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;PUBLISHING &quot; + r
                                  + &quot; &quot; + intent + &quot;: &quot; + service);
        if (r != null) {
            // 通过intent过滤获取IntentBindRecord
            Intent.FilterComparison filter
                = new Intent.FilterComparison(intent);
            IntentBindRecord b = r.bindings.get(filter);
            if (b != null &amp;&amp; !b.received) {
                b.binder = service;
                b.requested = true;
                b.received = true;
                ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();
                for (int conni = connections.size() - 1; conni &gt;= 0; conni--) {
                    ArrayList&lt;ConnectionRecord&gt; clist = connections.valueAt(conni);
                    for (int i=0; i&lt;clist.size(); i++) {
                        ConnectionRecord c = clist.get(i);
                        // ...
                        try {
                            c.conn.connected(r.name, service, false);
                        } catch (Exception e) {
                            // ...
                        }
                    }
                }
            }
            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);
        }
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
}
</code></pre>
<h3 id="contextimplbindservicecommon-2">ContextImpl#bindServiceCommon</h3>
<p>前面对<code>service</code>启动和绑定的分析完毕后，在来看看是如何回调<code>ServiceConnection</code>的相关方法的。</p>
<pre><code class="language-java">private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,
                                  String instanceName, Handler handler, Executor executor, UserHandle user) {
    // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.
    IServiceConnection sd;
    ....
        if (mPackageInfo != null) {
            if (executor != null) {
                // IServiceConnection 来源
                sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);
            } else {
                sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);
            }
        } else {
            throw new RuntimeException(&quot;Not supported in system context&quot;);
        }
    ....
}
</code></pre>
<h3 id="loadapkgetservicedispatchercommon">LoadApk#getServiceDispatcherCommon</h3>
<p>创建<code>ServiceDispatcher</code>（对ServiceConnect实例进行包装和增强）。</p>
<pre><code class="language-java">private IServiceConnection getServiceDispatcherCommon(ServiceConnection c,
                                                      Context context, Handler handler,
                                                      Executor executor, int flags) {
    synchronized (mServices) {
        ....
            if (sd == null) {
                if (executor != null) {
                    sd = new ServiceDispatcher(c, context, executor, flags);
                } else {
                    sd = new ServiceDispatcher(c, context, handler, flags);
                }
                if (DEBUG) Slog.d(TAG, &quot;Creating new dispatcher &quot; + sd + &quot; for conn &quot; + c);
                if (map == null) {
                    map = new ArrayMap&lt;&gt;();
                    mServices.put(context, map);
                }
                map.put(c, sd);
            } else {
                sd.validate(context, handler, executor);
            }
        return sd.getIServiceConnection();
    }
}
</code></pre>
<pre><code class="language-java">@UnsupportedAppUsage
ServiceDispatcher(ServiceConnection conn,
                  Context context, Handler activityThread, int flags) {
    // connection的实际类型
    mIServiceConnection = new InnerConnection(this);
    mConnection = conn;
    mContext = context;
    mActivityThread = activityThread;
    mActivityExecutor = null;
    mLocation = new ServiceConnectionLeaked(null);
    mLocation.fillInStackTrace();
    mFlags = flags;
}
</code></pre>
<h3 id="innerconnection">InnerConnection</h3>
<p><code>InnerConnection</code>继承自 <code>AIDL</code>中生成的<code>Stub</code>类。</p>
<pre><code class="language-java">private static class InnerConnection extends IServiceConnection.Stub {
    @UnsupportedAppUsage
    final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;
 
    InnerConnection(LoadedApk.ServiceDispatcher sd) {
        mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);
    }
 
    public void connected(ComponentName name, IBinder service, boolean dead)
        throws RemoteException {
        LoadedApk.ServiceDispatcher sd = mDispatcher.get();
        if (sd != null) {
            sd.connected(name, service, dead);
        }
    }
}
</code></pre>
<pre><code class="language-java">public void connected(ComponentName name, IBinder service, boolean dead) {
    if (mActivityExecutor != null) {
        mActivityExecutor.execute(new RunConnection(name, service, 0, dead));
    } else if (mActivityThread != null) {
        mActivityThread.post(new RunConnection(name, service, 0, dead));
    } else {
        doConnected(name, service, dead);
    }
}
</code></pre>
<pre><code class="language-java">public void doConnected(ComponentName name, IBinder service, boolean dead) {
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
 
    // ....
    // If there was an old service, it is now disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    if (dead) {
        mConnection.onBindingDied(name);
    }
    // If there is a new viable service, it is now connected.
    if (service != null) {
        // 回调定义的onServiceConnected 方法
        mConnection.onServiceConnected(name, service);
    } else {
        // The binding machinery worked, but the remote returned null from onBind().
        mConnection.onNullBinding(name);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Handler机制]]></title>
        <id>https://jxiaow.gitee.io/posts/5daabb/</id>
        <link href="https://jxiaow.gitee.io/posts/5daabb/">
        </link>
        <updated>2021-01-27T10:03:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="handler的作用">handler的作用</h2>
<ol>
<li>与前端的ajax有异曲同工之妙；</li>
<li>使得Android开发难度大大降低；</li>
<li>几乎看不到线程死锁的问题。</li>
</ol>
<h2 id="线程通信开发中存在的问题">线程通信开发中存在的问题？</h2>
<h3 id="线程间如何通讯">线程间如何通讯？</h3>
<blockquote>
<p>Handler 通信实际采用的是内存共享方案</p>
</blockquote>
<h3 id="为什么线程间通信不会干扰">为什么线程间通信不会干扰？</h3>
<blockquote>
<p>内存管理设计思路优秀</p>
</blockquote>
<h3 id="为什么wait和notify用武之地不大">为什么wait和notify用武之地不大？</h3>
<blockquote>
<p>handler已经将需要的这部分功能进行了Linux层的封装</p>
</blockquote>
<h2 id="handle消息机制模型">Handle消息机制模型</h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/25/cdc2253fd297966ac6d47656ded7ca41-1600148470244-3ed87e98-231f-4b6d-8c1c-4b24ae88e22d-db1d4d.png" alt="20200629140531178png" loading="lazy"></figure>
<ul>
<li><code>Handler</code>通过<code>sendMessage()</code>发送消息，然后通过<code>enqueueMessage</code>将消息添加到消息队列<code>MessageQueue</code>中；</li>
<li><code>Looper</code>负责去遍历消息队列并且将队列中消息分发给对应的<code>Handler</code>去处理；</li>
<li>在<code>Handler</code>的<code>handleMessage</code>方法中处理该消息，这就完成了一个消息的发送和处理过程。</li>
</ul>
<p>从图中可以看到参与消息处理有四个对象，它们分别是 <strong>Handler</strong>,<strong>Message</strong>, <strong>MessageQueue</strong>，<strong>Looper</strong>。</p>
<h2 id="handler源码分析">Handler源码分析</h2>
<blockquote>
<p>源码基于API 30</p>
</blockquote>
<h3 id="threadloacal">ThreadLoacal</h3>
<p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定的线程中可以获取到存储数据，对于其他线程来说则无法获取到数据。</p>
<h3 id="handler">handler</h3>
<ol>
<li>
<p>如何实现线程间跨越的？</p>
</li>
<li>
<p>Handler是如何管理那块共享的内存的？</p>
</li>
</ol>
<h4 id="启动app时创建全局唯一的looper对象和全局唯一的messagequeue对象">启动App时，创建全局唯一的Looper对象和全局唯一的MessageQueue对象</h4>
<p>在<code>main</code>方法中调用<code>Looper.prepareMainLooper()</code>创建<code>Looper</code>对象和<code>MessageQueue</code>对象，并将其绑定到一起。然后调用<code>Looper.loop()</code>循环遍历取出消息并处理。</p>
<pre><code class="language-java">public static void main(String[] args) {
    // ...
    Looper.prepareMainLooper();
    // ...
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    // ...
    Looper.loop();
    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre>
<pre><code class="language-java">public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}
</code></pre>
<pre><code class="language-java">private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre>
<pre><code class="language-java">private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre>
<h4 id="activity中创建handler">Activity中创建handler</h4>
<p>在<code>Handler</code>的构造方法中，新版本中创建一个<code>Handler</code>对象时需要传递Looper对象，在使用的过程中会调用<code>Looper.getMainLooper()</code>获取Looper对象。这就避免了无法在子线程中创建Handler实例的问题。</p>
<pre><code class="language-java">public Handler(@NonNull Looper looper) {
   this(looper, null, false);
}
</code></pre>
<pre><code class="language-java">public Handler(@NonNull Looper looper, @Nullable Callback callback) {
   this(looper, callback, false);
}
</code></pre>
<pre><code class="language-java">/*
 * @hide
 *  此方法源码隐藏，不对外提供调用
 */
@UnsupportedAppUsage
public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) {
   mLooper = looper;
   mQueue = looper.mQueue;
   mCallback = callback;
   mAsynchronous = async;
}
</code></pre>
<h4 id="通过handler发送消息">通过handler发送消息</h4>
<p>通过handler发送消息时，回调用<code>sendXXX()</code>系列方法，如<code>sendMessage()</code>，通过方法调用跟踪发现，最终会调用到<code>enqueuMessage()</code>将消息压入到<code>MessageQueue</code>中。</p>
<pre><code class="language-java">public final boolean sendMessage(@NonNull Message msg) {
   return sendMessageDelayed(msg, 0);
}
</code></pre>
<pre><code class="language-java">public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {
    if (delayMillis &lt; 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
</code></pre>
<pre><code class="language-java">public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {
   MessageQueue queue = mQueue;
   if (queue == null) {
       RuntimeException e = new RuntimeException(
           this + &quot; sendMessageAtTime() called with no mQueue&quot;);
       Log.w(&quot;Looper&quot;, e.getMessage(), e);
       return false;
    }
   return enqueueMessage(queue, msg, uptimeMillis);
}
</code></pre>
<pre><code class="language-java">private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
            long uptimeMillis) {
  msg.target = this;
  msg.workSourceUid = ThreadLocalWorkSource.getUid();

  if (mAsynchronous) {
       msg.setAsynchronous(true);
  }
  return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<h4 id="消息处理">消息处理</h4>
<p>在对<code>Looper</code>创建时，了解到<code>ActivityThread#main()</code>中会调用<code>Looper.loop()</code>处理消息。</p>
<pre><code class="language-java">// Looper.java
public static void loop() {
   // 从sThreadLocal中获取Looper对象
   final Looper me = myLooper();
   // looper对象不能为空
   if (me == null) {
       throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
   }
   // ...
   // 从looper中获取MessageQueue
   final MessageQueue queue = me.mQueue;
   // ...
   for (;;) {
       // 从messageQueue中不断的获取消息，如果没有消息则堵塞，等待下一条消息将其唤醒
       Message msg = queue.next(); // might block
       if (msg == null) {
            // No message indicates that the message queue is quitting.
           return;
       }
       // ...
       try {
           // msg.target == handler
           // 获取到消息后，回调用handler的dispatchMessage()进行消息分发处理
           msg.target.dispatchMessage(msg);
       } 
       // ...
       // 最后将msg进行回收
       msg.recycleUnchecked();
   }
}
</code></pre>
<pre><code class="language-java">// Handler.java
public void dispatchMessage(@NonNull Message msg) {
   if (msg.callback != null) {
       handleCallback(msg);
   } else {
       if (mCallback != null) {
           if (mCallback.handleMessage(msg)) {
                return;
           }
        }
    handleMessage(msg);
   }
}
</code></pre>
<p>从<code>dispatchMessage</code>中可以看出处理消息的优先级是 1. msg.callback 2. handler.callback 3. handleMessage。</p>
<h4 id="消息阻塞和延时">消息阻塞和延时</h4>
<p>Looper的阻塞主要是靠MessageQueue来实现，在<code>MessageQueue#next()</code>时进行阻塞，在<code>MessageQueue#enqueueMessage()</code>进行唤醒。主要是依赖<code>navtive</code>层的<code>epoll</code>机制进行的。</p>
<pre><code class="language-java">@UnsupportedAppUsage
Message next() {
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre>
<p>阻塞和延时，主要是<code>next()</code>中<code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>调用 naive方法操作管道，由<code>nextPollTimeoutMillis</code>决定是否需要阻塞。 nextPollTimeoutMillis为0的时表示不阻塞，为 -1的时候表示一直阻塞直到被唤醒，其他时间表示延时。</p>
<h4 id="唤醒">唤醒</h4>
<p>消息处理的唤醒是在<code>MessageQueue#enqueueMessage()</code>中进行的。</p>
<pre><code class="language-java">boolean enqueueMessage(Message msg, long when) {
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
    }

    synchronized (this) {
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        }

        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(
                msg.target + &quot; sending message to a Handler on a dead thread&quot;);
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }

        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when &lt; p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
} 
</code></pre>
<p>就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。</p>
<p>这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<h4 id="延时入队列">延时入队列</h4>
<pre><code class="language-java">needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
Message prev;
for (;;) {
    prev = p;
    p = p.next;
    if (p == null || when &lt; p.when) {
        break;
    }
    if (needWake &amp;&amp; p.isAsynchronous()) {
       needWake = false;
    }
}
msg.next = p; // invariant: p == prev.next
prev.next = msg;
</code></pre>
<p>此处for死循环推出情况分两种</p>
<p>第一种：p==null表示对象池中已经运行到了最后一个，无需再循环。</p>
<p>第二种：碰到下一个消息when小于前一个，立马退出循环（不管对象池中所有message是否遍历完），进行从新排序。</p>
<h2 id="常见问题分析">常见问题分析</h2>
<ul>
<li>为什么不能在子线程中更新UI,根本原因是什么?</li>
</ul>
<pre><code class="language-java">// ViewRootImpl.java
void checkThread() {
   if (mThread != Thread.currentThread()) {
       throw new CalledFromWrongThreadException(
         &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);
   }
}
</code></pre>
<blockquote>
<p>mThread是UI线程，这里会检查当前线程是不是UI线程。那么为什么onCreate里面没有进行这个检查呢。这个问题原因出现在Activity的生命周期中，在onCreate方法中，UI处于创建过程，对用户来说界面还不可视，直到onStart方法后界面可视了，再到onResume方法后界面可以交互。从某种程度来讲，在onCreate方法中不能算是更新UI，只能说是配置UI，或者是设置UI的属性。这个时候不会调用到ViewRootImpl.checkThread()，因为ViewRootImpl没被创建。而在onResume方法后，ViewRootImpl才被创建。这个时候去交互界面才算是更新UI。</p>
</blockquote>
<blockquote>
<p>setContentView只是建立了View树，并没有进行渲染工作（其实真正的渲染工作是在onResume之后）。也正是建立了View树，因此我们可以通过findViewById（）来获取到View对象，但是由于并没有进行渲染视图的工作，也就是没有执行ViewRootImpl.performTransversal。同样View中也不会执行onMeasure（），如果在onResume（）方法里直接获取View.getHeight（）/View.getWidth（）得到的结果总是0。</p>
</blockquote>
<ul>
<li>为什么主线程用Looper死循环不会引发ANR异常?</li>
</ul>
<blockquote>
<p>简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制。</p>
</blockquote>
<ul>
<li>为什么Handler构造方法里面的Looper不是直接new？</li>
</ul>
<blockquote>
<p>如果在Handler构造方法里面new Looper，怕是无法保证保证Looper唯一，只有用Looper.prepare()才能保证唯一性。</p>
</blockquote>
<ul>
<li>MessageQueue为什么要放在Looper私有构造方法初始化？</li>
</ul>
<blockquote>
<p>因为一个线程只绑定一个Looper，所以在Looper构造方法里面初始化就可以保证mQueue也是唯一的Thread对应一个Looper 对应一个 mQueue。</p>
</blockquote>
<ul>
<li>Handler.post的逻辑在哪个线程执行的，是由Looper所在线程还是Handler所在线程决定的？</li>
</ul>
<blockquote>
<p>由Looper所在线程决定的。逻辑是在Looper.loop()方法中，从MsgQueue中拿出msg，并且执行其逻辑，这是在Looper中执行的，因此有Looper所在线程决定。</p>
</blockquote>
<ul>
<li>MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？</li>
</ul>
<blockquote>
<p>MessageQueue 唤醒机制</p>
</blockquote>
<ul>
<li>Handler的dispatchMessage()分发消息的处理流程？</li>
</ul>
<blockquote>
<p>Msg.callback 在mHandler.post（）中使用, mCallback在new Handler是通过接口回调</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[屏幕适配]]></title>
        <id>https://jxiaow.gitee.io/posts/9233ed3f/</id>
        <link href="https://jxiaow.gitee.io/posts/9233ed3f/">
        </link>
        <updated>2021-01-21T15:00:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dp-和-sp">dp 和 sp</h2>
<p>dp与像素无关， Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时，1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp&gt;1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。</p>
<h2 id="android-布局文件适配">Android 布局文件适配</h2>
<p><strong>Android 分辨率</strong></p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/17/3499134421b76a11b04b406081c0c756-1592361871473-f993ade9-a337-4f81-bac3-0bfa55b45f9c-8f16fe.png" alt="1592361871473f993ade9a3374f81bac30bfa55b45f9c" loading="lazy"></figure>
<p>如果在不同的分辨率上布局文件不一致，我们可以在res目录下，新建一个文件夹，如：layout-1080x720 <strong>数值大的在前面</strong></p>
<h2 id="android使用最小宽度限定符">Android使用最小宽度限定符</h2>
<p>Android开发中最头疼的问题之一就是兼容不同尺寸和分辨率的设备。在使用最小宽度限定符时这个最小宽度的该如何计算。<br>
最小宽度限定符可以使用一个与屏幕像素密度无关为单位（dp）的数值区分出的不同设备，以应用不同的资源。<br>
如下图中values-sw600dp的sw表示最小宽度，那么600dp是如何确定的呢？<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/17/3951c6895aa89c18d0edb4ed07c7422b-1592361824722-3dc4f61f-cf86-4f64-a49d-5b44a9323dfc-6aea5c.jpeg" alt="" loading="lazy"></p>
<p>举个例子：一般情况下我们可以容易知道设备的分辨率和尺寸的参数。比如现在有平板A（分辨率1280<em>720px，尺寸是8inch）， 手机B（分辨率1920</em>1080px，尺寸是5.7inch），手机C（分辨率1280*720px，尺寸是5inch）。通过下面的屏幕像素密度的计算公式，我们可以分别计算出他们的屏幕像素密度：<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/17/c90f834a918dd3c890ff085200b82c99-1592361824704-5e404eb9-c6d6-4892-a694-cb799b7f98d8-307fca.jpeg" alt="" loading="lazy"></p>
<p>平板A约为184dpi，手机B约为386dpi，手机C约为293dpi。<br>
接下里需要注意的是，最小宽度是不考虑横屏或竖屏的，也就是说最小宽度是设备屏幕四条边里最短的那两条边。<br>
如果需要考虑横竖屏那么可以加入屏幕方向限定符，这不在我们讨论之列。那么接下来我们取最短边的像素数，并通过下面的公式计算最小宽度（dp）： 平板A约为626dp，手机B约为448dp，手机C约为393dp。<br>
<img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/17/272d10e130c9cee86c82ad20765303f4-1592361824487-166a5ec5-7be0-44cd-9370-12465939e47d-718378.jpeg" alt="" loading="lazy"></p>
<h2 id="android-studio-插件">Android Studio 插件</h2>
<p>在Android Studio插件市场，我们可以找到<code>ScreenMatch</code>来自动生成dimen.xml文件。</p>
<p>github地址：<a href="https://github.com/mengzhinan/PhoneScreenMatch">GitHub - mengzhinan/PhoneScreenMatch: 屏幕适配方案</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android属性动画]]></title>
        <id>https://jxiaow.gitee.io/posts/c521d2cf/</id>
        <link href="https://jxiaow.gitee.io/posts/c521d2cf/">
        </link>
        <updated>2021-01-21T12:51:11.000Z</updated>
        <content type="html"><![CDATA[<p>属性动画整理的脑图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/21/d78657d763dc999937aadb47a4225b21-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB-6d8276.png" alt="属性动画" loading="lazy"></figure>
<h2 id="基本使用">基本使用</h2>
<h3 id="valueanimator">ValueAnimator</h3>
<p><code>ValueAnimator</code>是整个属性动画机制当中最核心的一个类，属性动画的运行机制是<strong>通过不断地对值进行操作</strong>来实现的，而初始值和结束值之间的动画过渡就是由<code>ValueAnimator</code>这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，确实是一个非常重要的类。</p>
<pre><code class="language-kotlin"> ValueAnimator.ofXXX(0f, 100f, 50f, 100f)
       .apply {
          duration = 300
          addUpdateListener {
          // ...
       }
  }.start()
</code></pre>
<p>ps：<code>ofXXX</code>代表数值类型，可以是<code>ofInt</code>，<code>ofFloat</code>等。</p>
<h3 id="objectanimator">ObjectAnimator</h3>
<p><code>ObjectAnimator</code>继承自<code>ValueAnimator</code>, ValueAnimator是对值进行了一个平滑的动画过渡，而ObjectAnimator 可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。</p>
<pre><code class="language-kotlin">// 设置imageView的透明度属性
ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 1.0f, 0.4f, 1.0f)
    .apply {
        duration = 1000
        startDelay = 300
    }.start()
</code></pre>
<h3 id="propertyvaluesholder">PropertyValuesHolder</h3>
<p><code>PropertyValuesHolder</code>对象可用于通过<code>ValueAnimator</code>或<code>ObjectAnimator</code>创建动画，这些动画可以并行操作多个不同的属性。</p>
<pre><code class="language-kotlin">val holder1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1f, 0.5f)
val holder2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f, 0.5f)
val holder3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0.5f)
val animator: ObjectAnimator =
        ObjectAnimator.ofPropertyValuesHolder(binding.imgIv, holder1, holder2, holder3)
animator.duration = 200
animator.start()
</code></pre>
<h3 id="typeevaluator">TypeEvaluator</h3>
<p>通过<code>ValueAnimator#setEvaluator()</code>方法设置估值器，<code>TypeEvaluator</code>能够支持我们创建支持任意属性类型的动画。</p>
<p>系统内置了一些估值器：</p>
<blockquote>
<p><strong>ArgbEvaluator</strong>, <strong>FloatArrayEvaluator</strong>, <strong>FloatEvaluator</strong>, <strong>IntArrayEvaluator</strong>, <strong>IntEvaluator</strong>, <strong>PointFEvaluator</strong>, <strong>RectEvaluator</strong>， <strong>TypeEvaluator</strong></p>
</blockquote>
<p>我们也可以自定义，如下：</p>
<pre><code class="language-kotlin">ValueAnimator().apply {
    duration = 3000
    setObjectValues(PointF(0f, 0f))
    interpolator = AccelerateInterpolator(10f)
    val point = PointF()
    //自定义估值器
    setEvaluator { fraction, startValue, endValue -&gt;
                  point.x = 100f * (fraction * 5)
                  // y=vt=1/2*g*t*t(重力计算)
                  point.y = 0.5f * 98f * (fraction * 5) * (fraction * 5)
                  point
                 }
    addUpdateListener {
        val p = it.animatedValue as PointF
        imageView.apply {
            x = p.x
            y = p.y
        }
    }
}.start()
</code></pre>
<h3 id="interpolator">Interpolator</h3>
<p><code>Interpolator</code>被用于定义动画的变化速率。也可以说是加速度。系统自带了一些插值器如下：</p>
<ul>
<li>AccelerateDecelerateInterolator：先加速后减速</li>
<li>AccelerateInterpolator：加速</li>
<li>DecelerateInterpolator：减速</li>
<li>AnticipateInterpolator：先向相反方向改变一段再加速播放</li>
<li>AnticipateOvershootInterpolator：先向相反方向改变，再加速播放，会超出目标值然后缓慢移动至目标值，类似于弹簧回弹</li>
<li>BounceInterpolator：快到目标值时值会跳跃</li>
<li>CycleIinterpolator：动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI)</li>
<li>LinearInterpolator：线性均匀改变</li>
<li>OvershottInterpolator：最后超出目标值然后缓慢改变到目标值</li>
<li>TimeInterpolator：一个允许自定义Interpolator的接口，以上都实现了该接口</li>
</ul>
<p>都是通过：<br>
<code>valueAnimator.setInterpolator(new LinearInterpolator());</code><br>
设置即可。</p>
<pre><code class="language-kotlin">ValueAnimator().apply {
    duration = 3000
    setObjectValues(PointF(0f, 0f))
    interpolator = AccelerateInterpolator(10f)
}.start()
</code></pre>
<h3 id="animatorset">AnimatorSet</h3>
<p><code>AnimatorSet</code>是对属性动画的一个集合，可以让很多动画按一定顺序或者 同时进行。</p>
<pre><code class="language-kotlin">val translationXAnimator = ObjectAnimator.ofFloat(binding.imgIv, &quot;translationX&quot;, 0f, 500f)
val alphaAnimator = ObjectAnimator.ofFloat(binding.imgIv, &quot;alpha&quot;, 0f, 1f)
val scaleXAnimator = ObjectAnimator.ofFloat(binding.imgIv, &quot;scaleX&quot;, 0f, 2f)

val animatorSet = AnimatorSet()
animatorSet.duration = 500

// 按照顺序执行
// animatorSet.playSequentially(translationXAnimator, alphaAnimator, scaleXAnimator)
// 一起执行
// animatorSet.playTogether(translationXAnimator, alphaAnimator, scaleXAnimator)
// 链式调用
// animatorSet.play(translationXAnimator).with(alphaAnimator).with(scaleXAnimator)
// after 在 play之前执行  before 在 play之后执行
animatorSet.play(translationXAnimator).after(scaleXAnimator).before(alphaAnimator)
animatorSet.start()
</code></pre>
<h2 id="实战">实战</h2>
<p><a href="https://gitee.com/jxiaow/practiseCodeAndroid/blob/master/AnimationSample/app/src/main/java/com/github/jxiaow/animation/SplashView.kt">xiaow/AndroidPractiseCode: Android 代码练习库 - Gitee.com</a></p>
<h2 id="动画框架">动画框架</h2>
<p><a href="https://gitee.com/jxiaow/practiseCodeAndroid/blob/master/AnimationSample/app/src/main/java/com/github/jxiaow/framework/AnimatorScrollView.kt">xiaow/AndroidPractiseCode: Android 代码练习库 - Gitee.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Klint格式化代码]]></title>
        <id>https://jxiaow.gitee.io/posts/745cbbe1/</id>
        <link href="https://jxiaow.gitee.io/posts/745cbbe1/">
        </link>
        <updated>2021-01-05T02:13:13.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/shyiko/ktlint">ktlint</a> 是一款用来检查Kotlin代码风格的工具，在Android Studio 中可以使用 <a href="https://github.com/diffplug/spotless">spotless</a>。</p>
<p>在 project 下的build.gradle 中：</p>
<pre><code>buildscript {
    // Define versions in a single place
    ext {
        // Sdk and tools
        ktlintVersion = '0.33.0'
    }
}
 
plugins {
    id &quot;com.diffplug.gradle.spotless&quot; version &quot;4.3.0&quot;
}
 
spotless {
    kotlin {
        target &quot;**/*.kt&quot;
        ktlint(ktlintVersion).userData(['max_line_length' : '100'])
    }
}
</code></pre>
<p>设置好后，在控制台输入</p>
<pre><code>gradlew build
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/05/1243d237d8337ca75622d34561a177e6-1592451801894-6b55f217-0517-4bee-acaf-48c5cb326807-062f08.png" alt="image.png" loading="lazy"></figure>
<p>如果有错误的话，就会出现提示，然后再次输入命令：</p>
<pre><code>gradlew :spotlessApply
</code></pre>
<p>即可修复。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 事件分发机制]]></title>
        <id>https://jxiaow.gitee.io/posts/149503c8/</id>
        <link href="https://jxiaow.gitee.io/posts/149503c8/">
        </link>
        <updated>2021-01-04T05:53:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android事件分发机制">Android事件分发机制</h1>
<blockquote>
<p>源码基于 API 30</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/04/66b068244f5dd3120267516cdb214013-Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6-bb31d3.png" alt="Android事件分发机制" loading="lazy"></figure>
<h2 id="activity-事件分发">Activity 事件分发</h2>
<p>流程图：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2020/12/31/1a58b9a8e764d57a34b8a0fa3d260f1e-Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE-e99245.svg" alt="Activity事件分发流程图" loading="lazy"></figure>
<h3 id="activitydispatchtouchevent">Activity#dispatchTouchEvent()</h3>
<pre><code class="language-java">public boolean dispatchTouchEvent(MotionEvent ev) {
    // 一般事件都是从DOWN事件开始，故此处为true
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
</code></pre>
<h3 id="activityonuserinteraction">Activity#onUserInteraction()</h3>
<blockquote>
<p>默认实现为空</p>
<p>当activity在栈顶时，按home，back,menu键时会触发此方法</p>
</blockquote>
<pre><code class="language-java">public void onUserInteraction() {
}
</code></pre>
<h3 id="phonewindowsuperdispatchtouchevent">PhoneWindow#superDispatchTouchEvent()</h3>
<p>在<code>Activity#dispatchTouchEvent</code>中调用了<code>getWindow().superDisaptchTouchEvent()</code>， 而我们知道<code>getWindow()</code>返回的是<code>PhoneWindow</code>，所以 间接的调用了<code>PhoneWindow#superDispatchTouchEvent()</code>。</p>
<pre><code class="language-java">@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}
</code></pre>
<p>从上述方法可以看出，<code>superDispatchTouchEvent</code>调用了<code>mDecor</code>（不在此处详细介绍了）的<code>superDispatchTouchEvent</code>。</p>
<h3 id="decorviewsuperdispatchtouchevent">DecorView#superDispatchTouchEvent()</h3>
<pre><code class="language-java">public boolean superDispatchTouchEvent(MotionEvent event) {
    return super.dispatchTouchEvent(event);
}
</code></pre>
<p><code>DecorView</code>继承自<code>FrameLayout</code>，所以<code>super.dispatchTouchEvent(event)</code>会调用到<code>ViewGroup</code>中的<code>dispatchTouchEvent(event)</code>方法。</p>
<h3 id="activityontouch">Activity#onTouch()</h3>
<p>前面通过源码跟踪了<code>getWindow().superDispatchTouchEvent(ev)</code>的调用过程，现在看一下<code>onTouch()</code>。</p>
<pre><code class="language-java">public boolean onTouchEvent(MotionEvent event) {
    if (mWindow.shouldCloseOnTouch(this, event)) {
        finish();
        return true;
    }
    return false;
}
</code></pre>
<p>当一个点击事件未被<code>Activity</code>下的任何一个<code>view</code>消耗时，就会调用此方法。如： 处理发生在<code>Window</code>边界外的触摸事件。</p>
<h3 id="windowshouldcloseontouch">Window#shouldCloseOnTouch()</h3>
<pre><code class="language-java">public boolean shouldCloseOnTouch(Context context, MotionEvent event) {
    final boolean isOutside =
        event.getAction() == MotionEvent.ACTION_UP &amp;&amp; isOutOfBounds(context, event)
        || event.getAction() == MotionEvent.ACTION_OUTSIDE;
    if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) {
        return true;
    }
    return false;
}
</code></pre>
<p>主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等。</p>
<h2 id="viewgroup-事件分发">ViewGroup 事件分发</h2>
<p>从上面<code>Activity</code>事件分发机制可知，<code>ViewGroup</code>事件分发机制从<code>dispatchTouchEvent()</code>开始。</p>
<h3 id="viewgroupdispatchtouchevent">ViewGroup.dispatchTouchEvent()</h3>
<pre><code class="language-java">@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    // ...
 
    boolean handled = false;
 
    // 过滤掉不安全的事件响应
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;
 
        // DOWN事件下做初始化操作
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            // 取消和清除上一次的触摸对象
            cancelAndClearTouchTargets(ev);
            // 重置触摸状态
            resetTouchState();
        }
 
        // 检查是否需要拦截处理
        // Check for interception.
        final boolean intercepted;
        // DOWN事件或有触摸对象的情况下，检查是否需要做事件拦截处理
        if (actionMasked == MotionEvent.ACTION_DOWN
            || mFirstTouchTarget != null) {
            // 默认情况下是false,子view调用了父view的 requestDisallowInterceptTouchEvent() 改变
            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
            // false的情况下，会调用onInterceptTouchEvent,根据intercepted的值进行判断是否需要拦截
            if (!disallowIntercept) {
                // 一般情况下，不做拦截
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else { // 否则不拦截
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
 
        // If intercepted, start normal event dispatch. Also if there is already
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
 
        // 检查是否需要取消
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this)
            || actionMasked == MotionEvent.ACTION_CANCEL;
 
        // Update list of touch targets for pointer down, if needed.
        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0
            &amp;&amp; !isMouseEvent;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        // 不拦截，不取消的情况下
        if (!canceled &amp;&amp; !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                ? findChildWithAccessibilityFocus() : null;
 
            // DOWN事件处理
            if (actionMasked == MotionEvent.ACTION_DOWN
                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                final int actionIndex = ev.getActionIndex(); // always 0 for down
                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                    : TouchTarget.ALL_POINTER_IDS;
 
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
 
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                    final float x =
                        isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);
                    final float y =
                        isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    // 对当前view下所有的子view根据z轴的值大小，从小到大进行排序
                    final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null
                        &amp;&amp; isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    // 从后往前遍历所有child，将事件传递
                    for (int i = childrenCount - 1; i &gt;= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(
                            childrenCount, i, customOrder);
                        // 获取child
                        final View child = getAndVerifyPreorderedView(
                            preorderedList, children, childIndex);
                        // 如果child不能接收事件或者当前事件未在child内，则寻找下一个child
                        if (!child.canReceivePointerEvents()
                            || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        // 第一次查找，由于mFirstTouchTarget为null,所以newTouchTarget也为null
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
 
                        resetCancelNextUpFlag(child);
                        // 将事件分发到child, 如果child已消耗事件，则返回true
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j &lt; childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            // 事件被child消耗，那么会将child复制给 mFirstTouchTarget和 newTouchTarget, 并结束查找
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
 
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null) preorderedList.clear();
                }
                // 如果已经找到,newTouchTarget 不为空
                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // 如果 mFirstTouchTarget 为 null，表明没有找到需要消耗该事件的child
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // 传递child 为null后，会调用 super.dispatchTouchEvent()，进入view的事件分发中
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                                                    TouchTarget.ALL_POINTER_IDS);
        } else { // 找到了需要拦截的child, 进行后续事件处理
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                    // Down 事件 拦截处理
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                        || intercepted;
                    // 其他事件调用child分发
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                                                      target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // ...
    }
    // ...
    return handled;
}
</code></pre>
<h3 id="viewgrouponfiltertoucheventforsecurity">ViewGroup.onFilterTouchEventForSecurity()</h3>
<p>当视图被隐藏或者窗口被遮挡时，过滤掉该事件响应。</p>
<pre><code class="language-java">public boolean onFilterTouchEventForSecurity(MotionEvent event) {
    //noinspection RedundantIfStatement
    // 当视图被隐藏或者窗口被遮挡时，过滤掉该事件响应
    if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0
        &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
        // Window is obscured, drop this touch.
        return false;
    }
    return true;
}
</code></pre>
<h3 id="viewgrouprequestdisallowintercepttouchevent">ViewGroup.requestDisallowInterceptTouchEvent()</h3>
<p>设置是否允许父view拦截触摸事件， true 不允许，false运行。</p>
<pre><code class="language-java">@Override
public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
 
    if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) {
        // We're already in this state, assume our ancestors are too
        return;
    }
 
    if (disallowIntercept) {
        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;
    } else {
        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
    }
 
    // Pass it up to our parent
    if (mParent != null) {
        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
    }
}
</code></pre>
<h3 id="viewgrouponintercepttouchevent">ViewGroup.onInterceptTouchEvent()</h3>
<p><code>onInterceptTouchEvent</code>的返回值决定当前viewGroup是否要对触摸事件进行拦截，如果为true，则进行拦截并终止事件往下传递，一般情况下不拦截。</p>
<pre><code class="language-java">public boolean onInterceptTouchEvent(MotionEvent ev) {
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN
            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {
        return true;
    }
    return false;
}
</code></pre>
<h3 id="viewgroupbuildtouchdispatchchildlist">ViewGroup.buildTouchDispatchChildList()</h3>
<p>将<code>child</code>根据<code>z</code>轴值的大小进行从小到大排列（即 离用户的远近进行排列）。</p>
<pre><code class="language-java">public ArrayList&lt;View&gt; buildTouchDispatchChildList() {
    return buildOrderedChildList();
}
</code></pre>
<pre><code class="language-java">ArrayList&lt;View&gt; buildOrderedChildList() {
    final int childrenCount = mChildrenCount;
    if (childrenCount &lt;= 1 || !hasChildWithZ()) return null;
 
    if (mPreSortedChildren == null) {
        mPreSortedChildren = new ArrayList&lt;&gt;(childrenCount);
    } else {
        // callers should clear, so clear shouldn't be necessary, but for safety...
        mPreSortedChildren.clear();
        mPreSortedChildren.ensureCapacity(childrenCount);
    }
 
    final boolean customOrder = isChildrenDrawingOrderEnabled();
    // 遍历child，根据getZ()进行排列
    for (int i = 0; i &lt; childrenCount; i++) {
        // add next child (in child order) to end of list
        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        final View nextChild = mChildren[childIndex];
        final float currentZ = nextChild.getZ();
 
        // insert ahead of any Views with greater Z
        int insertIndex = i;
        while (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) {
            insertIndex--;
        }
        mPreSortedChildren.add(insertIndex, nextChild);
    }
    return mPreSortedChildren;
}
</code></pre>
<h3 id="viewgroupgettouchtarget">ViewGroup.getTouchTarget()</h3>
<p>根据child获取触摸的对象，第一次执行时，返回值为null。</p>
<pre><code class="language-java">private TouchTarget getTouchTarget(@NonNull View child) {
    for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
        if (target.child == child) {
            return target;
        }
    }
    return null;
}
</code></pre>
<h3 id="viewgroupdispatchtransformedtouchevent">ViewGroup.dispatchTransformedTouchEvent()</h3>
<p>将当前事件进行child分发，当child为null时，调用<code>super.dispatchTouchEvent()</code>，返回true，代表事件已被消耗。</p>
<pre><code class="language-java">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
                                              View child, int desiredPointerIdBits) {
    final boolean handled;
 
    // Canceling motions is a special case.  We don't need to perform any transformations
    // or filtering.  The important part is the action, not the contents.
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) {
            handled = super.dispatchTouchEvent(event);
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        event.setAction(oldAction);
        return handled;
    }
 
    // Calculate the number of pointers to deliver.
    final int oldPointerIdBits = event.getPointerIdBits();
    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;
 
    // If for some reason we ended up in an inconsistent state where it looks like we
    // might produce a motion event with no pointers in it, then drop the event.
    if (newPointerIdBits == 0) {
        return false;
    }
 
    // If the number of pointers is the same and we don't need to perform any fancy
    // irreversible transformations, then we can reuse the motion event for this
    // dispatch as long as we are careful to revert any changes we make.
    // Otherwise we need to make a copy.
    final MotionEvent transformedEvent;
    if (newPointerIdBits == oldPointerIdBits) {
        if (child == null || child.hasIdentityMatrix()) {
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                final float offsetX = mScrollX - child.mLeft;
                final float offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);
 
                handled = child.dispatchTouchEvent(event);
 
                event.offsetLocation(-offsetX, -offsetY);
            }
            return handled;
        }
        transformedEvent = MotionEvent.obtain(event);
    } else {
        transformedEvent = event.split(newPointerIdBits);
    }
 
    // Perform any necessary transformations and dispatch.
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (!child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }
 
        handled = child.dispatchTouchEvent(transformedEvent);
    }
 
    // Done.
    transformedEvent.recycle();
    return handled;
}
</code></pre>
<h2 id="view-事件分发">View 事件分发</h2>
<h3 id="viewgroupaddtouchtarget">ViewGroup.addTouchTarget()</h3>
<p>获取<code>TouchTarget</code>并将其赋值给<code>mFirstTouchTarget</code>。</p>
<pre><code class="language-java">private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
    target.next = mFirstTouchTarget;
    mFirstTouchTarget = target;
    return target;
}
</code></pre>
<h3 id="viewdispatchtouchevent">View.dispatchTouchEvent()</h3>
<p>touch事件最终会传递到<code>View</code>的<code>dispatchTouchEvent</code>中，根据其返回值决定是否会消耗该事件。</p>
<pre><code class="language-java">public boolean dispatchTouchEvent(MotionEvent event) {
    // ...
    boolean result = false;
 
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    // DOWN事件下停止上一次的滚动事件
    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }
    // 过滤到不安全的事件响应
    if (onFilterTouchEventForSecurity(event)) {
        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {
            result = true;
        }
        // 先处理setOnTouchListener中的onTouch方法，如果返回true，则不再进行方法传递
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
        // 如果mOnTouchListener == null  或 mOnTouchListener.onTouch() 为false,则会调用onTouchEvent()方法。
        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }
 
    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
 
    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn't want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }
 
    return result;
}
</code></pre>
<h2 id="补充点">补充点</h2>
<p><strong>action与actionMasked</strong>的区别：</p>
<blockquote>
<p><strong>相同点：</strong><br>
都表示此次MotionEvent的事件类型-手指按下/移动/抬起</p>
<p><strong>不同点：</strong><br>
action 无法直接识别第二根手指的按下与抬起，而 actionMasked 可以。action 的类型有 按下、移动、抬起，而 actionMasked 有额外两种类型：<br>
ACTION_POINTER_DOWN - “已经有手指按着了，又按下了新手指”<br>
ACTION_POINTER_UP - “手指抬起了，但仍有其它手指按着”</p>
<p><strong>使用建议：</strong><br>
action比actionMasked少了多指识别，适合&quot;检测点击位置&quot;、&quot;记录按下时间&quot;这种只涉及按下抬起的动作。<br>
对于单指拖拽动作要确保用户只用一根手指，不会出现类似“按下第二根手指后抬起第一根手指，继续拖拽”这种临时多指的动作，否则位置会跳。<br>
actionMasked比action更全面，无论处理简单拖拽还是复杂的多指事件都适用。</p>
</blockquote>
<pre><code class="language-kotlin">fun parseActionString(actionMasked: Int): String {
    return when (actionMasked) {
        MotionEvent.ACTION_DOWN -&gt; &quot;按下&quot;
            MotionEvent.ACTION_POINTER_DOWN -&gt; &quot;按下(已有其它触摸点)&quot;
            MotionEvent.ACTION_MOVE -&gt; &quot;移动&quot;
            MotionEvent.ACTION_POINTER_UP -&gt; &quot;抬起(仍留其它触摸点)&quot;
            MotionEvent.ACTION_UP -&gt; &quot;抬起&quot;
            MotionEvent.ACTION_CANCEL -&gt; &quot;取消&quot;
            else -&gt; &quot;未知&quot;
            }
}
</code></pre>
<h2 id="思维导图">思维导图</h2>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/20/bb611881dedbef108831f4feefa3165b-Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6-6d6774.png" alt="Android事件分发机制" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI绘制合集]]></title>
        <id>https://jxiaow.gitee.io/posts/b1e45c68/</id>
        <link href="https://jxiaow.gitee.io/posts/b1e45c68/">
        </link>
        <updated>2020-12-17T09:33:22.000Z</updated>
        <summary type="html"><![CDATA[<p>最近正在整理以前总结的关于 <strong>Android高级UI</strong> 相关的知识，本篇文章只是一个目录，用于进行文章归档。</p>
<h2 id="ui-思维导图">UI 思维导图</h2>
]]></summary>
        <content type="html"><![CDATA[<p>最近正在整理以前总结的关于 <strong>Android高级UI</strong> 相关的知识，本篇文章只是一个目录，用于进行文章归档。</p>
<h2 id="ui-思维导图">UI 思维导图</h2>
<!--more-->
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest/blog-images/2021/01/04/b8784e03ce0e921ad0fbe1a023c28e41-Android-ui-update-50349d.png" alt="Android-ui-update" loading="lazy"></figure>
<h2 id="ui-测量布局绘制流程">UI 测量布局绘制流程</h2>
<h3 id="整体绘制流程"><a href="https://jxiaow.gitee.io/posts/69abe299/">整体绘制流程</a></h3>
<h3 id="布局绘制入口"><a href="https://jxiaow.gitee.io/posts/cd03afe4/">布局绘制入口</a></h3>
<h3 id="测量流程"><a href="https://jxiaow.gitee.io/posts/a920adc7">测量流程</a></h3>
<h3 id="布局流程"><a href="https://jxiaow.gitee.io/posts/6f6ae2ee">布局流程</a></h3>
<h3 id="绘制流程"><a href="https://jxiaow.gitee.io/posts/94ccb851">绘制流程</a></h3>
<h2 id="绘制流程-2">绘制流程</h2>
<h3 id="paint的基本使用"><a href="https://jxiaow.gitee.io/posts/46f22235">Paint的基本使用</a></h3>
<h3 id="paint的高级使用-shader"><a href="https://jxiaow.gitee.io/posts/36c3e87b">Paint的高级使用-Shader</a></h3>
<h3 id="paint的高级使用-滤镜"><a href="https://jxiaow.gitee.io/posts/49e1d711">Paint的高级使用-滤镜</a></h3>
<h3 id="paint的高级使用-xfermode"><a href="https://jxiaow.gitee.io/posts/b2c61861">Paint的高级使用-xfermode</a></h3>
<h3 id="pathmeasure的基本使用"><a href="https://jxiaow.gitee.io/posts/3d90af75">PathMeasure的基本使用</a></h3>
<h2 id="自定义view">自定义view</h2>
<h3 id="自定义view-2"><a href="https://jxiaow.gitee.io/posts/b6d9f081">自定义view</a></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android通过Intent简单实现分享功能]]></title>
        <id>https://jxiaow.gitee.io/posts/73a6d0c4/</id>
        <link href="https://jxiaow.gitee.io/posts/73a6d0c4/">
        </link>
        <updated>2020-12-04T16:03:24.000Z</updated>
        <summary type="html"><![CDATA[<p>现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过<code>Intent</code>方式打开在系统中安装的具有分享功能的App的分享页面。</p>
]]></summary>
        <content type="html"><![CDATA[<p>现在大多数App的分享功能基本上使用的都是微信、QQ、微博的分享sdk或者是集成友盟分享sdk，如果想简单快速的实现分享功能，可以考虑通过<code>Intent</code>方式打开在系统中安装的具有分享功能的App的分享页面。</p>
<!-- more -->
<p>方法如下：</p>
<pre><code class="language-java">public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_SEND);
    intnet.setType(&quot;text/plain&quot;);
    PackageManager packageManager = context.getPackageManager();
    List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0);
    return resloveInfos;
}
</code></pre>
<p>如果只需要QQ和微信分享，可以进行如下操作：</p>
<pre><code class="language-java">public static List&lt;ResolveInfo&gt; shareIntentActivities(Context context){
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_SEND);
    intnet.setType(&quot;text/plain&quot;);
    PackageManager packageManager = context.getPackageManager();
    List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent, 0);
    List&lt;ResolveInfo&gt; shareItems = new ArrayList();    
    for(ResolveInfo info: resolveInfos) {
        String name = info.activityInfo.packageName;
        if (TextUtils.equals(packageName, &quot;com.tencent.mm&quot;)
                    || TextUtils.equals(packageName, &quot;com.tencent.mobileqq&quot;)) {
                shareItems.add(resolveInfo);
        }
    }
    return shareItems;
}
</code></pre>
<p>通过<code>ResolveInfo</code>获取图标<code>ICON</code>和<code>Label</code>:</p>
<pre><code class="language-java">Drawable drawable = resloveInfo.loadIcon(packageManager);
CharSequence label = resolveInfo.loadLabel(packageManager);
</code></pre>
<p>通过<code>Intent</code>发起分享：</p>
<pre><code class="language-java">public static void share(Context context, 
            ResolveInfo info, String shareContent){
    Intent itnent = new Intent();
    intnet.setAction(Intent.ACTION_SEND);
    String pkg = resolveInfo.activityInfo.packageName;
    String cls = resolveInfo.activityInfo.name;
    intent.setComponent(new Component(pkg, cls));
    intent.putExtra(Intent.EXTRA_TEXT, shareContent);
    context.startActivity(intent);
}
</code></pre>
]]></content>
    </entry>
</feed>